From fae9948acc943a9ffd1f79af7568c62c02c4f0bc Mon Sep 17 00:00:00 2001
From: Amit Prakash Ambasta <amit.prakash.ambasta@gmail.com>
Date: Tue, 12 Jan 2021 14:51:15 +0530
Subject: [PATCH 24/24] Allow firefox to build without X11

---
 browser/installer/package-manifest.in         |    2 +
 dom/base/moz.build                            |    2 +-
 dom/base/moz.build.orig                       |  567 ++
 dom/ipc/ContentChild.cpp                      |    4 +-
 dom/plugins/base/nsNPAPIPlugin.cpp            |    4 +-
 dom/plugins/base/nsPluginHost.cpp             |    4 +-
 dom/plugins/ipc/PluginInstanceChild.cpp       |    4 +-
 dom/plugins/ipc/PluginModuleChild.cpp         |    8 +-
 dom/plugins/ipc/PluginModuleChild.h           |    2 +-
 dom/plugins/ipc/moz.build                     |    2 +-
 dom/plugins/test/moz.build                    |    3 +-
 gfx/angle/moz.build.common                    |    2 +
 gfx/angle/moz.build.common.orig               |    7 +
 gfx/gl/GLContextProvider.h                    |   13 +-
 gfx/gl/GLContextProviderEGL.cpp               |    2 +-
 gfx/gl/GLContextProviderWayland.cpp           |   26 +-
 gfx/gl/GLLibraryEGL.cpp                       |    2 +-
 gfx/gl/moz.build                              |    2 +-
 gfx/layers/ipc/CompositorBridgeParent.cpp     |    4 +-
 gfx/thebes/gfxPlatformGtk.cpp                 |    7 +
 .../RenderCompositorEGL.cpp                   |    4 +-
 gfx/webrender_bindings/RenderThread.cpp       |    6 +-
 gfx/webrender_bindings/RenderThread.cpp.orig  | 1213 +++
 layout/xul/nsMenuPopupFrame.cpp               |    9 +-
 old-configure.in                              |    2 +-
 old-configure.in.orig                         | 2828 ++++++
 .../broker/SandboxBrokerPolicyFactory.cpp     |    4 +-
 toolkit/components/remote/moz.build           |   10 +-
 toolkit/components/remote/nsGTKRemoteServer.h |    1 -
 toolkit/components/remote/nsRemoteService.cpp |   22 +-
 toolkit/moz.configure                         |   19 +-
 toolkit/xre/nsAppRunner.cpp                   |    4 +-
 toolkit/xre/nsAppRunner.cpp.orig              | 5598 +++++++++++
 toolkit/xre/nsGDKErrorHandler.cpp             |   15 +-
 widget/CompositorWidget.h                     |    2 +-
 widget/GfxInfoX11.cpp                         |    4 +-
 widget/ScreenManager.cpp                      |    3 +-
 widget/gtk/DMABufLibWrapper.cpp               |    5 +-
 widget/gtk/MozContainer.cpp                   |    1 -
 widget/gtk/MozContainerWayland.cpp            |    1 -
 widget/gtk/ScreenHelperGTK.cpp                |    2 +-
 widget/gtk/WindowSurfaceProvider.cpp          |   20 +-
 widget/gtk/WindowSurfaceProvider.h            |   10 +-
 widget/gtk/components.conf                    |    2 +-
 widget/gtk/moz.build                          |   14 +-
 widget/gtk/mozgtk/moz.build                   |    5 +-
 widget/gtk/mozgtk/mozgtk.c                    |    4 +-
 widget/gtk/mozgtk/mozgtk.c.orig               |  677 ++
 widget/gtk/nsClipboard.cpp                    |    2 +
 widget/gtk/nsClipboardX11.cpp                 |   22 +-
 widget/gtk/nsDragService.cpp                  |    5 +-
 widget/gtk/nsGtkKeyUtils.cpp                  |   30 +-
 widget/gtk/nsGtkKeyUtils.cpp.orig             | 2379 +++++
 widget/gtk/nsGtkKeyUtils.h                    |   12 +-
 widget/gtk/nsLookAndFeel.cpp                  |    2 +
 widget/gtk/nsPrintDialogGTK.cpp               |    7 +-
 widget/gtk/nsUserIdleServiceGTK.cpp           |   14 +-
 widget/gtk/nsUserIdleServiceGTK.h             |   12 +-
 widget/gtk/nsWaylandDisplay.cpp               |    2 +-
 widget/gtk/nsWidgetFactory.cpp                |    4 +-
 widget/gtk/nsWindow.cpp                       |   94 +-
 widget/gtk/nsWindow.cpp.orig                  | 8335 +++++++++++++++++
 widget/gtk/nsWindow.h                         |   12 +-
 widget/gtk/nsWindow.h.orig                    |  714 ++
 widget/moz.build                              |    8 +-
 widget/moz.build.orig                         |  364 +
 66 files changed, 23048 insertions(+), 122 deletions(-)
 create mode 100644 dom/base/moz.build.orig
 create mode 100644 gfx/angle/moz.build.common.orig
 create mode 100644 gfx/webrender_bindings/RenderThread.cpp.orig
 create mode 100644 old-configure.in.orig
 create mode 100644 toolkit/xre/nsAppRunner.cpp.orig
 create mode 100644 widget/gtk/mozgtk/mozgtk.c.orig
 create mode 100644 widget/gtk/nsGtkKeyUtils.cpp.orig
 create mode 100644 widget/gtk/nsWindow.cpp.orig
 create mode 100644 widget/gtk/nsWindow.h.orig
 create mode 100644 widget/moz.build.orig

diff --git a/browser/installer/package-manifest.in b/browser/installer/package-manifest.in
index 75c79a7168..afd98f182e 100644
--- a/browser/installer/package-manifest.in
+++ b/browser/installer/package-manifest.in
@@ -107,7 +107,9 @@
 #endif
 #ifdef MOZ_GTK
 @BINPATH@/@DLL_PREFIX@mozgtk@DLL_SUFFIX@
+#ifdef MOZ_X11
 @BINPATH@/gtk2/@DLL_PREFIX@mozgtk@DLL_SUFFIX@
+#endif
 #ifdef MOZ_WAYLAND
 @BINPATH@/@DLL_PREFIX@mozwayland@DLL_SUFFIX@
 #endif
diff --git a/dom/base/moz.build b/dom/base/moz.build
index 50aac7ed1d..4cf84b8d2c 100644
--- a/dom/base/moz.build
+++ b/dom/base/moz.build
@@ -543,7 +543,7 @@ FINAL_LIBRARY = "xul"
 if CONFIG["MOZ_BUILD_APP"] in ["browser", "mobile/android", "xulrunner"]:
     DEFINES["HAVE_SIDEBAR"] = True
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     CXXFLAGS += CONFIG["TK_CFLAGS"]
 
 if CONFIG["MOZ_SYSTEM_HARFBUZZ"]:
diff --git a/dom/base/moz.build.orig b/dom/base/moz.build.orig
new file mode 100644
index 0000000000..50aac7ed1d
--- /dev/null
+++ b/dom/base/moz.build.orig
@@ -0,0 +1,567 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+with Files("*Selection*"):
+    BUG_COMPONENT = ("Core", "DOM: Selection")
+
+with Files("**"):
+    BUG_COMPONENT = ("Core", "DOM: Core & HTML")
+
+TEST_DIRS += ["test"]
+
+XPIDL_SOURCES += [
+    "mozIDOMWindow.idl",
+    "nsIContentPolicy.idl",
+    "nsIDOMRequestService.idl",
+    "nsIDroppedLinkHandler.idl",
+    "nsIEventSourceEventService.idl",
+    "nsIImageLoadingContent.idl",
+    "nsIMessageManager.idl",
+    "nsIObjectLoadingContent.idl",
+    "nsIScriptableContentIterator.idl",
+    "nsIScriptChannel.idl",
+    "nsISelectionController.idl",
+    "nsISelectionDisplay.idl",
+    "nsISelectionListener.idl",
+    "nsISlowScriptDebug.idl",
+]
+
+XPIDL_MODULE = "dom"
+
+EXPORTS += [
+    "AttrArray.h",
+    "AutocompleteFieldList.h",
+    "Crypto.h",
+    "HTMLSplitOnSpacesTokenizer.h",
+    "IframeSandboxKeywordList.h",
+    "mozAutoDocUpdate.h",
+    "NodeUbiReporting.h",
+    "nsAttrName.h",
+    "nsAttrValue.h",
+    "nsAttrValueInlines.h",
+    "nsCaseTreatment.h",
+    "nsChildContentList.h",
+    "nsContentCID.h",
+    "nsContentCreatorFunctions.h",
+    "nsContentList.h",
+    "nsContentListDeclarations.h",
+    "nsContentPermissionHelper.h",
+    "nsContentPolicyUtils.h",
+    "nsContentSink.h",
+    "nsContentTypeParser.h",
+    "nsContentUtils.h",
+    "nsCopySupport.h",
+    "nsDeprecatedOperationList.h",
+    "nsDocElementCreatedNotificationRunner.h",
+    "nsDocumentWarningList.h",
+    "nsDOMAttributeMap.h",
+    "nsDOMCID.h",
+    "nsDOMJSUtils.h",
+    "nsDOMMutationObserver.h",
+    "nsDOMNavigationTiming.h",
+    "nsDOMString.h",
+    "nsDOMTokenList.h",
+    "nsFocusManager.h",
+    "nsFrameLoader.h",  # Because binding headers include it.
+    "nsFrameLoaderOwner.h",
+    "nsFrameMessageManager.h",
+    "nsGlobalWindow.h",  # Because binding headers include it.
+    "nsGlobalWindowInner.h",  # Because binding headers include it.
+    "nsGlobalWindowOuter.h",  # Because binding headers include it.
+    "nsIAnimationObserver.h",
+    "nsIContent.h",
+    "nsIContentInlines.h",
+    "nsIDocumentObserver.h",
+    "nsIGlobalObject.h",
+    "nsImageLoadingContent.h",
+    "nsIMutationObserver.h",
+    "nsINode.h",
+    "nsINodeList.h",
+    "nsIScriptContext.h",
+    "nsIScriptGlobalObject.h",
+    "nsIScriptObjectPrincipal.h",
+    "nsJSEnvironment.h",
+    "nsJSUtils.h",
+    "nsLineBreaker.h",
+    "nsMappedAttributeElement.h",
+    "nsNameSpaceManager.h",
+    "nsNodeInfoManager.h",
+    "nsPIDOMWindow.h",
+    "nsPIDOMWindowInlines.h",
+    "nsPIWindowRoot.h",
+    "nsPropertyTable.h",
+    "nsRange.h",
+    "nsSandboxFlags.h",
+    "nsStructuredCloneContainer.h",
+    "nsStubAnimationObserver.h",
+    "nsStubDocumentObserver.h",
+    "nsStubMutationObserver.h",
+    "nsStyledElement.h",
+    "nsTextFragment.h",
+    "nsTraversal.h",
+    "nsTreeSanitizer.h",
+    "nsViewportInfo.h",
+    "nsWindowMemoryReporter.h",
+    "nsWindowSizes.h",
+    "nsWrapperCache.h",
+    "nsWrapperCacheInlines.h",
+    "XPathGenerator.h",
+]
+
+if CONFIG["MOZ_WEBRTC"]:
+    EXPORTS += [
+        "nsDOMDataChannel.h",
+        "nsDOMDataChannelDeclarations.h",
+    ]
+
+EXPORTS.mozilla += [
+    "CallState.h",
+    "ContentIterator.h",
+    "CORSMode.h",
+    "FlushType.h",
+    "FullscreenChange.h",
+    "IdentifierMapEntry.h",
+    "RangeBoundary.h",
+    "RangeUtils.h",
+    "ScriptableContentIterator.h",
+    "SelectionChangeEventDispatcher.h",
+    "TextInputProcessor.h",
+    "UseCounter.h",
+]
+
+EXPORTS.mozilla.dom += [
+    "!UseCounterList.h",
+    "!UseCounterWorkerList.h",
+    "AbstractRange.h",
+    "AncestorIterator.h",
+    "AnonymousContent.h",
+    "Attr.h",
+    "AutoPrintEventDispatcher.h",
+    "AutoSuppressEventHandlingAndSuspend.h",
+    "BarProps.h",
+    "BindContext.h",
+    "BodyConsumer.h",
+    "BodyStream.h",
+    "BodyUtil.h",
+    "BorrowedAttrInfo.h",
+    "CharacterData.h",
+    "ChildIterator.h",
+    "ChildProcessMessageManager.h",
+    "ChromeMessageBroadcaster.h",
+    "ChromeMessageSender.h",
+    "ChromeNodeList.h",
+    "ChromeUtils.h",
+    "Comment.h",
+    "ContentFrameMessageManager.h",
+    "ContentProcessMessageManager.h",
+    "CustomElementRegistry.h",
+    "DirectionalityUtils.h",
+    "DispatcherTrait.h",
+    "DocGroup.h",
+    "Document.h",
+    "DocumentFragment.h",
+    "DocumentInlines.h",
+    "DocumentOrShadowRoot.h",
+    "DocumentType.h",
+    "DOMArena.h",
+    "DOMException.h",
+    "DOMImplementation.h",
+    "DOMIntersectionObserver.h",
+    "DOMMatrix.h",
+    "DOMMozPromiseRequestHolder.h",
+    "DOMParser.h",
+    "DOMPoint.h",
+    "DOMQuad.h",
+    "DOMRect.h",
+    "DOMRequest.h",
+    "DOMStringList.h",
+    "DOMTokenListSupportedTokens.h",
+    "Element.h",
+    "ElementInlines.h",
+    "EventSource.h",
+    "EventSourceEventService.h",
+    "FilteredNodeIterator.h",
+    "FormData.h",
+    "FragmentOrElement.h",
+    "FromParser.h",
+    "GeneratedImageContent.h",
+    "IdleDeadline.h",
+    "IdleRequest.h",
+    "IDTracker.h",
+    "ImageEncoder.h",
+    "ImageTracker.h",
+    "IntlUtils.h",
+    "JSExecutionContext.h",
+    "Link.h",
+    "LinkStyle.h",
+    "Location.h",
+    "LocationBase.h",
+    "MaybeCrossOriginObject.h",
+    "MessageBroadcaster.h",
+    "MessageListenerManager.h",
+    "MessageManagerCallback.h",
+    "MessageManagerGlobal.h",
+    "MessageSender.h",
+    "MimeType.h",
+    "MozQueryInterface.h",
+    "MutationObservers.h",
+    "NameSpaceConstants.h",
+    "Navigator.h",
+    "NodeInfo.h",
+    "NodeInfoInlines.h",
+    "NodeIterator.h",
+    "ParentProcessMessageManager.h",
+    "PlacesBookmark.h",
+    "PlacesBookmarkAddition.h",
+    "PlacesBookmarkRemoved.h",
+    "PlacesEvent.h",
+    "PlacesFavicon.h",
+    "PlacesObservers.h",
+    "PlacesVisit.h",
+    "PlacesWeakCallbackWrapper.h",
+    "PopupBlocker.h",
+    "Pose.h",
+    "PostMessageEvent.h",
+    "ProcessMessageManager.h",
+    "ResizeObserver.h",
+    "ResizeObserverController.h",
+    "ResponsiveImageSelector.h",
+    "SameProcessMessageQueue.h",
+    "ScreenLuminance.h",
+    "ScreenOrientation.h",
+    "Selection.h",
+    "SerializedStackHolder.h",
+    "ShadowIncludingTreeIterator.h",
+    "ShadowRoot.h",
+    "StaticRange.h",
+    "StructuredCloneBlob.h",
+    "StructuredCloneHolder.h",
+    "StructuredCloneTags.h",
+    "StructuredCloneTester.h",
+    "StyledRange.h",
+    "StyleSheetList.h",
+    "SubtleCrypto.h",
+    "SyncMessageSender.h",
+    "Text.h",
+    "Timeout.h",
+    "TimeoutHandler.h",
+    "TimeoutManager.h",
+    "TreeIterator.h",
+    "TreeOrderedArray.h",
+    "TreeOrderedArrayInlines.h",
+    "TreeWalker.h",
+    "UIDirectionManager.h",
+    "UserActivation.h",
+    "ViewportMetaData.h",
+    "VisualViewport.h",
+    "WindowFeatures.h",
+    "WindowOrientationObserver.h",
+    "WindowProxyHolder.h",
+]
+
+if CONFIG["FUZZING"]:
+    EXPORTS.mozilla.dom += [
+        "FuzzingFunctions.h",
+    ]
+
+UNIFIED_SOURCES += [
+    "AbstractRange.cpp",
+    "AnonymousContent.cpp",
+    "Attr.cpp",
+    "AttrArray.cpp",
+    "BarProps.cpp",
+    "BindContext.cpp",
+    "BodyConsumer.cpp",
+    "BodyStream.cpp",
+    "BodyUtil.cpp",
+    "BorrowedAttrInfo.cpp",
+    "CharacterData.cpp",
+    "ChildIterator.cpp",
+    "ChromeMessageBroadcaster.cpp",
+    "ChromeMessageSender.cpp",
+    "ChromeNodeList.cpp",
+    "ChromeUtils.cpp",
+    "Comment.cpp",
+    "ContentFrameMessageManager.cpp",
+    "ContentIterator.cpp",
+    "ContentProcessMessageManager.cpp",
+    "Crypto.cpp",
+    "CustomElementRegistry.cpp",
+    "DirectionalityUtils.cpp",
+    "DispatcherTrait.cpp",
+    "DocGroup.cpp",
+    "Document.cpp",
+    "DocumentFragment.cpp",
+    "DocumentOrShadowRoot.cpp",
+    "DocumentType.cpp",
+    "DOMException.cpp",
+    "DOMImplementation.cpp",
+    "DOMMatrix.cpp",
+    "DOMParser.cpp",
+    "DOMPoint.cpp",
+    "DOMQuad.cpp",
+    "DOMRect.cpp",
+    "DOMRequest.cpp",
+    "DOMStringList.cpp",
+    "Element.cpp",
+    "EventSource.cpp",
+    "EventSourceEventService.cpp",
+    "FormData.cpp",
+    "FragmentOrElement.cpp",
+    "GeneratedImageContent.cpp",
+    "IdleDeadline.cpp",
+    "IdleRequest.cpp",
+    "IDTracker.cpp",
+    "ImageEncoder.cpp",
+    "ImageTracker.cpp",
+    "InProcessBrowserChildMessageManager.cpp",
+    "IntlUtils.cpp",
+    "JSExecutionContext.cpp",
+    "Link.cpp",
+    "LinkStyle.cpp",
+    "Location.cpp",
+    "LocationBase.cpp",
+    "MaybeCrossOriginObject.cpp",
+    "MessageBroadcaster.cpp",
+    "MessageListenerManager.cpp",
+    "MessageManagerGlobal.cpp",
+    "MessageSender.cpp",
+    "MimeType.cpp",
+    "MozQueryInterface.cpp",
+    "MutationObservers.cpp",
+    "Navigator.cpp",
+    "NodeInfo.cpp",
+    "NodeIterator.cpp",
+    "NodeUbiReporting.cpp",
+    "nsAttrValue.cpp",
+    "nsAttrValueOrString.cpp",
+    "nsCCUncollectableMarker.cpp",
+    "nsContentAreaDragDrop.cpp",
+    "nsContentList.cpp",
+    "nsContentPermissionHelper.cpp",
+    "nsContentPolicy.cpp",
+    "nsContentSink.cpp",
+    "nsContentTypeParser.cpp",
+    "nsCopySupport.cpp",
+    "nsDataDocumentContentPolicy.cpp",
+    "nsDOMAttributeMap.cpp",
+    "nsDOMCaretPosition.cpp",
+    "nsDOMMutationObserver.cpp",
+    "nsDOMNavigationTiming.cpp",
+    "nsDOMTokenList.cpp",
+    "nsFocusManager.cpp",
+    "nsFrameLoader.cpp",
+    "nsFrameLoaderOwner.cpp",
+    "nsGlobalWindowCommands.cpp",
+    "nsHistory.cpp",
+    "nsIGlobalObject.cpp",
+    "nsINode.cpp",
+    "nsJSEnvironment.cpp",
+    "nsJSUtils.cpp",
+    "nsLineBreaker.cpp",
+    "nsMappedAttributeElement.cpp",
+    "nsMappedAttributes.cpp",
+    "nsMimeTypeArray.cpp",
+    "nsNameSpaceManager.cpp",
+    "nsNoDataProtocolContentPolicy.cpp",
+    "nsNodeInfoManager.cpp",
+    "nsOpenURIInFrameParams.cpp",
+    "nsPropertyTable.cpp",
+    "nsQueryContentEventResult.cpp",
+    "nsRange.cpp",
+    "nsScreen.cpp",
+    "nsStructuredCloneContainer.cpp",
+    "nsStubAnimationObserver.cpp",
+    "nsStubDocumentObserver.cpp",
+    "nsStubMutationObserver.cpp",
+    "nsStyledElement.cpp",
+    "nsSyncLoadService.cpp",
+    "nsTextFragment.cpp",
+    "nsTextNode.cpp",
+    "nsTraversal.cpp",
+    "nsTreeSanitizer.cpp",
+    "nsViewportInfo.cpp",
+    "nsWindowMemoryReporter.cpp",
+    "nsWindowRoot.cpp",
+    "nsWrapperCache.cpp",
+    "ParentProcessMessageManager.cpp",
+    "PopupBlocker.cpp",
+    "Pose.cpp",
+    "PostMessageEvent.cpp",
+    "ProcessMessageManager.cpp",
+    "RangeUtils.cpp",
+    "RemoteOuterWindowProxy.cpp",
+    "ResizeObserver.cpp",
+    "ResizeObserverController.cpp",
+    "ResponsiveImageSelector.cpp",
+    "SameProcessMessageQueue.cpp",
+    "ScreenLuminance.cpp",
+    "ScreenOrientation.cpp",
+    "ScriptableContentIterator.cpp",
+    "Selection.cpp",
+    "SelectionChangeEventDispatcher.cpp",
+    "SerializedStackHolder.cpp",
+    "ShadowRoot.cpp",
+    "StaticRange.cpp",
+    "StorageAccessPermissionRequest.cpp",
+    "StructuredCloneBlob.cpp",
+    "StructuredCloneHolder.cpp",
+    "StructuredCloneTester.cpp",
+    "StyledRange.cpp",
+    "StyleSheetList.cpp",
+    "SubtleCrypto.cpp",
+    "Text.cpp",
+    "TextInputProcessor.cpp",
+    "ThirdPartyUtil.cpp",
+    "Timeout.cpp",
+    "TimeoutBudgetManager.cpp",
+    "TimeoutExecutor.cpp",
+    "TimeoutHandler.cpp",
+    "TimeoutManager.cpp",
+    "TreeWalker.cpp",
+    "UIDirectionManager.cpp",
+    "UserActivation.cpp",
+    "ViewportMetaData.cpp",
+    "VisualViewport.cpp",
+    "WindowDestroyedEvent.cpp",
+    "WindowFeatures.cpp",
+    "WindowNamedPropertiesHandler.cpp",
+    "WindowOrientationObserver.cpp",
+    "XPathGenerator.cpp",
+]
+
+if CONFIG["MOZ_WEBRTC"]:
+    UNIFIED_SOURCES += [
+        "nsDOMDataChannel.cpp",
+    ]
+
+if CONFIG["FUZZING"]:
+    UNIFIED_SOURCES += [
+        "FuzzingFunctions.cpp",
+    ]
+
+if CONFIG["MOZ_PLACES"]:
+    UNIFIED_SOURCES += [
+        "PlacesEvent.cpp",
+        "PlacesObservers.cpp",
+        "PlacesWeakCallbackWrapper.cpp",
+    ]
+
+# these files couldn't be in UNIFIED_SOURCES for now for reasons given below:
+SOURCES += [
+    # Several conflicts with other bindings.
+    "DOMIntersectionObserver.cpp",
+    # Because of OS X headers.
+    "nsContentUtils.cpp",
+    # this file doesn't like windows.h
+    "nsDOMWindowUtils.cpp",
+    # Conflicts with windows.h's definition of SendMessage.
+    "nsFrameMessageManager.cpp",
+    # These files have a #error "Never include unwrapped windows.h in this file!"
+    "nsGlobalWindowInner.cpp",
+    "nsGlobalWindowOuter.cpp",
+    # Conflicts with windows.h's definition of LoadImage.
+    "nsImageLoadingContent.cpp",
+    # Because of OS X headers.
+    "nsObjectLoadingContent.cpp",
+    # nsPluginArray.cpp includes npapi.h indirectly, and that includes a lot of system headers
+    "nsPluginArray.cpp",
+]
+
+# Are we targeting x86-32 or x86-64?  If so, we want to include SSE2 code for
+# nsTextFragment.cpp
+if CONFIG["INTEL_ARCHITECTURE"]:
+    SOURCES += ["nsTextFragmentSSE2.cpp"]
+    SOURCES["nsTextFragmentSSE2.cpp"].flags += CONFIG["SSE2_FLAGS"]
+
+# Are we targeting PowerPC? If so, we can enable a SIMD version for
+# nsTextFragment.cpp as well.
+if CONFIG["CPU_ARCH"].startswith("ppc"):
+    SOURCES += ["nsTextFragmentVMX.cpp"]
+    SOURCES["nsTextFragmentVMX.cpp"].flags += CONFIG["PPC_VMX_FLAGS"]
+
+EXTRA_JS_MODULES += [
+    "ContentAreaDropListener.jsm",
+    "DOMRequestHelper.jsm",
+    "IndexedDBHelper.jsm",
+    "LocationHelper.jsm",
+    "ProcessSelector.jsm",
+    "SlowScriptDebug.jsm",
+]
+
+XPCOM_MANIFESTS += [
+    "components.conf",
+]
+
+LOCAL_INCLUDES += [
+    "../battery",
+    "../events",
+    "../media",
+    "../network",
+    "/caps",
+    "/docshell/base",
+    "/dom/base",
+    "/dom/file",
+    "/dom/geolocation",
+    "/dom/html",
+    "/dom/ipc",
+    "/dom/storage",
+    "/dom/svg",
+    "/dom/u2f",
+    "/dom/xml",
+    "/dom/xslt/xpath",
+    "/dom/xul",
+    "/gfx/2d",
+    "/image",
+    "/js/xpconnect/loader",
+    "/js/xpconnect/src",
+    "/js/xpconnect/wrappers",
+    "/layout/base",
+    "/layout/forms",
+    "/layout/generic",
+    "/layout/style",
+    "/layout/xul",
+    "/netwerk/base",
+    "/netwerk/url-classifier",
+    "/security/manager/ssl",
+    "/widget",
+    "/xpcom/ds",
+]
+
+if CONFIG["MOZ_WEBRTC"]:
+    LOCAL_INCLUDES += [
+        "/netwerk/sctp/datachannel",
+    ]
+
+include("/ipc/chromium/chromium-config.mozbuild")
+
+FINAL_LIBRARY = "xul"
+
+if CONFIG["MOZ_BUILD_APP"] in ["browser", "mobile/android", "xulrunner"]:
+    DEFINES["HAVE_SIDEBAR"] = True
+
+if CONFIG["MOZ_X11"]:
+    CXXFLAGS += CONFIG["TK_CFLAGS"]
+
+if CONFIG["MOZ_SYSTEM_HARFBUZZ"]:
+    CXXFLAGS += CONFIG["MOZ_HARFBUZZ_CFLAGS"]
+
+GeneratedFile(
+    "UseCounterList.h",
+    script="gen-usecounters.py",
+    entry_point="use_counter_list",
+    inputs=["UseCounters.conf"],
+)
+
+GeneratedFile(
+    "UseCounterWorkerList.h",
+    script="gen-usecounters.py",
+    entry_point="use_counter_list",
+    inputs=["UseCountersWorker.conf"],
+)
+
+if CONFIG["CC_TYPE"] in ("clang", "gcc"):
+    CXXFLAGS += ["-Wno-error=shadow"]
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
index 124be0cdf7..9dbd6639a4 100644
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -5,7 +5,9 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifdef MOZ_WIDGET_GTK
-#  include <gdk/gdkx.h>
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#  endif
 #  include <gtk/gtk.h>
 #endif
 
diff --git a/dom/plugins/base/nsNPAPIPlugin.cpp b/dom/plugins/base/nsNPAPIPlugin.cpp
index 6d302573b4..3549ed5594 100644
--- a/dom/plugins/base/nsNPAPIPlugin.cpp
+++ b/dom/plugins/base/nsNPAPIPlugin.cpp
@@ -60,7 +60,9 @@
 // needed for nppdf plugin
 #if (MOZ_WIDGET_GTK)
 #  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#  endif
 #endif
 
 #include "nsJSUtils.h"
diff --git a/dom/plugins/base/nsPluginHost.cpp b/dom/plugins/base/nsPluginHost.cpp
index 4cc7d89e59..baa7a0ec05 100644
--- a/dom/plugins/base/nsPluginHost.cpp
+++ b/dom/plugins/base/nsPluginHost.cpp
@@ -114,7 +114,9 @@
 #endif
 #if (MOZ_WIDGET_GTK)
 #  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#  endif
 #endif
 
 using namespace mozilla;
diff --git a/dom/plugins/ipc/PluginInstanceChild.cpp b/dom/plugins/ipc/PluginInstanceChild.cpp
index 8e454827a8..069fd9d4b3 100644
--- a/dom/plugins/ipc/PluginInstanceChild.cpp
+++ b/dom/plugins/ipc/PluginInstanceChild.cpp
@@ -48,7 +48,9 @@ using namespace mozilla::widget;
 #ifdef MOZ_WIDGET_GTK
 
 #  include <gtk/gtk.h>
-#  include <gdk/gdkx.h>
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#  endif
 #  include <gdk/gdk.h>
 
 #elif defined(OS_WIN)
diff --git a/dom/plugins/ipc/PluginModuleChild.cpp b/dom/plugins/ipc/PluginModuleChild.cpp
index 81eb8467d4..7f1b771075 100644
--- a/dom/plugins/ipc/PluginModuleChild.cpp
+++ b/dom/plugins/ipc/PluginModuleChild.cpp
@@ -14,7 +14,9 @@
 
 #ifdef MOZ_WIDGET_GTK
 #  include <gtk/gtk.h>
-#  include <gdk/gdkx.h>
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#  endif
 #endif
 
 #include "nsIFile.h"
@@ -331,7 +333,7 @@ bool PluginModuleChild::InitForChrome(const std::string& aPluginFilename,
   return true;
 }
 
-#if defined(MOZ_WIDGET_GTK)
+#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
 
 typedef void (*GObjectDisposeFn)(GObject*);
 typedef gboolean (*GtkWidgetScrollEventFn)(GtkWidget*, GdkEventScroll*);
@@ -551,7 +553,7 @@ bool PluginModuleChild::ShouldContinueFromReplyTimeout() {
 }
 
 bool PluginModuleChild::InitGraphics() {
-#if defined(MOZ_WIDGET_GTK)
+#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
   // Work around plugins that don't interact well with GDK
   // client-side windows.
   PR_SetEnv("GDK_NATIVE_WINDOWS=1");
diff --git a/dom/plugins/ipc/PluginModuleChild.h b/dom/plugins/ipc/PluginModuleChild.h
index 31d4eafb8f..7d64d7f39a 100644
--- a/dom/plugins/ipc/PluginModuleChild.h
+++ b/dom/plugins/ipc/PluginModuleChild.h
@@ -210,7 +210,7 @@ class PluginModuleChild : public PPluginModuleChild {
   bool InitGraphics();
   void DeinitGraphics();
 
-#if defined(MOZ_WIDGET_GTK)
+#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
   static gboolean DetectNestedEventLoop(gpointer data);
   static gboolean ProcessBrowserEvents(gpointer data);
 
diff --git a/dom/plugins/ipc/moz.build b/dom/plugins/ipc/moz.build
index 62a726e25c..8047987afa 100644
--- a/dom/plugins/ipc/moz.build
+++ b/dom/plugins/ipc/moz.build
@@ -137,7 +137,7 @@ if CONFIG["MOZ_SANDBOX"] and CONFIG["OS_ARCH"] == "WINNT":
 
 DEFINES["FORCE_PR_LOG"] = True
 
-if CONFIG["MOZ_WIDGET_TOOLKIT"] != "gtk":
+if CONFIG["MOZ_WIDGET_TOOLKIT"] != "gtk" or not CONFIG['MOZ_X11']:
     CXXFLAGS += CONFIG["TK_CFLAGS"]
 else:
     # Force build against gtk+2 for struct offsets and such.
diff --git a/dom/plugins/test/moz.build b/dom/plugins/test/moz.build
index 7f40fb3cbe..3320aaf009 100644
--- a/dom/plugins/test/moz.build
+++ b/dom/plugins/test/moz.build
@@ -4,7 +4,8 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-DIRS += ["testplugin"]
+if CONFIG["MOZ_X11"]:
+    DIRS += ["testplugin"]
 
 if CONFIG["MOZ_WIDGET_TOOLKIT"] in ("gtk", "cocoa", "windows"):
     MOCHITEST_MANIFESTS += ["mochitest/mochitest.ini"]
diff --git a/gfx/angle/moz.build.common b/gfx/angle/moz.build.common
index 1179d9121d..485d69783b 100644
--- a/gfx/angle/moz.build.common
+++ b/gfx/angle/moz.build.common
@@ -5,3 +5,5 @@ if CONFIG['INTEL_ARCHITECTURE']:
 DEFINES['__NDK_FPABI__'] = ''
 DEFINES['ANGLE_SKIP_DXGI_1_2_CHECK'] = True
 DEFINES['ANGLE_ENABLE_KEYEDMUTEX'] = True
+if CONFIG["MOZ_WAYLAND"]:
+    CXXFLAGS += [ "-DWL_EGL_PLATFORM" ]
diff --git a/gfx/angle/moz.build.common.orig b/gfx/angle/moz.build.common.orig
new file mode 100644
index 0000000000..1179d9121d
--- /dev/null
+++ b/gfx/angle/moz.build.common.orig
@@ -0,0 +1,7 @@
+AllowCompilerWarnings()
+
+if CONFIG['INTEL_ARCHITECTURE']:
+    CXXFLAGS += CONFIG['SSE2_FLAGS']
+DEFINES['__NDK_FPABI__'] = ''
+DEFINES['ANGLE_SKIP_DXGI_1_2_CHECK'] = True
+DEFINES['ANGLE_ENABLE_KEYEDMUTEX'] = True
diff --git a/gfx/gl/GLContextProvider.h b/gfx/gl/GLContextProvider.h
index 12d1a497b9..274122b1df 100644
--- a/gfx/gl/GLContextProvider.h
+++ b/gfx/gl/GLContextProvider.h
@@ -48,6 +48,13 @@ namespace gl {
 #include "GLContextProviderImpl.h"
 #undef GL_CONTEXT_PROVIDER_NAME
 
+#if defined(MOZ_WAYLAND)
+#  define GL_CONTEXT_PROVIDER_NAME GLContextProviderWayland
+#  include "GLContextProviderImpl.h"
+#  undef GL_CONTEXT_PROVIDER_NAME
+#  define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderWayland
+#endif
+
 #if defined(MOZ_X11)
 #  define GL_CONTEXT_PROVIDER_NAME GLContextProviderGLX
 #  include "GLContextProviderImpl.h"
@@ -55,12 +62,6 @@ namespace gl {
 #  define GL_CONTEXT_PROVIDER_NAME GLContextProviderX11
 #  include "GLContextProviderImpl.h"
 #  undef GL_CONTEXT_PROVIDER_NAME
-#  if defined(MOZ_WAYLAND)
-#    define GL_CONTEXT_PROVIDER_NAME GLContextProviderWayland
-#    include "GLContextProviderImpl.h"
-#    undef GL_CONTEXT_PROVIDER_NAME
-#    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderWayland
-#  endif
 #  ifndef GL_CONTEXT_PROVIDER_DEFAULT
 #    define GL_CONTEXT_PROVIDER_DEFAULT GLContextProviderX11
 #  endif
diff --git a/gfx/gl/GLContextProviderEGL.cpp b/gfx/gl/GLContextProviderEGL.cpp
index 67b9c6a2ad..2d179155a1 100644
--- a/gfx/gl/GLContextProviderEGL.cpp
+++ b/gfx/gl/GLContextProviderEGL.cpp
@@ -93,7 +93,7 @@ inline bool IsWaylandDisplay() {
 }
 
 inline bool IsX11Display() {
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
   return gdk_display_get_default() &&
          GDK_IS_X11_DISPLAY(gdk_display_get_default());
 #else
diff --git a/gfx/gl/GLContextProviderWayland.cpp b/gfx/gl/GLContextProviderWayland.cpp
index 4f7c15380c..0603311843 100644
--- a/gfx/gl/GLContextProviderWayland.cpp
+++ b/gfx/gl/GLContextProviderWayland.cpp
@@ -5,7 +5,9 @@
 
 #ifdef MOZ_WIDGET_GTK
 #  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#  endif
 #endif
 
 #include "GLContextProvider.h"
@@ -15,16 +17,21 @@ namespace mozilla::gl {
 using namespace mozilla::gfx;
 using namespace mozilla::widget;
 
+#ifdef MOZ_X11
 static class GLContextProviderX11 sGLContextProviderX11;
+#endif
 static class GLContextProviderEGL sGLContextProviderEGL;
 
 already_AddRefed<GLContext> GLContextProviderWayland::CreateForCompositorWidget(
     CompositorWidget* aCompositorWidget, bool aWebRender,
     bool aForceAccelerated) {
+#ifdef MOZ_X11
   if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
     return sGLContextProviderX11.CreateForCompositorWidget(
         aCompositorWidget, aWebRender, aForceAccelerated);
-  } else {
+  } else 
+#endif
+  {
     return sGLContextProviderEGL.CreateForCompositorWidget(
         aCompositorWidget, aWebRender, aForceAccelerated);
   }
@@ -33,27 +40,36 @@ already_AddRefed<GLContext> GLContextProviderWayland::CreateForCompositorWidget(
 /*static*/
 already_AddRefed<GLContext> GLContextProviderWayland::CreateHeadless(
     const GLContextCreateDesc& desc, nsACString* const out_failureId) {
+#ifdef MOZ_X11
   if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
     return sGLContextProviderX11.CreateHeadless(desc, out_failureId);
-  } else {
+  } else 
+#endif
+  {
     return sGLContextProviderEGL.CreateHeadless(desc, out_failureId);
   }
 }
 
 /*static*/
 GLContext* GLContextProviderWayland::GetGlobalContext() {
+#ifdef MOZ_X11
   if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
     return sGLContextProviderX11.GetGlobalContext();
-  } else {
+  } else 
+#endif
+  {
     return sGLContextProviderEGL.GetGlobalContext();
   }
 }
 
 /*static*/
 void GLContextProviderWayland::Shutdown() {
+#ifdef MOZ_X11
   if (GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
     sGLContextProviderX11.Shutdown();
-  } else {
+  } else 
+#endif
+  {
     sGLContextProviderEGL.Shutdown();
   }
 }
diff --git a/gfx/gl/GLLibraryEGL.cpp b/gfx/gl/GLLibraryEGL.cpp
index 2238041435..111d4f848b 100644
--- a/gfx/gl/GLLibraryEGL.cpp
+++ b/gfx/gl/GLLibraryEGL.cpp
@@ -766,7 +766,7 @@ std::shared_ptr<EglDisplay> GLLibraryEGL::CreateDisplay(
 #ifdef MOZ_WAYLAND
     // Some drivers doesn't support EGL_DEFAULT_DISPLAY
     GdkDisplay* gdkDisplay = gdk_display_get_default();
-    if (gdkDisplay && !GDK_IS_X11_DISPLAY(gdkDisplay)) {
+    if (gdkDisplay && GDK_IS_WAYLAND_DISPLAY(gdkDisplay)) {
       nativeDisplay = widget::WaylandDisplayGetWLDisplay(gdkDisplay);
       if (!nativeDisplay) {
         NS_WARNING("Failed to get wl_display.");
diff --git a/gfx/gl/moz.build b/gfx/gl/moz.build
index 72e576a408..234c4768f7 100644
--- a/gfx/gl/moz.build
+++ b/gfx/gl/moz.build
@@ -13,7 +13,7 @@ elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "cocoa":
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "uikit":
     gl_provider = "EAGL"
 elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
-    if CONFIG["MOZ_EGL_XRENDER_COMPOSITE"]:
+    if CONFIG["MOZ_EGL_XRENDER_COMPOSITE"] or not CONFIG["MOZ_X11"]:
         gl_provider = "EGL"
     else:
         gl_provider = "GLX"
diff --git a/gfx/layers/ipc/CompositorBridgeParent.cpp b/gfx/layers/ipc/CompositorBridgeParent.cpp
index 5da1239834..4f74a2dfce 100644
--- a/gfx/layers/ipc/CompositorBridgeParent.cpp
+++ b/gfx/layers/ipc/CompositorBridgeParent.cpp
@@ -70,7 +70,7 @@
 #include "mozilla/PerfStats.h"
 #include "mozilla/PodOperations.h"
 #include "mozilla/Telemetry.h"
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
 #  include "basic/X11BasicCompositor.h"  // for X11BasicCompositor
 #endif
 #include "nsCOMPtr.h"         // for already_AddRefed
@@ -1505,7 +1505,7 @@ RefPtr<Compositor> CompositorBridgeParent::NewCompositor(
           new CompositorOGL(this, mWidget, mEGLSurfaceSize.width,
                             mEGLSurfaceSize.height, mUseExternalSurfaceSize);
     } else if (aBackendHints[i] == LayersBackend::LAYERS_BASIC) {
-#ifdef MOZ_WIDGET_GTK
+#if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
       if (gfxVars::UseXRender()) {
         compositor = new X11BasicCompositor(this, mWidget);
       } else
diff --git a/gfx/thebes/gfxPlatformGtk.cpp b/gfx/thebes/gfxPlatformGtk.cpp
index c2ac7707fe..a6d4b56fa3 100644
--- a/gfx/thebes/gfxPlatformGtk.cpp
+++ b/gfx/thebes/gfxPlatformGtk.cpp
@@ -36,6 +36,7 @@
 #include "nsMathUtils.h"
 #include "nsUnicharUtils.h"
 #include "nsUnicodeProperties.h"
+#include "prenv.h"
 #include "VsyncSource.h"
 
 #ifdef MOZ_X11
@@ -85,9 +86,13 @@ gfxPlatformGtk::gfxPlatformGtk() {
   }
 
   mMaxGenericSubstitutions = UNINITIALIZED_VALUE;
+#ifdef MOZ_X11
   mIsX11Display = gfxPlatform::IsHeadless()
                       ? false
                       : GDK_IS_X11_DISPLAY(gdk_display_get_default());
+#else
+  mIsX11Display = false;
+#endif
   if (XRE_IsParentProcess()) {
 #ifdef MOZ_X11
     if (mIsX11Display && mozilla::Preferences::GetBool("gfx.xrender.enabled")) {
@@ -124,9 +129,11 @@ gfxPlatformGtk::~gfxPlatformGtk() {
 }
 
 void gfxPlatformGtk::FlushContentDrawing() {
+#ifdef MOZ_X11
   if (gfxVars::UseXRender()) {
     XFlush(DefaultXDisplay());
   }
+#endif
 }
 
 void gfxPlatformGtk::InitPlatformGPUProcessPrefs() {
diff --git a/gfx/webrender_bindings/RenderCompositorEGL.cpp b/gfx/webrender_bindings/RenderCompositorEGL.cpp
index 9669ba0e8a..db48e81a4b 100644
--- a/gfx/webrender_bindings/RenderCompositorEGL.cpp
+++ b/gfx/webrender_bindings/RenderCompositorEGL.cpp
@@ -19,7 +19,7 @@
 #ifdef MOZ_WAYLAND
 #  include "mozilla/widget/GtkCompositorWidget.h"
 #  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
+#  include <gdk/gdkwayland.h>
 #endif
 
 #ifdef MOZ_WIDGET_ANDROID
@@ -37,7 +37,7 @@ UniquePtr<RenderCompositor> RenderCompositorEGL::Create(
     RefPtr<widget::CompositorWidget> aWidget, nsACString& aError) {
 #ifdef MOZ_WAYLAND
   if (!gdk_display_get_default() ||
-      GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+      !GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
     return nullptr;
   }
 #endif
diff --git a/gfx/webrender_bindings/RenderThread.cpp b/gfx/webrender_bindings/RenderThread.cpp
index 4b94c0ef6c..a1acd48f9f 100644
--- a/gfx/webrender_bindings/RenderThread.cpp
+++ b/gfx/webrender_bindings/RenderThread.cpp
@@ -40,11 +40,9 @@
 #  include "mozilla/webrender/RenderAndroidSurfaceTextureHost.h"
 #endif
 
-#ifdef MOZ_WIDGET_GTK
-#  include <gdk/gdkx.h>
-#endif
 
 #ifdef MOZ_WAYLAND
+#  include <gdk/gdkwayland.h>
 #  include "GLLibraryEGL.h"
 #endif
 
@@ -1147,7 +1145,7 @@ static already_AddRefed<gl::GLContext> CreateGLContext(nsACString& aError) {
   gl = CreateGLContextEGL();
 #elif defined(MOZ_WAYLAND)
   if (gdk_display_get_default() &&
-      !GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+      GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
     gl = CreateGLContextEGL();
   }
 #elif XP_MACOSX
diff --git a/gfx/webrender_bindings/RenderThread.cpp.orig b/gfx/webrender_bindings/RenderThread.cpp.orig
new file mode 100644
index 0000000000..4b94c0ef6c
--- /dev/null
+++ b/gfx/webrender_bindings/RenderThread.cpp.orig
@@ -0,0 +1,1213 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "base/task.h"
+#include "GeckoProfiler.h"
+#include "gfxPlatform.h"
+#include "GLContext.h"
+#include "RenderThread.h"
+#include "nsThreadUtils.h"
+#include "transport/runnable_utils.h"
+#include "mozilla/layers/AsyncImagePipelineManager.h"
+#include "mozilla/gfx/gfxVars.h"
+#include "mozilla/gfx/GPUParent.h"
+#include "mozilla/gfx/GPUProcessManager.h"
+#include "mozilla/layers/CompositorThread.h"
+#include "mozilla/layers/CompositorBridgeParent.h"
+#include "mozilla/layers/CompositorManagerParent.h"
+#include "mozilla/layers/WebRenderBridgeParent.h"
+#include "mozilla/layers/SharedSurfacesParent.h"
+#include "mozilla/StaticPtr.h"
+#include "mozilla/Telemetry.h"
+#include "mozilla/webrender/RendererOGL.h"
+#include "mozilla/webrender/RenderTextureHost.h"
+#include "mozilla/widget/CompositorWidget.h"
+
+#ifdef XP_WIN
+#  include "GLContextEGL.h"
+#  include "GLLibraryEGL.h"
+#  include "mozilla/widget/WinCompositorWindowThread.h"
+#  include "mozilla/gfx/DeviceManagerDx.h"
+//#  include "nsWindowsHelpers.h"
+//#  include <d3d11.h>
+#endif
+
+#ifdef MOZ_WIDGET_ANDROID
+#  include "GLLibraryEGL.h"
+#  include "mozilla/webrender/RenderAndroidSurfaceTextureHost.h"
+#endif
+
+#ifdef MOZ_WIDGET_GTK
+#  include <gdk/gdkx.h>
+#endif
+
+#ifdef MOZ_WAYLAND
+#  include "GLLibraryEGL.h"
+#endif
+
+using namespace mozilla;
+
+static already_AddRefed<gl::GLContext> CreateGLContext(nsACString& aError);
+
+MOZ_DEFINE_MALLOC_SIZE_OF(WebRenderRendererMallocSizeOf)
+
+namespace mozilla {
+namespace wr {
+
+static StaticRefPtr<RenderThread> sRenderThread;
+
+RenderThread::RenderThread(base::Thread* aThread)
+    : mThread(aThread),
+      mThreadPool(false),
+      mThreadPoolLP(true),
+      mWindowInfos("RenderThread.mWindowInfos"),
+      mRenderTextureMapLock("RenderThread.mRenderTextureMapLock"),
+      mHasShutdown(false),
+      mHandlingDeviceReset(false),
+      mHandlingWebRenderError(false) {}
+
+RenderThread::~RenderThread() {
+  MOZ_ASSERT(mRenderTexturesDeferred.empty());
+  delete mThread;
+}
+
+// static
+RenderThread* RenderThread::Get() { return sRenderThread; }
+
+// static
+void RenderThread::Start() {
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(!sRenderThread);
+
+  base::Thread* thread = new base::Thread("Renderer");
+
+  base::Thread::Options options;
+  // TODO(nical): The compositor thread has a bunch of specific options, see
+  // which ones make sense here.
+  if (!thread->StartWithOptions(options)) {
+    delete thread;
+    return;
+  }
+
+  sRenderThread = new RenderThread(thread);
+#ifdef XP_WIN
+  widget::WinCompositorWindowThread::Start();
+#endif
+  layers::SharedSurfacesParent::Initialize();
+
+  RefPtr<Runnable> runnable = WrapRunnable(
+      RefPtr<RenderThread>(sRenderThread.get()), &RenderThread::InitDeviceTask);
+  sRenderThread->Loop()->PostTask(runnable.forget());
+}
+
+// static
+void RenderThread::ShutDown() {
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(sRenderThread);
+
+  {
+    MutexAutoLock lock(sRenderThread->mRenderTextureMapLock);
+    sRenderThread->mHasShutdown = true;
+  }
+
+  layers::SynchronousTask task("RenderThread");
+  RefPtr<Runnable> runnable =
+      WrapRunnable(RefPtr<RenderThread>(sRenderThread.get()),
+                   &RenderThread::ShutDownTask, &task);
+  sRenderThread->Loop()->PostTask(runnable.forget());
+  task.Wait();
+
+  sRenderThread = nullptr;
+#ifdef XP_WIN
+  if (widget::WinCompositorWindowThread::Get()) {
+    widget::WinCompositorWindowThread::ShutDown();
+  }
+#endif
+}
+
+extern void ClearAllBlobImageResources();
+
+void RenderThread::ShutDownTask(layers::SynchronousTask* aTask) {
+  layers::AutoCompleteTask complete(aTask);
+  MOZ_ASSERT(IsInRenderThread());
+
+  // Let go of our handle to the (internally ref-counted) thread pool.
+  mThreadPool.Release();
+  mThreadPoolLP.Release();
+
+  // Releasing on the render thread will allow us to avoid dispatching to remove
+  // remaining textures from the texture map.
+  layers::SharedSurfacesParent::Shutdown();
+
+  ClearAllBlobImageResources();
+  ClearSharedGL();
+  ClearSharedSurfacePool();
+}
+
+// static
+MessageLoop* RenderThread::Loop() {
+  return sRenderThread ? sRenderThread->mThread->message_loop() : nullptr;
+}
+
+// static
+bool RenderThread::IsInRenderThread() {
+  return sRenderThread &&
+         sRenderThread->mThread->thread_id() == PlatformThread::CurrentId();
+}
+
+void RenderThread::DoAccumulateMemoryReport(
+    MemoryReport aReport,
+    const RefPtr<MemoryReportPromise::Private>& aPromise) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  for (auto& r : mRenderers) {
+    r.second->AccumulateMemoryReport(&aReport);
+  }
+
+  // Note memory used by the shader cache, which is shared across all WR
+  // instances.
+  MOZ_ASSERT(aReport.shader_cache == 0);
+  if (mProgramCache) {
+    aReport.shader_cache = wr_program_cache_report_memory(
+        mProgramCache->Raw(), &WebRenderRendererMallocSizeOf);
+  }
+
+  aPromise->Resolve(aReport, __func__);
+}
+
+// static
+RefPtr<MemoryReportPromise> RenderThread::AccumulateMemoryReport(
+    MemoryReport aInitial) {
+  RefPtr<MemoryReportPromise::Private> p =
+      new MemoryReportPromise::Private(__func__);
+  MOZ_ASSERT(!IsInRenderThread());
+  if (!Get() || !Get()->Loop()) {
+    // This happens when the GPU process fails to start and we fall back to the
+    // basic compositor in the parent process. We could assert against this if
+    // we made the webrender detection code in gfxPlatform.cpp smarter. See bug
+    // 1494430 comment 12.
+    NS_WARNING("No render thread, returning empty memory report");
+    p->Resolve(aInitial, __func__);
+    return p;
+  }
+
+  Get()->Loop()->PostTask(
+      NewRunnableMethod<MemoryReport, RefPtr<MemoryReportPromise::Private>>(
+          "wr::RenderThread::DoAccumulateMemoryReport", Get(),
+          &RenderThread::DoAccumulateMemoryReport, aInitial, p));
+
+  return p;
+}
+
+void RenderThread::AddRenderer(wr::WindowId aWindowId,
+                               UniquePtr<RendererOGL> aRenderer) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  if (mHasShutdown) {
+    return;
+  }
+
+  mRenderers[aWindowId] = std::move(aRenderer);
+
+  auto windows = mWindowInfos.Lock();
+  windows->emplace(AsUint64(aWindowId), new WindowInfo());
+}
+
+void RenderThread::RemoveRenderer(wr::WindowId aWindowId) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  if (mHasShutdown) {
+    return;
+  }
+
+  mRenderers.erase(aWindowId);
+
+  if (mRenderers.size() == 0 && mHandlingDeviceReset) {
+    mHandlingDeviceReset = false;
+  }
+
+  auto windows = mWindowInfos.Lock();
+  auto it = windows->find(AsUint64(aWindowId));
+  MOZ_ASSERT(it != windows->end());
+  WindowInfo* toDelete = it->second;
+  windows->erase(it);
+  delete toDelete;
+}
+
+RendererOGL* RenderThread::GetRenderer(wr::WindowId aWindowId) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  auto it = mRenderers.find(aWindowId);
+  MOZ_ASSERT(it != mRenderers.end());
+
+  if (it == mRenderers.end()) {
+    return nullptr;
+  }
+
+  return it->second.get();
+}
+
+size_t RenderThread::RendererCount() {
+  MOZ_ASSERT(IsInRenderThread());
+  return mRenderers.size();
+}
+
+void RenderThread::BeginRecordingForWindow(wr::WindowId aWindowId,
+                                           const TimeStamp& aRecordingStart,
+                                           wr::PipelineId aRootPipelineId) {
+  MOZ_ASSERT(IsInRenderThread());
+  RendererOGL* renderer = GetRenderer(aWindowId);
+  MOZ_ASSERT(renderer);
+
+  renderer->BeginRecording(aRecordingStart, aRootPipelineId);
+}
+
+void RenderThread::WriteCollectedFramesForWindow(wr::WindowId aWindowId) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  RendererOGL* renderer = GetRenderer(aWindowId);
+  MOZ_ASSERT(renderer);
+  renderer->WriteCollectedFrames();
+}
+
+Maybe<layers::CollectedFrames> RenderThread::GetCollectedFramesForWindow(
+    wr::WindowId aWindowId) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  RendererOGL* renderer = GetRenderer(aWindowId);
+  MOZ_ASSERT(renderer);
+  return renderer->GetCollectedFrames();
+}
+
+void RenderThread::HandleFrameOneDoc(wr::WindowId aWindowId, bool aRender) {
+  if (mHasShutdown) {
+    return;
+  }
+
+  if (!IsInRenderThread()) {
+    Loop()->PostTask(NewRunnableMethod<wr::WindowId, bool>(
+        "wr::RenderThread::HandleFrameOneDoc", this,
+        &RenderThread::HandleFrameOneDoc, aWindowId, aRender));
+    return;
+  }
+
+  if (IsDestroyed(aWindowId)) {
+    return;
+  }
+
+  if (mHandlingDeviceReset) {
+    return;
+  }
+
+  bool render = false;
+  PendingFrameInfo frame;
+  {  // scope lock
+    auto windows = mWindowInfos.Lock();
+    auto it = windows->find(AsUint64(aWindowId));
+    if (it == windows->end()) {
+      MOZ_ASSERT(false);
+      return;
+    }
+
+    WindowInfo* info = it->second;
+    PendingFrameInfo& frameInfo = info->mPendingFrames.front();
+    frameInfo.mFrameNeedsRender |= aRender;
+    render = frameInfo.mFrameNeedsRender;
+
+    frame = frameInfo;
+  }
+
+  // It is for ensuring that PrepareForUse() is called before
+  // RenderTextureHost::Lock().
+  HandleRenderTextureOps();
+
+  UpdateAndRender(aWindowId, frame.mStartId, frame.mStartTime, render,
+                  /* aReadbackSize */ Nothing(),
+                  /* aReadbackFormat */ Nothing(),
+                  /* aReadbackBuffer */ Nothing());
+
+  {  // scope lock
+    auto windows = mWindowInfos.Lock();
+    auto it = windows->find(AsUint64(aWindowId));
+    if (it == windows->end()) {
+      MOZ_ASSERT(false);
+      return;
+    }
+    WindowInfo* info = it->second;
+    info->mPendingFrames.pop();
+  }
+
+  // The start time is from WebRenderBridgeParent::CompositeToTarget. From that
+  // point until now (when the frame is finally pushed to the screen) is
+  // equivalent to the COMPOSITE_TIME metric in the non-WR codepath.
+  mozilla::Telemetry::AccumulateTimeDelta(mozilla::Telemetry::COMPOSITE_TIME,
+                                          frame.mStartTime);
+}
+
+void RenderThread::WakeUp(wr::WindowId aWindowId) {
+  if (mHasShutdown) {
+    return;
+  }
+
+  if (!IsInRenderThread()) {
+    Loop()->PostTask(NewRunnableMethod<wr::WindowId>(
+        "wr::RenderThread::WakeUp", this, &RenderThread::WakeUp, aWindowId));
+    return;
+  }
+
+  if (IsDestroyed(aWindowId)) {
+    return;
+  }
+
+  if (mHandlingDeviceReset) {
+    return;
+  }
+
+  auto it = mRenderers.find(aWindowId);
+  MOZ_ASSERT(it != mRenderers.end());
+  if (it != mRenderers.end()) {
+    it->second->Update();
+  }
+}
+
+void RenderThread::SetClearColor(wr::WindowId aWindowId, wr::ColorF aColor) {
+  if (mHasShutdown) {
+    return;
+  }
+
+  if (!IsInRenderThread()) {
+    Loop()->PostTask(NewRunnableMethod<wr::WindowId, wr::ColorF>(
+        "wr::RenderThread::SetClearColor", this, &RenderThread::SetClearColor,
+        aWindowId, aColor));
+    return;
+  }
+
+  if (IsDestroyed(aWindowId)) {
+    return;
+  }
+
+  auto it = mRenderers.find(aWindowId);
+  MOZ_ASSERT(it != mRenderers.end());
+  if (it != mRenderers.end()) {
+    wr_renderer_set_clear_color(it->second->GetRenderer(), aColor);
+  }
+}
+
+void RenderThread::SetProfilerUI(wr::WindowId aWindowId, nsCString aUI) {
+  if (mHasShutdown) {
+    return;
+  }
+
+  if (!IsInRenderThread()) {
+    Loop()->PostTask(NewRunnableMethod<wr::WindowId, nsCString>(
+        "wr::RenderThread::SetProfilerUI", this, &RenderThread::SetProfilerUI,
+        aWindowId, aUI));
+    return;
+  }
+
+  auto it = mRenderers.find(aWindowId);
+  if (it != mRenderers.end()) {
+    it->second->SetProfilerUI(aUI);
+  }
+}
+
+void RenderThread::RunEvent(wr::WindowId aWindowId,
+                            UniquePtr<RendererEvent> aEvent) {
+  if (!IsInRenderThread()) {
+    Loop()->PostTask(
+        NewRunnableMethod<wr::WindowId, UniquePtr<RendererEvent>&&>(
+            "wr::RenderThread::RunEvent", this, &RenderThread::RunEvent,
+            aWindowId, std::move(aEvent)));
+    return;
+  }
+
+  aEvent->Run(*this, aWindowId);
+  aEvent = nullptr;
+}
+
+static void NotifyDidRender(layers::CompositorBridgeParent* aBridge,
+                            RefPtr<const WebRenderPipelineInfo> aInfo,
+                            VsyncId aCompositeStartId,
+                            TimeStamp aCompositeStart, TimeStamp aRenderStart,
+                            TimeStamp aEnd, bool aRender,
+                            RendererStats aStats) {
+  if (aRender && aBridge->GetWrBridge()) {
+    // We call this here to mimic the behavior in LayerManagerComposite, as to
+    // not change what Talos measures. That is, we do not record an empty frame
+    // as a frame.
+    aBridge->GetWrBridge()->RecordFrame();
+  }
+
+  aBridge->NotifyDidRender(aCompositeStartId, aCompositeStart, aRenderStart,
+                           aEnd, &aStats);
+
+  for (const auto& epoch : aInfo->Raw().epochs) {
+    aBridge->NotifyPipelineRendered(epoch.pipeline_id, epoch.epoch,
+                                    aCompositeStartId, aCompositeStart,
+                                    aRenderStart, aEnd, &aStats);
+  }
+
+  if (aBridge->GetWrBridge()) {
+    aBridge->GetWrBridge()->CompositeIfNeeded();
+  }
+}
+
+static void NotifyDidStartRender(layers::CompositorBridgeParent* aBridge) {
+  // Starting a render will change mIsRendering, and potentially
+  // change whether we can allow the bridge to intiate another frame.
+  if (aBridge->GetWrBridge()) {
+    aBridge->GetWrBridge()->CompositeIfNeeded();
+  }
+}
+
+void RenderThread::UpdateAndRender(
+    wr::WindowId aWindowId, const VsyncId& aStartId,
+    const TimeStamp& aStartTime, bool aRender,
+    const Maybe<gfx::IntSize>& aReadbackSize,
+    const Maybe<wr::ImageFormat>& aReadbackFormat,
+    const Maybe<Range<uint8_t>>& aReadbackBuffer, bool* aNeedsYFlip) {
+  AUTO_PROFILER_TRACING_MARKER("Paint", "Composite", GRAPHICS);
+  MOZ_ASSERT(IsInRenderThread());
+  MOZ_ASSERT(aRender || aReadbackBuffer.isNothing());
+
+  auto it = mRenderers.find(aWindowId);
+  MOZ_ASSERT(it != mRenderers.end());
+  if (it == mRenderers.end()) {
+    return;
+  }
+
+  TimeStamp start = TimeStamp::Now();
+
+  auto& renderer = it->second;
+
+  layers::CompositorThread()->Dispatch(
+      NewRunnableFunction("NotifyDidStartRenderRunnable", &NotifyDidStartRender,
+                          renderer->GetCompositorBridge()));
+
+  wr::RenderedFrameId latestFrameId;
+  RendererStats stats = {0};
+  if (aRender) {
+    latestFrameId = renderer->UpdateAndRender(
+        aReadbackSize, aReadbackFormat, aReadbackBuffer, aNeedsYFlip, &stats);
+  } else {
+    renderer->Update();
+  }
+  // Check graphics reset status even when rendering is skipped.
+  renderer->CheckGraphicsResetStatus("PostUpdate", /* aForce */ false);
+
+  TimeStamp end = TimeStamp::Now();
+  RefPtr<const WebRenderPipelineInfo> info = renderer->FlushPipelineInfo();
+
+  layers::CompositorThread()->Dispatch(
+      NewRunnableFunction("NotifyDidRenderRunnable", &NotifyDidRender,
+                          renderer->GetCompositorBridge(), info, aStartId,
+                          aStartTime, start, end, aRender, stats));
+
+  if (latestFrameId.IsValid()) {
+    renderer->MaybeRecordFrame(info);
+  }
+
+  ipc::FileDescriptor fenceFd;
+
+  if (latestFrameId.IsValid()) {
+    fenceFd = renderer->GetAndResetReleaseFence();
+
+    // Wait for GPU after posting NotifyDidRender, since the wait is not
+    // necessary for the NotifyDidRender.
+    // The wait is necessary for Textures recycling of AsyncImagePipelineManager
+    // and for avoiding GPU queue is filled with too much tasks.
+    // WaitForGPU's implementation is different for each platform.
+    renderer->WaitForGPU();
+  }
+
+  if (!aRender) {
+    // Update frame id for NotifyPipelinesUpdated() when rendering does not
+    // happen.
+    latestFrameId = renderer->UpdateFrameId();
+  }
+
+  RenderedFrameId lastCompletedFrameId = renderer->GetLastCompletedFrameId();
+
+  RefPtr<layers::AsyncImagePipelineManager> pipelineMgr =
+      renderer->GetCompositorBridge()->GetAsyncImagePipelineManager();
+  // pipelineMgr should always be non-null here because it is only nulled out
+  // after the WebRenderAPI instance for the CompositorBridgeParent is
+  // destroyed, and that destruction blocks until the renderer thread has
+  // removed the relevant renderer. And after that happens we should never reach
+  // this code at all; it would bail out at the mRenderers.find check above.
+  MOZ_ASSERT(pipelineMgr);
+  pipelineMgr->NotifyPipelinesUpdated(info, latestFrameId, lastCompletedFrameId,
+                                      std::move(fenceFd));
+}
+
+void RenderThread::Pause(wr::WindowId aWindowId) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  auto it = mRenderers.find(aWindowId);
+  MOZ_ASSERT(it != mRenderers.end());
+  if (it == mRenderers.end()) {
+    return;
+  }
+  auto& renderer = it->second;
+  renderer->Pause();
+}
+
+bool RenderThread::Resume(wr::WindowId aWindowId) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  auto it = mRenderers.find(aWindowId);
+  MOZ_ASSERT(it != mRenderers.end());
+  if (it == mRenderers.end()) {
+    return false;
+  }
+  auto& renderer = it->second;
+  return renderer->Resume();
+}
+
+bool RenderThread::TooManyPendingFrames(wr::WindowId aWindowId) {
+  const int64_t maxFrameCount = 1;
+
+  // Too many pending frames if pending frames exit more than maxFrameCount
+  // or if RenderBackend is still processing a frame.
+
+  auto windows = mWindowInfos.Lock();
+  auto it = windows->find(AsUint64(aWindowId));
+  if (it == windows->end()) {
+    MOZ_ASSERT(false);
+    return true;
+  }
+  WindowInfo* info = it->second;
+
+  if (info->PendingCount() > maxFrameCount) {
+    return true;
+  }
+  // If there is no ongoing frame build, we accept a new frame.
+  return info->mPendingFrameBuild > 0;
+}
+
+bool RenderThread::IsDestroyed(wr::WindowId aWindowId) {
+  auto windows = mWindowInfos.Lock();
+  auto it = windows->find(AsUint64(aWindowId));
+  if (it == windows->end()) {
+    return true;
+  }
+
+  return it->second->mIsDestroyed;
+}
+
+void RenderThread::SetDestroyed(wr::WindowId aWindowId) {
+  auto windows = mWindowInfos.Lock();
+  auto it = windows->find(AsUint64(aWindowId));
+  if (it == windows->end()) {
+    MOZ_ASSERT(false);
+    return;
+  }
+  it->second->mIsDestroyed = true;
+}
+
+void RenderThread::IncPendingFrameCount(wr::WindowId aWindowId,
+                                        const VsyncId& aStartId,
+                                        const TimeStamp& aStartTime) {
+  auto windows = mWindowInfos.Lock();
+  auto it = windows->find(AsUint64(aWindowId));
+  if (it == windows->end()) {
+    MOZ_ASSERT(false);
+    return;
+  }
+  it->second->mPendingFrameBuild++;
+  it->second->mPendingFrames.push(
+      PendingFrameInfo{aStartTime, aStartId, false});
+}
+
+void RenderThread::DecPendingFrameBuildCount(wr::WindowId aWindowId) {
+  auto windows = mWindowInfos.Lock();
+  auto it = windows->find(AsUint64(aWindowId));
+  if (it == windows->end()) {
+    MOZ_ASSERT(false);
+    return;
+  }
+  WindowInfo* info = it->second;
+  MOZ_RELEASE_ASSERT(info->mPendingFrameBuild >= 1);
+  info->mPendingFrameBuild--;
+}
+
+void RenderThread::RegisterExternalImage(
+    uint64_t aExternalImageId, already_AddRefed<RenderTextureHost> aTexture) {
+  MutexAutoLock lock(mRenderTextureMapLock);
+
+  if (mHasShutdown) {
+    return;
+  }
+  MOZ_ASSERT(mRenderTextures.find(aExternalImageId) == mRenderTextures.end());
+  RefPtr<RenderTextureHost> texture = aTexture;
+  if (texture->SyncObjectNeeded()) {
+    mSyncObjectNeededRenderTextures.emplace(aExternalImageId, texture);
+  }
+  mRenderTextures.emplace(aExternalImageId, texture);
+}
+
+void RenderThread::UnregisterExternalImage(uint64_t aExternalImageId) {
+  MutexAutoLock lock(mRenderTextureMapLock);
+  if (mHasShutdown) {
+    return;
+  }
+  auto it = mRenderTextures.find(aExternalImageId);
+  if (it == mRenderTextures.end()) {
+    return;
+  }
+
+  auto& texture = it->second;
+  if (texture->SyncObjectNeeded()) {
+    MOZ_RELEASE_ASSERT(
+        mSyncObjectNeededRenderTextures.erase(aExternalImageId) == 1);
+  }
+
+  if (!IsInRenderThread()) {
+    // The RenderTextureHost should be released in render thread. So, post the
+    // deletion task here.
+    // The shmem and raw buffer are owned by compositor ipc channel. It's
+    // possible that RenderTextureHost is still exist after the shmem/raw buffer
+    // deletion. Then the buffer in RenderTextureHost becomes invalid. It's fine
+    // for this situation. Gecko will only release the buffer if WR doesn't need
+    // it. So, no one will access the invalid buffer in RenderTextureHost.
+    RefPtr<RenderTextureHost> texture = it->second;
+    mRenderTextures.erase(it);
+    mRenderTexturesDeferred.emplace_back(std::move(texture));
+    Loop()->PostTask(NewRunnableMethod(
+        "RenderThread::DeferredRenderTextureHostDestroy", this,
+        &RenderThread::DeferredRenderTextureHostDestroy));
+  } else {
+    mRenderTextures.erase(it);
+  }
+}
+
+void RenderThread::PrepareForUse(uint64_t aExternalImageId) {
+  AddRenderTextureOp(RenderTextureOp::PrepareForUse, aExternalImageId);
+}
+
+void RenderThread::NotifyNotUsed(uint64_t aExternalImageId) {
+  AddRenderTextureOp(RenderTextureOp::NotifyNotUsed, aExternalImageId);
+}
+
+void RenderThread::NotifyForUse(uint64_t aExternalImageId) {
+  AddRenderTextureOp(RenderTextureOp::NotifyForUse, aExternalImageId);
+}
+
+void RenderThread::AddRenderTextureOp(RenderTextureOp aOp,
+                                      uint64_t aExternalImageId) {
+  MOZ_ASSERT(!IsInRenderThread());
+
+  MutexAutoLock lock(mRenderTextureMapLock);
+
+  auto it = mRenderTextures.find(aExternalImageId);
+  MOZ_ASSERT(it != mRenderTextures.end());
+  if (it == mRenderTextures.end()) {
+    return;
+  }
+
+  RefPtr<RenderTextureHost> texture = it->second;
+  mRenderTextureOps.emplace_back(aOp, std::move(texture));
+  Loop()->PostTask(NewRunnableMethod("RenderThread::HandleRenderTextureOps",
+                                     this,
+                                     &RenderThread::HandleRenderTextureOps));
+}
+
+void RenderThread::HandleRenderTextureOps() {
+  MOZ_ASSERT(IsInRenderThread());
+
+  std::list<std::pair<RenderTextureOp, RefPtr<RenderTextureHost>>>
+      renderTextureOps;
+  {
+    MutexAutoLock lock(mRenderTextureMapLock);
+    mRenderTextureOps.swap(renderTextureOps);
+  }
+
+  for (auto& it : renderTextureOps) {
+    switch (it.first) {
+      case RenderTextureOp::PrepareForUse:
+        it.second->PrepareForUse();
+        break;
+      case RenderTextureOp::NotifyForUse:
+        it.second->NotifyForUse();
+        break;
+      case RenderTextureOp::NotifyNotUsed:
+        it.second->NotifyNotUsed();
+        break;
+    }
+  }
+}
+
+void RenderThread::UnregisterExternalImageDuringShutdown(
+    uint64_t aExternalImageId) {
+  MOZ_ASSERT(IsInRenderThread());
+  MutexAutoLock lock(mRenderTextureMapLock);
+  MOZ_ASSERT(mHasShutdown);
+  MOZ_ASSERT(mRenderTextures.find(aExternalImageId) != mRenderTextures.end());
+  mRenderTextures.erase(aExternalImageId);
+}
+
+bool RenderThread::SyncObjectNeeded() {
+  MOZ_ASSERT(IsInRenderThread());
+  MutexAutoLock lock(mRenderTextureMapLock);
+  return !mSyncObjectNeededRenderTextures.empty();
+}
+
+void RenderThread::DeferredRenderTextureHostDestroy() {
+  MutexAutoLock lock(mRenderTextureMapLock);
+  mRenderTexturesDeferred.clear();
+}
+
+RenderTextureHost* RenderThread::GetRenderTexture(
+    wr::ExternalImageId aExternalImageId) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  MutexAutoLock lock(mRenderTextureMapLock);
+  auto it = mRenderTextures.find(AsUint64(aExternalImageId));
+  MOZ_ASSERT(it != mRenderTextures.end());
+  if (it == mRenderTextures.end()) {
+    return nullptr;
+  }
+  return it->second;
+}
+
+void RenderThread::InitDeviceTask() {
+  MOZ_ASSERT(IsInRenderThread());
+  MOZ_ASSERT(!mSharedGL);
+
+  if (gfx::gfxVars::UseSoftwareWebRender()) {
+    // Ensure we don't instantiate any shared GL context when SW-WR is used.
+    return;
+  }
+
+  nsAutoCString err;
+  mSharedGL = CreateGLContext(err);
+  if (gfx::gfxVars::UseWebRenderProgramBinaryDisk()) {
+    mProgramCache = MakeUnique<WebRenderProgramCache>(ThreadPool().Raw());
+  }
+  // Query the shared GL context to force the
+  // lazy initialization to happen now.
+  SharedGL();
+}
+
+#ifndef XP_WIN
+static DeviceResetReason GLenumToResetReason(GLenum aReason) {
+  switch (aReason) {
+    case LOCAL_GL_NO_ERROR:
+      return DeviceResetReason::FORCED_RESET;
+    case LOCAL_GL_INNOCENT_CONTEXT_RESET_ARB:
+      return DeviceResetReason::DRIVER_ERROR;
+    case LOCAL_GL_PURGED_CONTEXT_RESET_NV:
+      return DeviceResetReason::NVIDIA_VIDEO;
+    case LOCAL_GL_GUILTY_CONTEXT_RESET_ARB:
+      return DeviceResetReason::RESET;
+    case LOCAL_GL_UNKNOWN_CONTEXT_RESET_ARB:
+      return DeviceResetReason::UNKNOWN;
+    case LOCAL_GL_OUT_OF_MEMORY:
+      return DeviceResetReason::OUT_OF_MEMORY;
+    default:
+      return DeviceResetReason::OTHER;
+  }
+}
+#endif
+
+void RenderThread::HandleDeviceReset(const char* aWhere,
+                                     layers::CompositorBridgeParent* aBridge,
+                                     GLenum aReason) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  if (mHandlingDeviceReset) {
+    return;
+  }
+
+#ifndef XP_WIN
+  // On Windows, see DeviceManagerDx::MaybeResetAndReacquireDevices.
+  gfx::GPUProcessManager::RecordDeviceReset(GLenumToResetReason(aReason));
+#endif
+
+  {
+    MutexAutoLock lock(mRenderTextureMapLock);
+    mRenderTexturesDeferred.clear();
+    for (const auto& entry : mRenderTextures) {
+      entry.second->ClearCachedResources();
+    }
+  }
+
+  // On some platforms (i.e. Linux), we may get a device reset just for purging
+  // video memory with NVIDIA devices, because the driver has edge cases it
+  // needs to clear all of it.
+  if (aReason == LOCAL_GL_PURGED_CONTEXT_RESET_NV) {
+    MOZ_ASSERT(aBridge);
+    layers::CompositorThread()->Dispatch(NewRunnableMethod(
+        "CompositorBridgeParent::NotifyWebRenderContextPurge", aBridge,
+        &layers::CompositorBridgeParent::NotifyWebRenderContextPurge));
+    return;
+  }
+
+  mHandlingDeviceReset = aReason != LOCAL_GL_NO_ERROR;
+  if (mHandlingDeviceReset) {
+    // All RenderCompositors will be destroyed by the GPUProcessManager in
+    // either OnRemoteProcessDeviceReset via the GPUChild, or
+    // OnInProcessDeviceReset here directly.
+    gfxCriticalNote << "GFX: RenderThread detected a device reset in "
+                    << aWhere;
+    if (XRE_IsGPUProcess()) {
+      gfx::GPUParent::GetSingleton()->NotifyDeviceReset();
+    } else {
+#ifndef XP_WIN
+      // FIXME(aosmond): Do we need to do this on Windows? nsWindow::OnPaint
+      // seems to do its own detection for the parent process.
+      bool guilty = aReason == LOCAL_GL_GUILTY_CONTEXT_RESET_ARB;
+      NS_DispatchToMainThread(NS_NewRunnableFunction(
+          "gfx::GPUProcessManager::OnInProcessDeviceReset", [guilty]() -> void {
+            gfx::GPUProcessManager::Get()->OnInProcessDeviceReset(guilty);
+          }));
+#endif
+    }
+  }
+}
+
+bool RenderThread::IsHandlingDeviceReset() {
+  MOZ_ASSERT(IsInRenderThread());
+  return mHandlingDeviceReset;
+}
+
+void RenderThread::SimulateDeviceReset() {
+  if (!IsInRenderThread()) {
+    Loop()->PostTask(NewRunnableMethod("RenderThread::SimulateDeviceReset",
+                                       this,
+                                       &RenderThread::SimulateDeviceReset));
+  } else {
+    // When this function is called GPUProcessManager::SimulateDeviceReset()
+    // already triggers destroying all CompositorSessions before re-creating
+    // them.
+    HandleDeviceReset("SimulateDeviceReset", nullptr, LOCAL_GL_NO_ERROR);
+  }
+}
+
+static void DoNotifyWebRenderError(WebRenderError aError) {
+  layers::CompositorManagerParent::NotifyWebRenderError(aError);
+}
+
+void RenderThread::NotifyWebRenderError(WebRenderError aError) {
+  MOZ_ASSERT(IsInRenderThread());
+
+  layers::CompositorThread()->Dispatch(NewRunnableFunction(
+      "DoNotifyWebRenderErrorRunnable", &DoNotifyWebRenderError, aError));
+}
+
+void RenderThread::HandleWebRenderError(WebRenderError aError) {
+  if (mHandlingWebRenderError) {
+    return;
+  }
+
+  NotifyWebRenderError(aError);
+
+  {
+    MutexAutoLock lock(mRenderTextureMapLock);
+    mRenderTexturesDeferred.clear();
+    for (const auto& entry : mRenderTextures) {
+      entry.second->ClearCachedResources();
+    }
+  }
+  mHandlingWebRenderError = true;
+  // WebRender is going to be disabled by
+  // GPUProcessManager::NotifyWebRenderError()
+}
+
+bool RenderThread::IsHandlingWebRenderError() {
+  MOZ_ASSERT(IsInRenderThread());
+  return mHandlingWebRenderError;
+}
+
+gl::GLContext* RenderThread::SharedGL() {
+  nsAutoCString err;
+  auto gl = SharedGL(err);
+  if (!err.IsEmpty()) {
+    gfxCriticalNote << err.get();
+  }
+  return gl;
+}
+
+gl::GLContext* RenderThread::SharedGL(nsACString& aError) {
+  MOZ_ASSERT(IsInRenderThread());
+  if (!mSharedGL) {
+    mSharedGL = CreateGLContext(aError);
+    mShaders = nullptr;
+  }
+  if (mSharedGL && !mShaders) {
+    mShaders = MakeUnique<WebRenderShaders>(mSharedGL, mProgramCache.get());
+  }
+
+  return mSharedGL.get();
+}
+
+void RenderThread::ClearSharedGL() {
+  MOZ_ASSERT(IsInRenderThread());
+  if (mSurfacePool) {
+    mSurfacePool->DestroyGLResourcesForContext(mSharedGL);
+  }
+  mShaders = nullptr;
+  mSharedGL = nullptr;
+}
+
+RefPtr<layers::SurfacePool> RenderThread::SharedSurfacePool() {
+#ifdef XP_MACOSX
+  if (!mSurfacePool) {
+    size_t poolSizeLimit =
+        StaticPrefs::gfx_webrender_compositor_surface_pool_size_AtStartup();
+    mSurfacePool = layers::SurfacePool::Create(poolSizeLimit);
+  }
+#endif
+  return mSurfacePool;
+}
+
+void RenderThread::ClearSharedSurfacePool() { mSurfacePool = nullptr; }
+
+static void GLAPIENTRY DebugMessageCallback(GLenum aSource, GLenum aType,
+                                            GLuint aId, GLenum aSeverity,
+                                            GLsizei aLength,
+                                            const GLchar* aMessage,
+                                            const GLvoid* aUserParam) {
+  constexpr const char* kContextLost = "Context has been lost.";
+
+  if (StaticPrefs::gfx_webrender_gl_debug_message_critical_note_AtStartup() &&
+      aSeverity == LOCAL_GL_DEBUG_SEVERITY_HIGH) {
+    auto message = std::string(aMessage, aLength);
+    // When content lost happned, error messages are flooded by its message.
+    if (message != kContextLost) {
+      gfxCriticalNote << message;
+    } else {
+      gfxCriticalNoteOnce << message;
+    }
+  }
+
+  if (StaticPrefs::gfx_webrender_gl_debug_message_print_AtStartup()) {
+    gl::GLContext* gl = (gl::GLContext*)aUserParam;
+    gl->DebugCallback(aSource, aType, aId, aSeverity, aLength, aMessage);
+  }
+}
+
+// static
+void RenderThread::MaybeEnableGLDebugMessage(gl::GLContext* aGLContext) {
+  if (!aGLContext) {
+    return;
+  }
+
+  bool enableDebugMessage =
+      StaticPrefs::gfx_webrender_gl_debug_message_critical_note_AtStartup() ||
+      StaticPrefs::gfx_webrender_gl_debug_message_print_AtStartup();
+
+  if (enableDebugMessage &&
+      aGLContext->IsExtensionSupported(gl::GLContext::KHR_debug)) {
+    aGLContext->fEnable(LOCAL_GL_DEBUG_OUTPUT);
+    aGLContext->fDisable(LOCAL_GL_DEBUG_OUTPUT_SYNCHRONOUS);
+    aGLContext->fDebugMessageCallback(&DebugMessageCallback, (void*)aGLContext);
+    aGLContext->fDebugMessageControl(LOCAL_GL_DONT_CARE, LOCAL_GL_DONT_CARE,
+                                     LOCAL_GL_DONT_CARE, 0, nullptr, true);
+  }
+}
+
+WebRenderShaders::WebRenderShaders(gl::GLContext* gl,
+                                   WebRenderProgramCache* programCache) {
+  mGL = gl;
+  mShaders =
+      wr_shaders_new(gl, programCache ? programCache->Raw() : nullptr,
+                     StaticPrefs::gfx_webrender_precache_shaders_AtStartup());
+}
+
+WebRenderShaders::~WebRenderShaders() {
+  wr_shaders_delete(mShaders, mGL.get());
+}
+
+WebRenderThreadPool::WebRenderThreadPool(bool low_priority) {
+  mThreadPool = wr_thread_pool_new(low_priority);
+}
+
+WebRenderThreadPool::~WebRenderThreadPool() { Release(); }
+
+void WebRenderThreadPool::Release() {
+  if (mThreadPool) {
+    wr_thread_pool_delete(mThreadPool);
+    mThreadPool = nullptr;
+  }
+}
+
+WebRenderProgramCache::WebRenderProgramCache(wr::WrThreadPool* aThreadPool) {
+  MOZ_ASSERT(aThreadPool);
+
+  nsAutoString path;
+  if (gfx::gfxVars::UseWebRenderProgramBinaryDisk()) {
+    path.Append(gfx::gfxVars::ProfDirectory());
+  }
+  mProgramCache = wr_program_cache_new(&path, aThreadPool);
+  if (gfx::gfxVars::UseWebRenderProgramBinaryDisk()) {
+    wr_try_load_startup_shaders_from_disk(mProgramCache);
+  }
+}
+
+WebRenderProgramCache::~WebRenderProgramCache() {
+  wr_program_cache_delete(mProgramCache);
+}
+
+}  // namespace wr
+}  // namespace mozilla
+
+#ifdef XP_WIN
+static already_AddRefed<gl::GLContext> CreateGLContextANGLE(
+    nsACString& aError) {
+  const RefPtr<ID3D11Device> d3d11Device =
+      gfx::DeviceManagerDx::Get()->GetCompositorDevice();
+  if (!d3d11Device) {
+    aError.Assign("RcANGLE(no compositor device for EGLDisplay)"_ns);
+    return nullptr;
+  }
+
+  nsCString failureId;
+  const auto lib = gl::DefaultEglLibrary(&failureId);
+  if (!lib) {
+    aError.Assign(
+        nsPrintfCString("RcANGLE(load EGL lib failed: %s)", failureId.get()));
+    return nullptr;
+  }
+
+  const auto egl = lib->CreateDisplay(d3d11Device.get());
+  if (!egl) {
+    aError.Assign(nsPrintfCString("RcANGLE(create EGLDisplay failed: %s)",
+                                  failureId.get()));
+    return nullptr;
+  }
+
+  gl::CreateContextFlags flags = gl::CreateContextFlags::PREFER_ES3 |
+                                 gl::CreateContextFlags::PREFER_ROBUSTNESS;
+
+  if (egl->IsExtensionSupported(
+          gl::EGLExtension::MOZ_create_context_provoking_vertex_dont_care)) {
+    flags |= gl::CreateContextFlags::PROVOKING_VERTEX_DONT_CARE;
+  }
+
+  // Create GLContext with dummy EGLSurface, the EGLSurface is not used.
+  // Instread we override it with EGLSurface of SwapChain's back buffer.
+
+  const auto dummySize = mozilla::gfx::IntSize(16, 16);
+  auto gl = gl::GLContextEGL::CreateEGLPBufferOffscreenContext(
+      egl, {flags}, dummySize, &failureId);
+  if (!gl || !gl->IsANGLE()) {
+    aError.Assign(nsPrintfCString("RcANGLE(create GL context failed: %x, %s)",
+                                  gl.get(), failureId.get()));
+    return nullptr;
+  }
+
+  if (!gl->MakeCurrent()) {
+    aError.Assign(
+        nsPrintfCString("RcANGLE(make current GL context failed: %x, %x)",
+                        gl.get(), gl->mEgl->mLib->fGetError()));
+    return nullptr;
+  }
+
+  return gl.forget();
+}
+#endif
+
+#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WAYLAND)
+static already_AddRefed<gl::GLContext> CreateGLContextEGL() {
+  // Create GLContext with dummy EGLSurface.
+  RefPtr<gl::GLContext> gl =
+      gl::GLContextProviderEGL::CreateForCompositorWidget(
+          nullptr, /* aWebRender */ true, /* aForceAccelerated */ true);
+  if (!gl || !gl->MakeCurrent()) {
+    gfxCriticalNote << "Failed GL context creation for WebRender: "
+                    << gfx::hexa(gl.get());
+    return nullptr;
+  }
+  return gl.forget();
+}
+#endif
+
+#ifdef XP_MACOSX
+static already_AddRefed<gl::GLContext> CreateGLContextCGL() {
+  nsCString failureUnused;
+  return gl::GLContextProvider::CreateHeadless(
+      {gl::CreateContextFlags::ALLOW_OFFLINE_RENDERER |
+       gl::CreateContextFlags::FORCE_ENABLE_HARDWARE},
+      &failureUnused);
+}
+#endif
+
+static already_AddRefed<gl::GLContext> CreateGLContext(nsACString& aError) {
+  RefPtr<gl::GLContext> gl;
+
+#ifdef XP_WIN
+  if (gfx::gfxVars::UseWebRenderANGLE()) {
+    gl = CreateGLContextANGLE(aError);
+  }
+#elif defined(MOZ_WIDGET_ANDROID)
+  gl = CreateGLContextEGL();
+#elif defined(MOZ_WAYLAND)
+  if (gdk_display_get_default() &&
+      !GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+    gl = CreateGLContextEGL();
+  }
+#elif XP_MACOSX
+  gl = CreateGLContextCGL();
+#endif
+
+  wr::RenderThread::MaybeEnableGLDebugMessage(gl);
+
+  return gl.forget();
+}
+
+extern "C" {
+
+void wr_notifier_wake_up(mozilla::wr::WrWindowId aWindowId) {
+  mozilla::wr::RenderThread::Get()->WakeUp(aWindowId);
+}
+
+void wr_notifier_new_frame_ready(mozilla::wr::WrWindowId aWindowId) {
+  mozilla::wr::RenderThread::Get()->DecPendingFrameBuildCount(aWindowId);
+  mozilla::wr::RenderThread::Get()->HandleFrameOneDoc(aWindowId,
+                                                      /* aRender */ true);
+}
+
+void wr_notifier_nop_frame_done(mozilla::wr::WrWindowId aWindowId) {
+  mozilla::wr::RenderThread::Get()->DecPendingFrameBuildCount(aWindowId);
+  mozilla::wr::RenderThread::Get()->HandleFrameOneDoc(aWindowId,
+                                                      /* aRender */ false);
+}
+
+void wr_notifier_external_event(mozilla::wr::WrWindowId aWindowId,
+                                size_t aRawEvent) {
+  mozilla::UniquePtr<mozilla::wr::RendererEvent> evt(
+      reinterpret_cast<mozilla::wr::RendererEvent*>(aRawEvent));
+  mozilla::wr::RenderThread::Get()->RunEvent(mozilla::wr::WindowId(aWindowId),
+                                             std::move(evt));
+}
+
+void wr_schedule_render(mozilla::wr::WrWindowId aWindowId) {
+  RefPtr<mozilla::layers::CompositorBridgeParent> cbp = mozilla::layers::
+      CompositorBridgeParent::GetCompositorBridgeParentFromWindowId(aWindowId);
+  if (cbp) {
+    cbp->ScheduleRenderOnCompositorThread();
+  }
+}
+
+static void NotifyDidSceneBuild(RefPtr<layers::CompositorBridgeParent> aBridge,
+                                RefPtr<const wr::WebRenderPipelineInfo> aInfo) {
+  aBridge->NotifyDidSceneBuild(aInfo);
+}
+
+void wr_finished_scene_build(mozilla::wr::WrWindowId aWindowId,
+                             mozilla::wr::WrPipelineInfo* aInfo) {
+  RefPtr<mozilla::layers::CompositorBridgeParent> cbp = mozilla::layers::
+      CompositorBridgeParent::GetCompositorBridgeParentFromWindowId(aWindowId);
+  RefPtr<wr::WebRenderPipelineInfo> info = new wr::WebRenderPipelineInfo();
+  info->Raw() = std::move(*aInfo);
+  if (cbp) {
+    layers::CompositorThread()->Dispatch(NewRunnableFunction(
+        "NotifyDidSceneBuild", &NotifyDidSceneBuild, cbp, info));
+  }
+}
+
+}  // extern C
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
index 192113d37c..e00f1f806c 100644
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -59,7 +59,6 @@
 #include <algorithm>
 #ifdef MOZ_WAYLAND
 #  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
 #  include <gdk/gdkwayland.h>
 #endif /* MOZ_WAYLAND */
 
@@ -547,7 +546,7 @@ void nsMenuPopupFrame::LayoutPopup(nsBoxLayoutState& aState,
 
 #ifdef MOZ_WAYLAND
   static bool inWayland = gdk_display_get_default() &&
-                          !GDK_IS_X11_DISPLAY(gdk_display_get_default());
+                          GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default());
 #else
   static bool inWayland = false;
 #endif
@@ -1451,7 +1450,7 @@ nsresult nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame,
 
 #ifdef MOZ_WAYLAND
       if (gdk_display_get_default() &&
-          !GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+          GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
         screenPoint = nsPoint(anchorRect.x, anchorRect.y);
         mAnchorRect = anchorRect;
       }
@@ -1589,7 +1588,7 @@ nsresult nsMenuPopupFrame::SetPopupPosition(nsIFrame* aAnchorFrame,
       // screen.
 #ifdef MOZ_WAYLAND
     static bool inWayland = gdk_display_get_default() &&
-                            !GDK_IS_X11_DISPLAY(gdk_display_get_default());
+                            GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default());
 #else
     static bool inWayland = false;
 #endif
@@ -1730,7 +1729,7 @@ LayoutDeviceIntRect nsMenuPopupFrame::GetConstraintRect(
       do_GetService("@mozilla.org/gfx/screenmanager;1"));
 #ifdef MOZ_WAYLAND
   static bool inWayland = gdk_display_get_default() &&
-                          !GDK_IS_X11_DISPLAY(gdk_display_get_default());
+                          GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default());
 #else
   static bool inWayland = false;
 #endif
diff --git a/old-configure.in b/old-configure.in
index 71a6d86cfb..b77d47c23e 100644
--- a/old-configure.in
+++ b/old-configure.in
@@ -2351,10 +2351,10 @@ fi
 
 # Define macros for cairo-features.h
 TEE_SURFACE_FEATURE="#define CAIRO_HAS_TEE_SURFACE 1"
+PS_SURFACE_FEATURE="#define CAIRO_HAS_PS_SURFACE 1"
 if test "$MOZ_X11"; then
     XLIB_SURFACE_FEATURE="#define CAIRO_HAS_XLIB_SURFACE 1"
     XLIB_XRENDER_SURFACE_FEATURE="#define CAIRO_HAS_XLIB_XRENDER_SURFACE 1"
-    PS_SURFACE_FEATURE="#define CAIRO_HAS_PS_SURFACE 1"
 fi
 if test "$_HAVE_FREETYPE2"; then
     FT_FONT_FEATURE="#define CAIRO_HAS_FT_FONT 1"
diff --git a/old-configure.in.orig b/old-configure.in.orig
new file mode 100644
index 0000000000..71a6d86cfb
--- /dev/null
+++ b/old-configure.in.orig
@@ -0,0 +1,2828 @@
+dnl -*- Mode: Autoconf; tab-width: 4; indent-tabs-mode: nil; -*-
+dnl vi: set tabstop=4 shiftwidth=4 expandtab syntax=m4:
+dnl This Source Code Form is subject to the terms of the Mozilla Public
+dnl License, v. 2.0. If a copy of the MPL was not distributed with this
+dnl file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+dnl Process this file with autoconf to produce a configure script.
+dnl ========================================================
+AC_PREREQ(2.13)
+AC_INIT(config/config.mk)
+AC_CONFIG_AUX_DIR(${srcdir}/build/autoconf)
+AC_CANONICAL_SYSTEM
+
+dnl ========================================================
+dnl =
+dnl = Don't change the following lines. Doing so breaks:
+dnl =
+dnl = CFLAGS="-foo" ./configure
+dnl =
+dnl ========================================================
+CFLAGS="${CFLAGS=}"
+CPPFLAGS="${CPPFLAGS=}"
+CXXFLAGS="${CXXFLAGS=}"
+LDFLAGS="${LDFLAGS=}"
+HOST_CFLAGS="${HOST_CFLAGS=}"
+HOST_CXXFLAGS="${HOST_CXXFLAGS=}"
+HOST_LDFLAGS="${HOST_LDFLAGS=}"
+
+dnl ========================================================
+dnl = Preserve certain environment flags passed to configure
+dnl = We want sub projects to receive the same flags
+dnl = untainted by this configure script
+dnl ========================================================
+_SUBDIR_CC="$CC"
+_SUBDIR_CXX="$CXX"
+_SUBDIR_CFLAGS="$CFLAGS"
+_SUBDIR_CPPFLAGS="$CPPFLAGS"
+_SUBDIR_CXXFLAGS="$CXXFLAGS"
+_SUBDIR_LDFLAGS="$LDFLAGS"
+_SUBDIR_HOST_CC="$HOST_CC"
+_SUBDIR_HOST_CFLAGS="$HOST_CFLAGS"
+_SUBDIR_HOST_CXXFLAGS="$HOST_CXXFLAGS"
+_SUBDIR_HOST_LDFLAGS="$HOST_LDFLAGS"
+_SUBDIR_CONFIG_ARGS="$ac_configure_args"
+
+dnl Set the version number of the libs included with mozilla
+dnl ========================================================
+MOZPNG=10635
+
+dnl Set the minimum version of toolkit libs used by mozilla
+dnl ========================================================
+GLIB_VERSION=2.42
+GLIB_VERSION_MIN_REQUIRED=GLIB_VERSION_2_42
+GLIB_VERSION_MAX_ALLOWED=GLIB_VERSION_2_42
+CAIRO_VERSION=1.10
+GTK2_VERSION=2.18.0
+GTK3_VERSION=3.14.0
+GDK_VERSION_MAX_ALLOWED=GDK_VERSION_3_14
+W32API_VERSION=3.14
+DBUS_VERSION=0.60
+
+dnl Set various checks
+dnl ========================================================
+MISSING_X=
+
+dnl Initialize the Pthread test variables early so they can be
+dnl  overridden by each platform.
+dnl ========================================================
+MOZ_USE_PTHREADS=
+_PTHREAD_LDFLAGS=""
+
+LDFLAGS="$LDFLAGS $LINKER_LDFLAGS"
+
+if test "$COMPILE_ENVIRONMENT"; then
+    MOZ_ANDROID_NDK
+fi # COMPILE_ENVIRONMENT
+
+case "$target" in
+*-android*|*-linuxandroid*)
+    ;;
+*-linux*)
+    AC_PATH_PROG(OBJCOPY,objcopy)
+    ;;
+esac
+
+AC_SUBST(OBJCOPY)
+
+dnl ========================================================
+dnl Checks for compilers.
+dnl ========================================================
+
+if test "$COMPILE_ENVIRONMENT"; then
+
+# Run some logic to figure out exe extensions (mostly for mingw's sake)
+AC_EXEEXT
+
+if test "$target" != "$host"; then
+    MOZ_CROSS_COMPILER
+else
+    AC_PROG_CC
+    case "$target" in
+    *-mingw*)
+      # Work around the conftest.exe access problem on Windows
+      sleep 2
+    esac
+    AC_PROG_CXX
+    AC_PROG_RANLIB
+    MOZ_PATH_PROGS(AS, $AS as, $CC)
+    AC_CHECK_PROGS(STRIP, strip, :)
+    AC_CHECK_PROGS(OTOOL, otool, :)
+fi
+
+MOZ_TOOL_VARIABLES
+
+dnl ========================================================
+dnl Special win32 checks
+dnl ========================================================
+
+WINVER=601
+
+case "$target" in
+*-mingw*)
+    if test "$GCC" != "yes"; then
+        # Check to see if we are really running in a msvc environemnt
+        _WIN32_MSVC=1
+
+        # Make sure compilers are valid
+        CXXFLAGS="$CXXFLAGS -TP"
+        AC_LANG_SAVE
+        AC_LANG_C
+        AC_TRY_COMPILE([#include <stdio.h>],
+            [ printf("Hello World\n"); ],,
+            AC_MSG_ERROR([\$(CC) test failed.  You must have MS VC++ in your path to build.]) )
+
+        AC_LANG_CPLUSPLUS
+        AC_TRY_COMPILE([#include <new.h>],
+            [ unsigned *test = new unsigned(42); ],,
+            AC_MSG_ERROR([\$(CXX) test failed.  You must have MS VC++ in your path to build.]) )
+        AC_LANG_RESTORE
+
+        changequote(,)
+        _MSVC_VER_FILTER='s|.*[^!-~]([0-9]+\.[0-9]+\.[0-9]+(\.[0-9]+)?).*|\1|p'
+        changequote([,])
+
+        AC_DEFINE(_CRT_SECURE_NO_WARNINGS)
+        AC_DEFINE(_CRT_NONSTDC_NO_WARNINGS)
+        AC_DEFINE(_USE_MATH_DEFINES) # Otherwise MSVC's math.h doesn't #define M_PI.
+
+        _CC_SUITE=14
+        MSVC_C_RUNTIME_DLL=vcruntime140.dll
+        MSVC_CXX_RUNTIME_DLL=msvcp140.dll
+
+        # -Zc:sizedDealloc- disables C++14 global sized deallocation (see bug 1160146)
+        CXXFLAGS="$CXXFLAGS -Zc:sizedDealloc-"
+
+        if test -n "$WIN_UCRT_REDIST_DIR"; then
+          if test ! -d "$WIN_UCRT_REDIST_DIR"; then
+            AC_MSG_ERROR([Invalid Windows UCRT Redist directory: ${WIN_UCRT_REDIST_DIR}])
+          fi
+          WIN_UCRT_REDIST_DIR=`cd "$WIN_UCRT_REDIST_DIR" && (pwd -W 2>/dev/null || pwd)`
+        fi
+
+        AC_SUBST(MSVC_C_RUNTIME_DLL)
+        AC_SUBST(MSVC_CXX_RUNTIME_DLL)
+
+        AC_DEFINE(HAVE_SEH_EXCEPTIONS)
+
+        if test -n "$WIN32_REDIST_DIR"; then
+          if test ! -d "$WIN32_REDIST_DIR"; then
+            AC_MSG_ERROR([Invalid Win32 Redist directory: ${WIN32_REDIST_DIR}])
+          fi
+          WIN32_REDIST_DIR=`cd "$WIN32_REDIST_DIR" && (pwd -W 2>/dev/null || pwd)`
+        fi
+
+        # Check linker version, except in lld builds
+        case "$LINKER" in
+        *lld*)
+            ;;
+        *)
+            _LD_FULL_VERSION=`"${LINKER}" -v 2>&1 | sed -nre "$_MSVC_VER_FILTER"`
+            _LD_MAJOR_VERSION=`echo ${_LD_FULL_VERSION} | $AWK -F\. '{ print $1 }'`
+            if test "$_LD_MAJOR_VERSION" != "$_CC_SUITE"; then
+                AC_MSG_ERROR([The linker major version, $_LD_FULL_VERSION,  does not match the compiler suite version, $_CC_SUITE.])
+            fi
+            ;;
+        esac
+
+        INCREMENTAL_LINKER=1
+
+        unset _MSVC_VER_FILTER
+
+        WRAP_STL_INCLUDES=1
+        STL_FLAGS="-I${DIST}/stl_wrappers"
+    else
+        # Check w32api version
+        _W32API_MAJOR_VERSION=`echo $W32API_VERSION | $AWK -F\. '{ print $1 }'`
+        _W32API_MINOR_VERSION=`echo $W32API_VERSION | $AWK -F\. '{ print $2 }'`
+        AC_MSG_CHECKING([for w32api version >= $W32API_VERSION])
+        AC_TRY_COMPILE([#include <w32api.h>],
+            #if (__W32API_MAJOR_VERSION < $_W32API_MAJOR_VERSION) || \
+                (__W32API_MAJOR_VERSION == $_W32API_MAJOR_VERSION && \
+                 __W32API_MINOR_VERSION < $_W32API_MINOR_VERSION)
+                #error "test failed."
+            #endif
+            , [ res=yes ], [ res=no ])
+        AC_MSG_RESULT([$res])
+        if test "$res" != "yes"; then
+            AC_MSG_ERROR([w32api version $W32API_VERSION or higher required.])
+        fi
+        # strsafe.h on mingw uses macros for function deprecation that pollutes namespace
+        # causing problems with local implementations with the same name.
+        AC_DEFINE(STRSAFE_NO_DEPRECATE)
+    fi # !GNU_CC
+
+    CFLAGS="$CFLAGS -D_HAS_EXCEPTIONS=0"
+    CXXFLAGS="$CXXFLAGS -D_HAS_EXCEPTIONS=0"
+
+    AC_DEFINE_UNQUOTED(WINVER,0x$WINVER)
+    AC_DEFINE_UNQUOTED(_WIN32_WINNT,0x$WINVER)
+    # Require OS features provided by IE 8.0 (Win7)
+    AC_DEFINE_UNQUOTED(_WIN32_IE,0x0800)
+
+    ;;
+esac
+
+if test -n "$_WIN32_MSVC"; then
+    SKIP_PATH_CHECKS=1
+    SKIP_COMPILER_CHECKS=1
+    SKIP_LIBRARY_CHECKS=1
+
+    # Since we're skipping compiler and library checks, hard-code
+    # some facts here.
+    AC_DEFINE(HAVE_IO_H)
+    AC_DEFINE(HAVE_ISATTY)
+fi
+
+fi # COMPILE_ENVIRONMENT
+
+AC_SUBST(GNU_CC)
+AC_SUBST(GNU_CXX)
+
+AC_SUBST_LIST(STL_FLAGS)
+AC_SUBST(WRAP_STL_INCLUDES)
+
+dnl ========================================================
+dnl Checks for programs.
+dnl ========================================================
+if test "$COMPILE_ENVIRONMENT"; then
+
+AC_PATH_XTRA
+
+XCFLAGS="$X_CFLAGS"
+
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl set the defaults first
+dnl ========================================================
+MOZ_USER_DIR=".mozilla"
+
+MOZ_FIX_LINK_PATHS="-Wl,-rpath-link,${DIST}/bin -Wl,-rpath-link,${prefix}/lib"
+
+MOZ_FS_LAYOUT=unix
+
+dnl Configure platform-specific CPU architecture compiler options.
+dnl ==============================================================
+if test "$COMPILE_ENVIRONMENT"; then
+    MOZ_ARCH_OPTS
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl Android libstdc++
+dnl ========================================================
+
+MOZ_ANDROID_CPU_ARCH
+if test "$COMPILE_ENVIRONMENT"; then
+    MOZ_ANDROID_STLPORT
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl Suppress Clang Argument Warnings
+dnl ========================================================
+WARNINGS_CFLAGS="$_WARNINGS_CFLAGS"
+if test -n "${CLANG_CC}${CLANG_CL}"; then
+    WARNINGS_CFLAGS="-Qunused-arguments $WARNINGS_CFLAGS"
+    CPPFLAGS="-Qunused-arguments ${CPPFLAGS}"
+fi
+if test -n "${CLANG_CXX}${CLANG_CL}"; then
+    _WARNINGS_CXXFLAGS="-Qunused-arguments ${_WARNINGS_CXXFLAGS}"
+fi
+
+if test -n "$COMPILE_ENVIRONMENT"; then
+   MOZ_CONFIG_SANITIZE
+fi
+
+dnl ========================================================
+dnl GNU specific defaults
+dnl ========================================================
+if test "$GNU_CC"; then
+    MMX_FLAGS="-mmmx"
+    SSE_FLAGS="-msse"
+    SSE2_FLAGS="-msse2"
+    SSSE3_FLAGS="-mssse3"
+    CFLAGS="$CFLAGS -fno-strict-aliasing"
+    DSO_CFLAGS=''
+
+    if test "$OS_ARCH" != "WINNT" -o -z "$CLANG_CC"; then
+        DSO_PIC_CFLAGS='-fPIC'
+        ASFLAGS="$ASFLAGS -fPIC"
+    fi
+
+    AC_MSG_CHECKING([for --noexecstack option to as])
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS -Wa,--noexecstack"
+    AC_TRY_COMPILE(,,AC_MSG_RESULT([yes])
+                     [ASFLAGS="$ASFLAGS -Wa,--noexecstack"],
+                     AC_MSG_RESULT([no]))
+    CFLAGS=$_SAVE_CFLAGS
+    AC_MSG_CHECKING([for -z noexecstack option to ld])
+    _SAVE_LDFLAGS=$LDFLAGS
+    LDFLAGS="$LDFLAGS -Wl,-z,noexecstack"
+    AC_TRY_LINK(,,AC_MSG_RESULT([yes]),
+                  AC_MSG_RESULT([no])
+                  LDFLAGS=$_SAVE_LDFLAGS)
+
+    AC_MSG_CHECKING([for -z text option to ld])
+    _SAVE_LDFLAGS=$LDFLAGS
+    LDFLAGS="$LDFLAGS -Wl,-z,text"
+    AC_TRY_LINK(,,AC_MSG_RESULT([yes]),
+                  AC_MSG_RESULT([no])
+                  LDFLAGS=$_SAVE_LDFLAGS)
+
+    AC_MSG_CHECKING([for -z relro option to ld])
+    _SAVE_LDFLAGS=$LDFLAGS
+    LDFLAGS="$LDFLAGS -Wl,-z,relro"
+    AC_TRY_LINK(,,AC_MSG_RESULT([yes]),
+                  AC_MSG_RESULT([no])
+                  LDFLAGS=$_SAVE_LDFLAGS)
+
+    AC_MSG_CHECKING([for -z nocopyreloc option to ld])
+    _SAVE_LDFLAGS=$LDFLAGS
+    LDFLAGS="$LDFLAGS -Wl,-z,nocopyreloc"
+    AC_TRY_LINK(,,AC_MSG_RESULT([yes]),
+                  AC_MSG_RESULT([no])
+                  LDFLAGS=$_SAVE_LDFLAGS)
+
+    AC_MSG_CHECKING([for -Bsymbolic-functions option to ld])
+    _SAVE_LDFLAGS=$LDFLAGS
+    LDFLAGS="$LDFLAGS -Wl,-Bsymbolic-functions"
+    AC_TRY_LINK(,,AC_MSG_RESULT([yes]),
+                  AC_MSG_RESULT([no])
+                  LDFLAGS=$_SAVE_LDFLAGS)
+
+    AC_MSG_CHECKING([for --ignore-unresolved-symbol option to ld])
+    HAVE_LINKER_SUPPORT_IGNORE_UNRESOLVED=
+    _SAVE_LDFLAGS=$LDFLAGS
+    LDFLAGS="$LDFLAGS -Wl,--ignore-unresolved-symbol,environ"
+    AC_TRY_LINK(,,AC_MSG_RESULT([yes])
+                  [HAVE_LINKER_SUPPORT_IGNORE_UNRESOLVED=1],
+                  AC_MSG_RESULT([no]))
+    LDFLAGS=$_SAVE_LDFLAGS
+
+    # Check for -mssse3 on $CC
+    AC_MSG_CHECKING([if toolchain supports -mssse3 option])
+    HAVE_TOOLCHAIN_SUPPORT_MSSSE3=
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS -mssse3"
+    AC_TRY_COMPILE([asm ("pmaddubsw %xmm2,%xmm3");],,AC_MSG_RESULT([yes])
+                     [HAVE_TOOLCHAIN_SUPPORT_MSSSE3=1],
+                     AC_MSG_RESULT([no]))
+    CFLAGS=$_SAVE_CFLAGS
+
+    # Check for -msse4.1 on $CC
+    AC_MSG_CHECKING([if toolchain supports -msse4.1 option])
+    HAVE_TOOLCHAIN_SUPPORT_MSSE4_1=
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS -msse4.1"
+    AC_TRY_COMPILE([asm ("pmulld %xmm6,%xmm0");],,AC_MSG_RESULT([yes])
+                     [HAVE_TOOLCHAIN_SUPPORT_MSSE4_1=1],
+                     AC_MSG_RESULT([no]))
+    CFLAGS=$_SAVE_CFLAGS
+
+    case "${CPU_ARCH}" in
+    x86 | x86_64)
+      AC_MSG_CHECKING(for x86 AVX2 asm support in compiler)
+      AC_TRY_COMPILE([],
+                     [asm volatile ("vpermq      \$0xd8,%ymm0,%ymm0 \n");],
+                     result="yes", result="no")
+      AC_MSG_RESULT("$result")
+      if test "$result" = "yes"; then
+          HAVE_X86_AVX2=1
+      fi
+      ;;
+
+    ppc*)
+      AC_MSG_CHECKING([whether we can enable AltiVec support])
+      HAVE_ALTIVEC=
+      _SAVE_CFLAGS=$CFLAGS
+      CFLAGS="$CFLAGS -maltivec"
+      AC_TRY_COMPILE(,,AC_MSG_RESULT([yes])
+                       [HAVE_ALTIVEC=1],
+                       AC_MSG_RESULT([no]))
+      CFLAGS=$_SAVE_CFLAGS
+      ;;
+    esac
+
+    DSO_LDOPTS='-shared'
+    if test "$GCC_USE_GNU_LD"; then
+        # Some tools like ASan use a runtime library that is only
+        # linked against executables, so we must allow undefined
+        # symbols for shared objects in some cases.
+        if test -z "$MOZ_ASAN$MOZ_MSAN$MOZ_UBSAN$MOZ_TSAN$FUZZING_INTERFACES"; then
+            # Don't allow undefined symbols in libraries
+            DSO_LDOPTS="$DSO_LDOPTS -Wl,-z,defs"
+
+            # BSDs need `environ' exposed for posix_spawn (bug 753046)
+            case "$OS_TARGET" in
+            DragonFly|FreeBSD|NetBSD|OpenBSD)
+                if test -n "$HAVE_LINKER_SUPPORT_IGNORE_UNRESOLVED"; then
+                    DSO_LDOPTS="$DSO_LDOPTS -Wl,--ignore-unresolved-symbol,environ"
+                else
+                    DSO_LDOPTS="$DSO_LDOPTS -Wl,--warn-unresolved-symbols"
+                fi
+                ;;
+            esac
+        fi
+    fi
+
+    _DEFINES_CFLAGS="-include $_objdir/mozilla-config.h -DMOZILLA_CLIENT"
+
+    ASFLAGS="$ASFLAGS $_DEFINES_CFLAGS"
+fi
+
+if test "$GNU_CXX"; then
+    CXXFLAGS="$CXXFLAGS -fno-exceptions -fno-strict-aliasing"
+
+    _DEFINES_CXXFLAGS="-DMOZILLA_CLIENT -include $_objdir/mozilla-config.h"
+fi
+
+dnl ========================================================
+dnl = Enable DMD
+dnl ========================================================
+
+if test "$MOZ_DMD"; then
+    if test "${CPU_ARCH}" = "arm"; then
+        CFLAGS="$CFLAGS -funwind-tables"
+        CXXFLAGS="$CXXFLAGS -funwind-tables"
+    fi
+fi
+
+dnl ========================================================
+dnl System overrides of the defaults for host
+dnl ========================================================
+case "$host" in
+*mingw*)
+    if test -n "$_WIN32_MSVC"; then
+        HOST_CFLAGS="$HOST_CFLAGS"
+    else
+        HOST_CFLAGS="$HOST_CFLAGS -mwindows"
+    fi
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_WIN -DWIN32 -D_WIN32 -D_CRT_SECURE_NO_WARNINGS"
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O2}"
+    HOST_BIN_SUFFIX=.exe
+
+    case "${host_cpu}" in
+    i*86)
+        if test -n "$_WIN32_MSVC"; then
+            HOST_LDFLAGS="$HOST_LDFLAGS -MACHINE:X86"
+        fi
+        ;;
+    x86_64)
+        if test -n "$_WIN32_MSVC"; then
+            HOST_LDFLAGS="$HOST_LDFLAGS -MACHINE:X64"
+        fi
+        HOST_CFLAGS="$HOST_CFLAGS -D_AMD64_"
+        ;;
+    esac
+    ;;
+
+*-darwin*)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX -DXP_MACOSX"
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O3}"
+    ;;
+
+*-linux*|*-kfreebsd*-gnu|*-gnu*)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX"
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O3}"
+    ;;
+
+*)
+    HOST_CFLAGS="$HOST_CFLAGS -DXP_UNIX"
+    HOST_OPTIMIZE_FLAGS="${HOST_OPTIMIZE_FLAGS=-O2}"
+    ;;
+esac
+
+dnl ========================================================
+dnl System overrides of the defaults for target
+dnl ========================================================
+
+case "$target" in
+*-darwin*)
+    MOZ_OPTIMIZE_FLAGS="-O3"
+    CXXFLAGS="$CXXFLAGS -stdlib=libc++"
+    DSO_LDOPTS=''
+    # The ExceptionHandling framework is needed for Objective-C exception
+    # logging code in nsObjCExceptions.h. Currently we only use that in debug
+    # builds.
+    MOZ_DEBUG_LDFLAGS="$MOZ_DEBUG_LDFLAGS -framework ExceptionHandling";
+
+    dnl DTrace and -dead_strip don't interact well. See bug 403132.
+    dnl ===================================================================
+    if test "x$enable_dtrace" = "xyes"; then
+        echo "Skipping -dead_strip because DTrace is enabled. See bug 403132."
+    else
+        dnl check for the presence of the -dead_strip linker flag
+        AC_MSG_CHECKING([for -dead_strip option to ld])
+        _SAVE_LDFLAGS=$LDFLAGS
+        LDFLAGS="$LDFLAGS -Wl,-dead_strip"
+        AC_TRY_LINK(,[return 0;],_HAVE_DEAD_STRIP=1,_HAVE_DEAD_STRIP=)
+        if test -n "$_HAVE_DEAD_STRIP" ; then
+            AC_MSG_RESULT([yes])
+            MOZ_OPTIMIZE_LDFLAGS="-Wl,-dead_strip"
+        else
+            AC_MSG_RESULT([no])
+        fi
+
+        LDFLAGS=$_SAVE_LDFLAGS
+    fi
+
+    MOZ_FIX_LINK_PATHS="-Wl,-executable_path,${DIST}/bin"
+    ;;
+
+*-android*|*-linuxandroid*)
+    if test "$COMPILE_ENVIRONMENT" -a -n "$MOZ_MEMORY"; then
+        MOZ_LINKER=1
+    fi
+
+    if test -z "$CLANG_CC"; then
+        MOZ_OPTIMIZE_FLAGS="-freorder-blocks -fno-reorder-functions -Os"
+    else
+        # From https://github.com/android-ndk/ndk/issues/133#issuecomment-308549264
+        # -Oz is smaller than -Os on clang.
+        MOZ_OPTIMIZE_FLAGS="-Oz"
+        # Disable the outliner, which causes performance regressions, and is
+        # enabled on some platforms at -Oz.
+        if test -z "$MOZ_LTO"; then
+            DISABLE_OUTLINER="-mno-outline"
+            _SAVE_CFLAGS=$CFLAGS
+            CFLAGS="$CFLAGS $DISABLE_OUTLINER"
+            AC_TRY_COMPILE(,,[MOZ_OPTIMIZE_FLAGS="$MOZ_OPTIMIZE_FLAGS $DISABLE_OUTLINER"])
+            CFLAGS="$_SAVE_CFLAGS"
+        else
+            DISABLE_OUTLINER="-Wl,-plugin-opt=-enable-machine-outliner=never"
+            _SAVE_LDFLAGS=$LDFLAGS
+            LDFLAGS="$LDFLAGS $MOZ_LTO_LDFLAGS $DISABLE_OUTLINER"
+            AC_TRY_LINK(,,[MOZ_OPTIMIZE_LDFLAGS="$MOZ_OPTIMIZE_LDFLAGS $DISABLE_OUTLINER"])
+            LDFLAGS="$_SAVE_LDFLAGS"
+        fi
+    fi
+    ;;
+
+*-*linux*)
+    if test "$GNU_CC" -o "$GNU_CXX"; then
+        MOZ_PGO_OPTIMIZE_FLAGS="-O3"
+        if test -n "$MOZ_DEBUG"; then
+            MOZ_OPTIMIZE_FLAGS="-Os"
+        else
+            MOZ_OPTIMIZE_FLAGS="-O2"
+        fi
+        if test -z "$CLANG_CC"; then
+           MOZ_OPTIMIZE_FLAGS="-freorder-blocks $MOZ_OPTIMIZE_FLAGS"
+        fi
+    fi
+
+    case "${target_cpu}" in
+    alpha*)
+        CFLAGS="$CFLAGS -mieee"
+        CXXFLAGS="$CXXFLAGS -mieee"
+    ;;
+    esac
+    ;;
+*-mingw*)
+    DSO_CFLAGS=
+    DSO_PIC_CFLAGS=
+    # certain versions of cygwin's makedepend barf on the
+    # #include <string> vs -I./dist/include/string issue so don't use it
+    if test -n "$GNU_CC" -o -n "$CLANG_CC"; then
+        # $GNU_CC will match gcc and clang; while $CLANG_CC will match only clang
+        if test -z "$CLANG_CC"; then
+            AC_MSG_ERROR(Firefox cannot be built with mingw-gcc and requires a mingw-clang toolchain to work)
+        fi
+
+        DSO_LDOPTS='-shared'
+        # mingw doesn't require kernel32, user32, and advapi32 explicitly
+        LIBS="$LIBS -luuid -lusp10 -lgdi32 -lwinmm -lwsock32 -luserenv -lsecur32"
+        MOZ_FIX_LINK_PATHS=
+
+        MOZ_OPTIMIZE_FLAGS="-O2"
+
+        WIN32_CONSOLE_EXE_LDFLAGS=-mconsole
+        WIN32_GUI_EXE_LDFLAGS=-mwindows
+
+        # Silence problematic clang warnings
+        CXXFLAGS="$CXXFLAGS -Wno-incompatible-ms-struct"
+        LDFLAGS="$LDFLAGS -Wl,--no-insert-timestamp"
+    else
+        TARGET_COMPILER_ABI=msvc
+        RANLIB='echo not_ranlib'
+        STRIP='echo not_strip'
+        # aarch64 doesn't support subsystems below 6.02
+        if test "$CPU_ARCH" = "aarch64"; then
+            WIN32_SUBSYSTEM_VERSION=6.02
+        else
+            WIN32_SUBSYSTEM_VERSION=6.01
+        fi
+        WIN32_CONSOLE_EXE_LDFLAGS=-SUBSYSTEM:CONSOLE,$WIN32_SUBSYSTEM_VERSION
+        WIN32_GUI_EXE_LDFLAGS=-SUBSYSTEM:WINDOWS,$WIN32_SUBSYSTEM_VERSION
+        DSO_LDOPTS=-SUBSYSTEM:WINDOWS,$WIN32_SUBSYSTEM_VERSION
+        _DEFINES_CFLAGS="-FI $_objdir/mozilla-config.h -DMOZILLA_CLIENT"
+        _DEFINES_CXXFLAGS="-FI $_objdir/mozilla-config.h -DMOZILLA_CLIENT"
+        CFLAGS="$CFLAGS -W3 -Gy -Zc:inline"
+        CXXFLAGS="$CXXFLAGS -W3 -Gy -Zc:inline"
+        if test -z "$CLANG_CL"; then
+            CPPFLAGS="$CPPFLAGS -utf-8"
+        fi
+        if test "$CPU_ARCH" = "x86"; then
+            dnl VS2012+ defaults to -arch:SSE2. We want to target nothing
+            dnl more recent, so set that explicitly here unless another
+            dnl target arch has already been set.
+            changequote(,)
+            if test -z `echo $CFLAGS | grep -i [-/]arch:`; then
+              CFLAGS="$CFLAGS -arch:SSE2"
+            fi
+            if test -z `echo $CXXFLAGS | grep -i [-/]arch:`; then
+              CXXFLAGS="$CXXFLAGS -arch:SSE2"
+            fi
+            changequote([,])
+            SSE_FLAGS="-arch:SSE"
+            SSE2_FLAGS="-arch:SSE2"
+            dnl MSVC allows the use of intrinsics without any flags
+            dnl and doesn't have a separate arch for SSSE3
+            SSSE3_FLAGS="-arch:SSE2"
+        fi
+        dnl clang-cl requires appropriate flags to enable SSSE3 support
+        dnl on all architectures.
+        if test -n "$CLANG_CL"; then
+            SSSE3_FLAGS="-mssse3"
+        fi
+        dnl VS2013+ supports -Gw for better linker optimizations.
+        dnl http://blogs.msdn.com/b/vcblog/archive/2013/09/11/introducing-gw-compiler-switch.aspx
+        dnl Disabled on ASan because it causes false-positive ODR violations.
+        if test -z "$MOZ_ASAN"; then
+            CFLAGS="$CFLAGS -Gw"
+            CXXFLAGS="$CXXFLAGS -Gw"
+        else
+            # String tail merging doesn't play nice with ASan's ODR checker.
+            LDFLAGS="$LDFLAGS -opt:nolldtailmerge"
+        fi
+        if test -n "$CLANG_CL"; then
+            # XXX We should combine some of these with our generic GCC-style
+            # warning checks.
+            #
+            # Suppress the clang-cl warning for the inline 'new' and 'delete' in mozalloc
+            CXXFLAGS="$CXXFLAGS -Wno-inline-new-delete"
+            # We use offsetof on non-POD objects all the time.
+            # We also suppress this warning on other platforms.
+            CXXFLAGS="$CXXFLAGS -Wno-invalid-offsetof"
+            # This warns for reasonable things like:
+            #   enum { X = 0xffffffffU };
+            # which is annoying for IDL headers.
+            CXXFLAGS="$CXXFLAGS -Wno-microsoft-enum-value"
+            # This warns for cases that would be reached by the Microsoft
+            # #include rules, but also currently warns on cases that would
+            # *also* be reached by standard C++ include rules.  That
+            # behavior doesn't seem useful, so we turn it off.
+            CXXFLAGS="$CXXFLAGS -Wno-microsoft-include"
+            # We normally error out on unknown pragmas, but since clang-cl
+            # claims to be MSVC, it would be difficult to add
+            # #if defined(_MSC_VER) && !defined(__clang__) everywhere we
+            # use such pragmas, so just ignore them.
+            CFLAGS="$CFLAGS -Wno-unknown-pragmas"
+            CXXFLAGS="$CXXFLAGS -Wno-unknown-pragmas"
+            # We get errors about various #pragma intrinsic directives from
+            # clang-cl, and we don't need to hear about those.
+            CFLAGS="$CFLAGS -Wno-ignored-pragmas"
+            CXXFLAGS="$CXXFLAGS -Wno-ignored-pragmas"
+            # clang-cl's Intrin.h marks things like _ReadWriteBarrier
+            # as __attribute((__deprecated__)).  This is nice to know,
+            # but since we don't get the equivalent warning from MSVC,
+            # let's just ignore it.
+            CFLAGS="$CFLAGS -Wno-deprecated-declarations"
+            CXXFLAGS="$CXXFLAGS -Wno-deprecated-declarations"
+            # We use a function like:
+            #   __declspec(noreturn) __inline void f() {}
+            # which -Winvalid-noreturn complains about.  Again, MSVC seems
+            # OK with it, so let's silence the warning.
+            CFLAGS="$CFLAGS -Wno-invalid-noreturn"
+            CXXFLAGS="$CXXFLAGS -Wno-invalid-noreturn"
+            # Missing |override| on virtual function declarations isn't
+            # something that MSVC currently warns about.
+            CXXFLAGS="$CXXFLAGS -Wno-inconsistent-missing-override"
+            # We use -DHAS_EXCEPTIONS=0, which removes the |throw()|
+            # declaration on |operator delete(void*)|.  However, clang-cl
+            # must internally declare |operator delete(void*)| differently,
+            # which causes this warning for virtually every file in the
+            # tree.  clang-cl doesn't support -fno-exceptions or equivalent,
+            # so there doesn't seem to be any way to convince clang-cl to
+            # declare |delete| differently.  Therefore, suppress this
+            # warning.
+            CXXFLAGS="$CXXFLAGS -Wno-implicit-exception-spec-mismatch"
+            # Macros like STDMETHOD() and IFACEMETHOD() can declare
+            # __attribute__((nothrow)) on their respective method declarations,
+            # while the definitions are left without the matching attribute.
+            CXXFLAGS="$CXXFLAGS -Wno-microsoft-exception-spec"
+            # At least one MSVC header and several headers in-tree have
+            # unused typedefs, so turn this on.
+            CXXFLAGS="$CXXFLAGS -Wno-unused-local-typedef"
+            # jemalloc uses __declspec(allocator) as a profiler hint,
+            # which clang-cl doesn't understand.
+            CXXFLAGS="$CXXFLAGS -Wno-ignored-attributes"
+            # __attribute__((unused)) really means "might be unused" and
+            # we use it to avoid warnings about things that are unused
+            # in some compilation units, but used in many others.  This
+            # warning insists on complaining about the latter case, which
+            # is annoying, and rather noisy.
+            CXXFLAGS="$CXXFLAGS -Wno-used-but-marked-unused"
+        fi
+        # Silence VS2017 15.5+ TR1 deprecation warnings hit by older gtest versions
+        CXXFLAGS="$CXXFLAGS -D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING"
+        LIBS="$LIBS user32.lib gdi32.lib winmm.lib wsock32.lib advapi32.lib secur32.lib"
+        MOZ_DEBUG_LDFLAGS='-DEBUG'
+        if test "$HOST_OS_ARCH" != "WINNT"; then
+          # %_PDB% is a special signal to emit only the PDB basename. This
+          # avoids problems in Windows tools that don't like forward-slashes.
+          MOZ_DEBUG_LDFLAGS="$MOZ_DEBUG_LDFLAGS -PDBALTPATH:%_PDB%"
+        fi
+        # Use a higher optimization level for clang-cl, so we can come closer
+        # to MSVC's performance numbers (see bug 1443590).
+        if test -n "$CLANG_CL"; then
+            MOZ_OPTIMIZE_FLAGS='-O2'
+        else
+            MOZ_OPTIMIZE_FLAGS='-O1 -Oi'
+        fi
+        MOZ_FIX_LINK_PATHS=
+        LDFLAGS="$LDFLAGS -LARGEADDRESSAWARE"
+        if test -z "$DEVELOPER_OPTIONS"; then
+            LDFLAGS="$LDFLAGS -RELEASE"
+        fi
+        dnl Minimum reqiurement of Gecko is VS2015 or later which supports
+        dnl both SSSE3 and SSE4.1.
+        HAVE_TOOLCHAIN_SUPPORT_MSSSE3=1
+        HAVE_TOOLCHAIN_SUPPORT_MSSE4_1=1
+        dnl allow AVX2 code from VS2015
+        HAVE_X86_AVX2=1
+    fi
+    AC_DEFINE(WIN32_LEAN_AND_MEAN)
+    dnl See http://support.microsoft.com/kb/143208 to use STL
+    AC_DEFINE(NOMINMAX)
+    BIN_SUFFIX='.exe'
+    MOZ_USER_DIR="Mozilla"
+
+    case "$host_os" in
+    cygwin*|msvc*|mks*)
+        AC_MSG_ERROR([Using a Cygwin build environment is unsupported. Configure cannot check for presence of necessary headers. Please upgrade to MozillaBuild; see https://developer.mozilla.org/en/Windows_Build_Prerequisites.])
+        ;;
+    esac
+
+    case "$target" in
+    i*86-*)
+        if test -n "$GNU_CC"; then
+            CFLAGS="$CFLAGS -mstackrealign"
+            CXXFLAGS="$CXXFLAGS -mstackrealign"
+            LDFLAGS="$LDFLAGS -Wl,--large-address-aware"
+        else
+            DSO_LDOPTS="$DSO_LDOPTS -MACHINE:X86"
+            LDFLAGS="$LDFLAGS -SAFESEH"
+        fi
+
+        AC_DEFINE(_X86_)
+        ;;
+    x86_64-*)
+        if test -n "$_WIN32_MSVC"; then
+            DSO_LDOPTS="$DSO_LDOPTS -MACHINE:X64"
+        fi
+        AC_DEFINE(_AMD64_)
+        ;;
+    aarch64-*)
+        if test -n "$_WIN32_MSVC"; then
+            DSO_LDOPTS="$DSO_LDOPTS -MACHINE:ARM64"
+        fi
+        AC_DEFINE(_ARM64_)
+        ;;
+    *)
+        AC_DEFINE(_CPU_ARCH_NOT_DEFINED)
+        ;;
+    esac
+    ;;
+
+*-netbsd*)
+    DSO_CFLAGS=''
+    CFLAGS="$CFLAGS -Dunix"
+    CXXFLAGS="$CXXFLAGS -Dunix"
+    if $CC -E - -dM </dev/null | grep __ELF__ >/dev/null; then
+        DSO_PIC_CFLAGS='-fPIC -DPIC'
+        DSO_LDOPTS='-shared'
+        MOZ_PROGRAM_LDFLAGS="$MOZ_PROGRAM_LDFLAGS -Wl,--export-dynamic"
+    else
+        DSO_PIC_CFLAGS='-fPIC -DPIC'
+        DSO_LDOPTS='-shared'
+    fi
+    # This will fail on a.out systems prior to 1.5.1_ALPHA.
+    if test "$LIBRUNPATH"; then
+        DSO_LDOPTS="-Wl,-R$LIBRUNPATH $DSO_LDOPTS"
+    fi
+    ;;
+
+*-openbsd*)
+    if test -z "$X11BASE"; then
+        X11BASE=/usr/X11R6
+    fi
+    MOZ_FIX_LINK_PATHS="$MOZ_FIX_LINK_PATHS -Wl,-rpath-link,${X11BASE}/lib"
+    DSO_CFLAGS=''
+    DSO_PIC_CFLAGS='-fPIC'
+    DSO_LDOPTS='-shared -fPIC'
+    if test "$LIBRUNPATH"; then
+        DSO_LDOPTS="-R$LIBRUNPATH $DSO_LDOPTS"
+    fi
+    ;;
+
+*-solaris*)
+    MOZ_FIX_LINK_PATHS="-L${DIST}/bin"
+    ;;
+
+esac
+
+if test -z "$MOZ_OPTIMIZE_FLAGS"; then
+    MOZ_OPTIMIZE_FLAGS="-O"
+fi
+
+AC_SUBST_LIST(MMX_FLAGS)
+AC_SUBST_LIST(SSE_FLAGS)
+AC_SUBST_LIST(SSE2_FLAGS)
+AC_SUBST_LIST(SSSE3_FLAGS)
+
+AC_SUBST(MOZ_LINKER)
+if test -n "$MOZ_LINKER"; then
+  AC_DEFINE(MOZ_LINKER)
+  MOZ_LINKER_EXTRACT=1
+  AC_CHECK_PROGS(XZ, xz)
+fi
+
+if test -z "$COMPILE_ENVIRONMENT"; then
+    SKIP_COMPILER_CHECKS=1
+    SKIP_LIBRARY_CHECKS=1
+    MOZ_DEBUGGING_OPTS
+else
+    MOZ_COMPILER_OPTS
+fi # COMPILE_ENVIRONMENT
+
+if test -z "$SKIP_COMPILER_CHECKS"; then
+dnl Checks for typedefs, structures, and compiler characteristics.
+dnl ========================================================
+AC_C_CONST
+AC_TYPE_MODE_T
+AC_TYPE_OFF_T
+AC_TYPE_PID_T
+AC_TYPE_SIZE_T
+AC_LANG_CPLUSPLUS
+AC_LANG_C
+
+AC_LANG_CPLUSPLUS
+
+MOZ_CXX11
+
+AC_LANG_C
+
+case "${OS_TARGET}" in
+Darwin)
+  ;;
+*)
+  STL_FLAGS="-I${DIST}/stl_wrappers"
+  WRAP_STL_INCLUDES=1
+  ;;
+esac
+
+if test "$MOZ_BUILD_APP" = "tools/crashreporter"; then
+    WRAP_STL_INCLUDES=
+fi
+
+dnl Checks for header files.
+dnl ========================================================
+AC_HEADER_DIRENT
+case "$target_os" in
+bitrig*|dragonfly*|freebsd*|openbsd*)
+# for stuff like -lXshm
+    CPPFLAGS="${CPPFLAGS} ${X_CFLAGS}"
+    ;;
+esac
+
+dnl Check for sin_len and sin6_len - used by SCTP; only appears in Mac/*BSD generally
+AC_CACHE_CHECK(for sockaddr_in.sin_len,
+                   ac_cv_sockaddr_in_sin_len,
+                   [AC_TRY_COMPILE([#ifdef HAVE_SYS_TYPES_H
+                                    #include <sys/types.h>
+                                    #endif
+                                    #include <netinet/in.h>
+                                    struct sockaddr_in x;
+                                    void *foo = (void*) &x.sin_len;],
+                                   [],
+                                   [ac_cv_sockaddr_in_sin_len=true],
+                                   [ac_cv_sockaddr_in_sin_len=false])])
+if test "$ac_cv_sockaddr_in_sin_len" = true ; then
+  AC_DEFINE(HAVE_SIN_LEN)
+dnl HAVE_CONN_LEN must be the same as HAVE_SIN_LEN (and HAVE_SIN6_LEN too)
+  AC_DEFINE(HAVE_SCONN_LEN)
+fi
+
+AC_CACHE_CHECK(for sockaddr_in6.sin6_len,
+               ac_cv_sockaddr_in6_sin6_len,
+               [AC_TRY_COMPILE([#ifdef HAVE_SYS_TYPES_H
+                                #include <sys/types.h>
+                                #endif
+                                #include <netinet/in.h>
+                                struct sockaddr_in6 x;
+                                void *foo = (void*) &x.sin6_len;],
+                               [],
+                               [ac_cv_sockaddr_in6_sin6_len=true],
+                               [ac_cv_sockaddr_in6_sin6_len=false])])
+if test "$ac_cv_sockaddr_in6_sin6_len" = true ; then
+  AC_DEFINE(HAVE_SIN6_LEN)
+fi
+
+AC_CACHE_CHECK(for sockaddr.sa_len,
+               ac_cv_sockaddr_sa_len,
+               [AC_TRY_COMPILE([#ifdef HAVE_SYS_TYPES_H
+                                #include <sys/types.h>
+                                #endif
+                                #include <sys/socket.h>
+                                struct sockaddr x;
+                                void *foo = (void*) &x.sa_len;],
+                               [],
+                               [ac_cv_sockaddr_sa_len=true],
+                               [ac_cv_sockaddr_sa_len=false])])
+if test "$ac_cv_sockaddr_sa_len" = true ; then
+  AC_DEFINE(HAVE_SA_LEN)
+fi
+
+dnl Checks for libraries.
+dnl ========================================================
+AC_CHECK_LIB(c_r, gethostbyname_r)
+
+dnl We don't want to link with libdl even if it's present on OS X, since
+dnl it's not used and not part of the default installation. OS/2 has dlfcn
+dnl in libc.
+dnl We don't want to link against libm or libpthread on Darwin since
+dnl they both are just symlinks to libSystem and explicitly linking
+dnl against libSystem causes issues when debugging (see bug 299601).
+case $target in
+*-darwin*)
+    ;;
+*)
+    AC_SEARCH_LIBS(dlopen, dl,
+        MOZ_CHECK_HEADER(dlfcn.h,
+        AC_DEFINE(HAVE_DLOPEN)))
+    ;;
+esac
+
+_SAVE_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS -D_GNU_SOURCE"
+AC_CHECK_FUNCS(dladdr memmem)
+CFLAGS="$_SAVE_CFLAGS"
+
+if test ! "$GNU_CXX"; then
+    AC_CHECK_LIB(C, demangle)
+fi
+
+AC_CHECK_LIB(socket, socket)
+
+XLDFLAGS="$X_LIBS"
+XLIBS="$X_EXTRA_LIBS"
+
+dnl ========================================================
+dnl Checks for X libraries.
+dnl Ordering is important.
+dnl Xt is dependent upon SM as of X11R6
+dnl ========================================================
+if test -n "$MOZ_X11"; then
+    AC_DEFINE_UNQUOTED(FUNCPROTO,15)
+    _SAVE_LDFLAGS="$LDFLAGS"
+    _SAVE_LIBS="$LIBS"
+    LDFLAGS="$XLDFLAGS $LDFLAGS"
+    AC_CHECK_LIB(X11, XDrawLines, [XLIBS="-lX11 $XLIBS"],
+        [MISSING_X="$MISSING_X -lX11"], $XLIBS)
+    AC_CHECK_LIB(Xext, XextAddDisplay, [XEXT_LIBS="-lXext"],
+        [MISSING_X="$MISSING_X -lXext"], $XLIBS)
+
+    AC_CHECK_LIB(Xt, XtFree, [ XT_LIBS="-lXt"], [
+        unset ac_cv_lib_Xt_XtFree
+        AC_CHECK_LIB(ICE, IceFlush, [XT_LIBS="-lICE $XT_LIBS"],, $XT_LIBS $XLIBS)
+        AC_CHECK_LIB(SM, SmcCloseConnection, [XT_LIBS="-lSM $XT_LIBS"],, $XT_LIBS $XLIBS)
+        AC_CHECK_LIB(Xt, XtFree, [ XT_LIBS="-lXt $XT_LIBS"],
+            [MISSING_X="$MISSING_X -lXt"], $X_PRE_LIBS $XT_LIBS $XLIBS)
+        ])
+
+    dnl ========================================================
+    dnl = Check for xcb
+    dnl ========================================================
+    AC_CHECK_LIB(xcb, xcb_connect, [XLIBS="-lxcb $XLIBS"],
+        [MISSING_X="$MISSING_X -lxcb"], $XLIBS)
+    AC_CHECK_LIB(xcb-shm, xcb_shm_query_version, [XLIBS="-lxcb-shm $XLIBS"],
+        [MISSING_X="$MISSING_X -lxcb-shm"], $XLIBS)
+    AC_CHECK_LIB(X11-xcb, XGetXCBConnection, [XLIBS="-lX11-xcb $XLIBS"],
+        [MISSING_X="$MISSING_X -lX11-xcb"], $XLIBS)
+
+    LDFLAGS="$_SAVE_LDFLAGS"
+    LIBS="$_SAVE_LIBS"
+fi # $MOZ_X11
+
+AC_SUBST_LIST(XCFLAGS)
+AC_SUBST_LIST(XLDFLAGS)
+AC_SUBST_LIST(XLIBS)
+AC_SUBST_LIST(XEXT_LIBS)
+AC_SUBST_LIST(XT_LIBS)
+
+dnl ========================================================
+dnl = pthread support
+dnl = Start by checking whether the system support pthreads
+dnl ========================================================
+case "$target_os" in
+darwin*)
+    MOZ_USE_PTHREADS=1
+    ;;
+*)
+    AC_CHECK_LIB(pthreads, pthread_create,
+        MOZ_USE_PTHREADS=1 _PTHREAD_LDFLAGS="-lpthreads",
+        AC_CHECK_LIB(pthread, pthread_create,
+            MOZ_USE_PTHREADS=1 _PTHREAD_LDFLAGS="-lpthread",
+            AC_CHECK_LIB(c_r, pthread_create,
+                MOZ_USE_PTHREADS=1 _PTHREAD_LDFLAGS="-lc_r",
+                AC_CHECK_LIB(c, pthread_create,
+                    MOZ_USE_PTHREADS=1
+                )
+            )
+        )
+    )
+    ;;
+esac
+
+dnl ========================================================
+dnl Do the platform specific pthread hackery
+dnl ========================================================
+if test "$MOZ_USE_PTHREADS"x != x
+then
+    dnl
+    dnl See if -pthread is supported.
+    dnl
+    rm -f conftest*
+    ac_cv_have_dash_pthread=no
+    AC_MSG_CHECKING(whether ${CC-cc} accepts -pthread)
+    echo 'int main() { return 0; }' | cat > conftest.c
+    ${CC-cc} -pthread -o conftest conftest.c > conftest.out 2>&1
+    if test $? -eq 0; then
+        if test -z "`egrep -i '(unrecognize|unknown)' conftest.out | grep pthread`" -a -z "`egrep -i '(error|incorrect)' conftest.out`" ; then
+            ac_cv_have_dash_pthread=yes
+            case "$target_os" in
+            freebsd*)
+# Freebsd doesn't use -pthread for compiles, it uses them for linking
+                ;;
+            *)
+                CFLAGS="$CFLAGS -pthread"
+                CXXFLAGS="$CXXFLAGS -pthread"
+                ;;
+            esac
+        fi
+    fi
+    rm -f conftest*
+    AC_MSG_RESULT($ac_cv_have_dash_pthread)
+
+    dnl
+    dnl See if -pthreads is supported.
+    dnl
+    ac_cv_have_dash_pthreads=no
+    if test "$ac_cv_have_dash_pthread" = "no"; then
+        AC_MSG_CHECKING(whether ${CC-cc} accepts -pthreads)
+        echo 'int main() { return 0; }' | cat > conftest.c
+        ${CC-cc} -pthreads -o conftest conftest.c > conftest.out 2>&1
+        if test $? -eq 0; then
+            if test -z "`egrep -i '(unrecognize|unknown)' conftest.out | grep pthreads`" -a -z "`egrep -i '(error|incorrect)' conftest.out`" ; then
+                ac_cv_have_dash_pthreads=yes
+                CFLAGS="$CFLAGS -pthreads"
+                CXXFLAGS="$CXXFLAGS -pthreads"
+            fi
+        fi
+        rm -f conftest*
+        AC_MSG_RESULT($ac_cv_have_dash_pthreads)
+    fi
+
+    case "$target" in
+        *-*-freebsd*)
+            AC_DEFINE(_REENTRANT)
+            AC_DEFINE(_THREAD_SAFE)
+            dnl -pthread links in -lpthread, so don't specify it explicitly.
+            if test "$ac_cv_have_dash_pthread" = "yes"; then
+                _PTHREAD_LDFLAGS="-pthread"
+            fi
+            ;;
+
+        *-*-openbsd*|*-*-bsdi*)
+            AC_DEFINE(_REENTRANT)
+            AC_DEFINE(_THREAD_SAFE)
+            dnl -pthread links in -lc_r, so don't specify it explicitly.
+            if test "$ac_cv_have_dash_pthread" = "yes"; then
+                _PTHREAD_LDFLAGS="-pthread"
+            fi
+            ;;
+
+        *-*-linux*|*-*-kfreebsd*-gnu|*-*-gnu*)
+            AC_DEFINE(_REENTRANT)
+            ;;
+
+    esac
+    LDFLAGS="${_PTHREAD_LDFLAGS} ${LDFLAGS}"
+    AC_SUBST(MOZ_USE_PTHREADS)
+    MOZ_CHECK_HEADERS(pthread.h)
+fi
+
+
+dnl Checks for library functions.
+dnl ========================================================
+AC_CHECK_FUNCS(stat64 lstat64 truncate64 statvfs64 statvfs statfs64 statfs getpagesize gmtime_r localtime_r arc4random arc4random_buf mallinfo gettid lchown setpriority strerror syscall lutimes)
+
+dnl check for clock_gettime(), the CLOCK_MONOTONIC clock
+AC_CACHE_CHECK(for clock_gettime(CLOCK_MONOTONIC),
+               ac_cv_clock_monotonic,
+               [for libs in "" -lrt; do
+                    _SAVE_LIBS="$LIBS"
+                    _SAVE_CFLAGS="$CFLAGS"
+                    LIBS="$LIBS $libs"
+                    CFLAGS="$CFLAGS $DSO_PIC_CFLAGS"
+dnl clock_gettime is available on OSX since 10.12, so depending on MACOSX_DEPLOYMENT_TARGET,
+dnl we should or not be able to use it. To detect if we can, we need to make the
+dnl availability attribute strict, so that compilation fails when the target is < 10.12.
+                    AC_TRY_LINK([#define availability(os, ...) availability(os, strict, __VA_ARGS)
+                                 #include <time.h>],
+                                 [ struct timespec ts;
+                                   clock_gettime(CLOCK_MONOTONIC, &ts); ],
+                                 ac_cv_clock_monotonic=$libs
+                                 LIBS="$_SAVE_LIBS"
+                                 CFLAGS="$_SAVE_CFLAGS"
+                                 break,
+                                 ac_cv_clock_monotonic=no)
+                    LIBS="$_SAVE_LIBS"
+                    CFLAGS="$_SAVE_CFLAGS"
+                done])
+if test "$ac_cv_clock_monotonic" != "no"; then
+    HAVE_CLOCK_MONOTONIC=1
+    REALTIME_LIBS=$ac_cv_clock_monotonic
+    AC_DEFINE(HAVE_CLOCK_MONOTONIC)
+    AC_SUBST(HAVE_CLOCK_MONOTONIC)
+    AC_SUBST_LIST(REALTIME_LIBS)
+fi
+
+dnl Turn on warnings-as-errors to prevent implicit declaration of
+dnl pthread_cond_timedwait_monotonic_np, which can cause this test to
+dnl inadvertently pass even if the function does not really exist.
+_SAVE_CFLAGS="$CFLAGS"
+CFLAGS="$CFLAGS $WARNINGS_AS_ERRORS"
+AC_CACHE_CHECK(for pthread_cond_timedwait_monotonic_np,
+               ac_cv_pthread_cond_timedwait_monotonic_np,
+               AC_TRY_LINK([#include <pthread.h>],
+                           [pthread_cond_timedwait_monotonic_np(0, 0, 0);],
+                           ac_cv_pthread_cond_timewait_monotonic_np=yes,
+                           ac_cv_pthread_cond_timewait_monotonic_np=no))
+if test "$ac_cv_pthread_cond_timewait_monotonic_np" != "no"; then
+    AC_DEFINE(HAVE_PTHREAD_COND_TIMEDWAIT_MONOTONIC)
+fi
+CFLAGS=$_SAVE_CFLAGS
+
+AC_CACHE_CHECK(
+    [for res_ninit()],
+    ac_cv_func_res_ninit,
+    [if test "$OS_TARGET" = NetBSD -o "$OS_TARGET" = OpenBSD; then
+        dnl no need for res_ninit() on NetBSD and OpenBSD
+        ac_cv_func_res_ninit=no
+     else
+        AC_TRY_LINK([
+            #ifdef linux
+            #define _BSD_SOURCE 1
+            #endif
+            #include <sys/types.h>
+            #include <netinet/in.h>
+            #include <arpa/nameser.h>
+            #include <resolv.h>
+            ],
+            [int foo = res_ninit(&_res);],
+            [ac_cv_func_res_ninit=yes],
+            [ac_cv_func_res_ninit=no])
+     fi
+    ])
+
+if test "$ac_cv_func_res_ninit" = "yes"; then
+    AC_DEFINE(HAVE_RES_NINIT)
+dnl must add the link line we do something as foolish as this... dougt
+dnl else
+dnl    AC_CHECK_LIB(bind, res_ninit, AC_DEFINE(HAVE_RES_NINIT),
+dnl        AC_CHECK_LIB(resolv, res_ninit, AC_DEFINE(HAVE_RES_NINIT)))
+fi
+
+AC_LANG_C
+
+dnl **********************
+dnl *** va_copy checks ***
+AC_CACHE_CHECK([for an implementation of va_copy()],
+               ac_cv_va_copy,
+    [AC_TRY_COMPILE([#include <stdarg.h>
+                     #include <stdlib.h>
+        void f (int i, ...) {
+            va_list args1, args2;
+            va_start (args1, i);
+            va_copy (args2, args1);
+            if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+                exit (1);
+            va_end (args1); va_end (args2);
+        }],
+        [f(0, 42); return 0],
+        [ac_cv_va_copy=yes],
+        [ac_cv_va_copy=no]
+    )]
+)
+AC_CACHE_CHECK([whether va_list can be copied by value],
+               ac_cv_va_val_copy,
+    [AC_TRY_COMPILE([#include <stdarg.h>
+                     #include <stdlib.h>
+        void f (int i, ...) {
+            va_list args1, args2;
+            va_start (args1, i);
+            args2 = args1;
+            if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)
+                exit (1);
+            va_end (args1); va_end (args2);
+        }],
+        [f(0, 42); return 0],
+        [ac_cv_va_val_copy=yes],
+        [ac_cv_va_val_copy=no],
+    )]
+)
+if test "x$ac_cv_va_copy" = "xyes"; then
+    AC_DEFINE(VA_COPY, va_copy)
+    AC_DEFINE(HAVE_VA_COPY)
+fi
+
+if test "x$ac_cv_va_val_copy" = "xno"; then
+   AC_DEFINE(HAVE_VA_LIST_AS_ARRAY)
+fi
+
+dnl ===================================================================
+dnl ========================================================
+dnl Put your C++ language/feature checks below
+dnl ========================================================
+AC_LANG_CPLUSPLUS
+
+ARM_ABI_PREFIX=
+if test "$GNU_CC"; then
+  if test "$CPU_ARCH" = "arm" ; then
+    AC_CACHE_CHECK(for ARM EABI,
+        ac_cv_gcc_arm_eabi,
+        [AC_TRY_COMPILE([],
+                        [
+#if defined(__ARM_EABI__)
+  return 0;
+#else
+#error Not ARM EABI.
+#endif
+                        ],
+                        ac_cv_gcc_arm_eabi="yes",
+                        ac_cv_gcc_arm_eabi="no")])
+    if test "$ac_cv_gcc_arm_eabi" = "yes"; then
+        HAVE_ARM_EABI=1
+        ARM_ABI_PREFIX=eabi-
+    else
+        ARM_ABI_PREFIX=oabi-
+    fi
+  fi
+
+  TARGET_COMPILER_ABI="${TARGET_COMPILER_ABI-${ARM_ABI_PREFIX}gcc3}"
+fi
+
+# try harder, when checking for __thread support, see bug 521750 comment #33 and below
+# We pass MOZ_OPTIMIZE_LDFLAGS to the linker because if dead_strip is
+# enabled, the linker in xcode 4.1 will crash. Without this it would crash when
+# linking XUL.
+_SAVE_LDFLAGS=$LDFLAGS
+LDFLAGS="$LDFLAGS $DSO_PIC_CFLAGS $DSO_LDOPTS $MOZ_OPTIMIZE_LDFLAGS"
+AC_CACHE_CHECK(for __thread keyword for TLS variables,
+               ac_cv_thread_keyword,
+               [AC_TRY_LINK([__thread bool tlsIsMainThread = false;],
+                            [return tlsIsMainThread;],
+                            ac_cv_thread_keyword=yes,
+                            ac_cv_thread_keyword=no)])
+LDFLAGS=$_SAVE_LDFLAGS
+# The custom dynamic linker doesn't support TLS variables
+MOZ_TLS=
+if test "$ac_cv_thread_keyword" = yes -a "$MOZ_LINKER" != 1; then
+  # mips builds fail with TLS variables because of a binutils bug.
+  # See bug 528687
+  # OpenBSD doesn't have TLS support, and the test succeeds with clang++
+  case "${target}" in
+    mips*-*)
+      :
+      ;;
+    *-android*|*-linuxandroid*)
+      :
+      ;;
+    *-openbsd*)
+      :
+      ;;
+    *)
+      AC_DEFINE(HAVE_THREAD_TLS_KEYWORD)
+      MOZ_TLS=1
+      ;;
+  esac
+fi
+
+dnl Using the custom linker on ARMv6 requires 16k alignment of ELF segments.
+if test -n "$MOZ_LINKER"; then
+  if test "$CPU_ARCH" = arm; then
+    dnl When building for < ARMv7, we need to ensure 16k alignment of ELF segments
+    if test -n "$ARM_ARCH" && test "$ARM_ARCH" -lt 7; then
+      LDFLAGS="$LDFLAGS -Wl,-z,max-page-size=0x4000 -Wl,-z,common-page-size=0x4000"
+      _SUBDIR_LDFLAGS="$_SUBDIR_LDFLAGS -Wl,-z,max-page-size=0x4000 -Wl,-z,common-page-size=0x4000"
+    fi
+  fi
+
+dnl gold emits wrong sysv-style elf hash tables when building both sysv and
+dnl style tables. https://sourceware.org/bugzilla/show_bug.cgi?id=13597
+dnl Since the linker only understands the sysv ones, no need to build the
+dnl gnu style tables anyways.
+  LDFLAGS="$LDFLAGS -Wl,--hash-style=sysv"
+fi
+
+dnl End of C++ language/feature checks
+AC_LANG_C
+
+dnl ========================================================
+dnl =  Internationalization checks
+dnl ========================================================
+dnl
+dnl Internationalization and Locale support is different
+dnl on various UNIX platforms.  Checks for specific i18n
+dnl features go here.
+
+AC_HAVE_FUNCS(localeconv)
+
+fi # ! SKIP_COMPILER_CHECKS
+
+if test -n "${COMPILE_ENVIRONMENT}"; then
+  MOZ_CHECK_ALLOCATOR
+fi
+
+TARGET_XPCOM_ABI=
+if test -n "${CPU_ARCH}" -a -n "${TARGET_COMPILER_ABI}"; then
+    TARGET_XPCOM_ABI="${CPU_ARCH}-${TARGET_COMPILER_ABI}"
+    AC_DEFINE_UNQUOTED(TARGET_XPCOM_ABI, ["${TARGET_XPCOM_ABI}"])
+fi
+
+dnl We can't run TRY_COMPILE tests on Windows, so hard-code some
+dnl features that Windows actually does support.
+
+if test -n "$SKIP_COMPILER_CHECKS"; then
+   dnl Windows has malloc.h
+   AC_DEFINE(MALLOC_H, [<malloc.h>])
+   AC_DEFINE(HAVE_FORCEINLINE)
+   AC_DEFINE(HAVE_LOCALECONV)
+fi # SKIP_COMPILER_CHECKS
+
+dnl Mozilla specific options
+dnl ========================================================
+dnl The macros used for command line options
+dnl are defined in build/autoconf/altoptions.m4.
+
+dnl ========================================================
+dnl =
+dnl = Check for external package dependencies
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(External Packages)
+
+dnl ========================================================
+dnl system libevent Support
+dnl ========================================================
+MOZ_ARG_WITH_STRING(system-libevent,
+[  --with-system-libevent[=PFX]
+                          Use system libevent [installed at prefix PFX]],
+    LIBEVENT_DIR=$withval)
+
+_SAVE_CFLAGS=$CFLAGS
+_SAVE_LDFLAGS=$LDFLAGS
+_SAVE_LIBS=$LIBS
+if test "$LIBEVENT_DIR" = yes; then
+    PKG_CHECK_MODULES(MOZ_LIBEVENT, libevent,
+        MOZ_SYSTEM_LIBEVENT=1,
+        LIBEVENT_DIR=/usr)
+fi
+if test -z "$LIBEVENT_DIR" -o "$LIBEVENT_DIR" = no; then
+    MOZ_SYSTEM_LIBEVENT=
+elif test -z "$MOZ_SYSTEM_LIBEVENT"; then
+    CFLAGS="-I${LIBEVENT_DIR}/include $CFLAGS"
+    LDFLAGS="-L${LIBEVENT_DIR}/lib $LDFLAGS"
+    MOZ_CHECK_HEADER(event.h,
+        [if test ! -f "${LIBEVENT_DIR}/include/event.h"; then
+             AC_MSG_ERROR([event.h found, but is not in ${LIBEVENT_DIR}/include])
+         fi],
+        AC_MSG_ERROR([--with-system-libevent requested but event.h not found]))
+    AC_CHECK_LIB(event, event_init,
+                 [MOZ_SYSTEM_LIBEVENT=1
+                  MOZ_LIBEVENT_CFLAGS="-I${LIBEVENT_DIR}/include"
+                  MOZ_LIBEVENT_LIBS="-L${LIBEVENT_DIR}/lib -levent"],
+                 [MOZ_SYSTEM_LIBEVENT= MOZ_LIBEVENT_CFLAGS= MOZ_LIBEVENT_LIBS=])
+fi
+CFLAGS=$_SAVE_CFLAGS
+LDFLAGS=$_SAVE_LDFLAGS
+LIBS=$_SAVE_LIBS
+
+AC_SUBST(MOZ_SYSTEM_LIBEVENT)
+
+if test -z "$SKIP_LIBRARY_CHECKS"; then
+
+dnl ========================================================
+dnl system PNG Support
+dnl ========================================================
+MOZ_ARG_WITH_STRING(system-png,
+[  --with-system-png[=PFX]
+                          Use system libpng [installed at prefix PFX]],
+    PNG_DIR=$withval)
+
+_SAVE_CFLAGS=$CFLAGS
+_SAVE_LDFLAGS=$LDFLAGS
+_SAVE_LIBS=$LIBS
+if test -n "${PNG_DIR}" -a "${PNG_DIR}" != "yes"; then
+    CFLAGS="-I${PNG_DIR}/include $CFLAGS"
+    LDFLAGS="-L${PNG_DIR}/lib $LDFLAGS"
+fi
+if test -z "$PNG_DIR" -o "$PNG_DIR" = no; then
+    MOZ_SYSTEM_PNG=
+else
+    AC_CHECK_LIB(png, png_get_valid, [MOZ_SYSTEM_PNG=1 MOZ_PNG_LIBS="-lpng"],
+                 AC_MSG_ERROR([--with-system-png requested but no working libpng found]))
+    AC_CHECK_LIB(png, png_get_acTL, ,
+                 AC_MSG_ERROR([--with-system-png won't work because the system's libpng doesn't have APNG support]))
+fi
+if test "$MOZ_SYSTEM_PNG" = 1; then
+    AC_TRY_COMPILE([ #include <stdio.h>
+                     #include <sys/types.h>
+                     #include <png.h> ],
+                   [ #if PNG_LIBPNG_VER < $MOZPNG
+                     #error "Insufficient libpng version ($MOZPNG required)."
+                     #endif
+                     #ifndef PNG_UINT_31_MAX
+                     #error "Insufficient libpng version."
+                     #endif ],
+                   MOZ_SYSTEM_PNG=1,
+                   AC_MSG_ERROR([--with-system-png requested but no working libpng found]))
+fi
+CFLAGS=$_SAVE_CFLAGS
+LDFLAGS=$_SAVE_LDFLAGS
+LIBS=$_SAVE_LIBS
+
+if test "${PNG_DIR}" -a -d "${PNG_DIR}" -a "$MOZ_SYSTEM_PNG" = 1; then
+    MOZ_PNG_CFLAGS="-I${PNG_DIR}/include"
+    MOZ_PNG_LIBS="-L${PNG_DIR}/lib ${MOZ_PNG_LIBS}"
+fi
+
+fi # SKIP_LIBRARY_CHECKS
+
+dnl ========================================================
+dnl =
+dnl = Application
+dnl =
+dnl ========================================================
+
+MOZ_ARG_HEADER(Application)
+
+ENABLE_SYSTEM_EXTENSION_DIRS=1
+MOZ_BRANDING_DIRECTORY=
+MOZ_OFFICIAL_BRANDING=
+MOZ_AUTH_EXTENSION=1
+MOZ_SPELLCHECK=1
+MOZ_UNIVERSALCHARDET=1
+MOZ_XUL=1
+MOZ_ZIPWRITER=1
+MOZ_NO_SMART_CARDS=
+MOZ_SANDBOX=1
+MOZ_BINARY_EXTENSIONS=
+MOZ_DEVTOOLS=server
+
+dnl ========================================================
+dnl = Trademarked Branding
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(official-branding,
+[  --enable-official-branding
+                          Enable Official mozilla.org Branding
+                          Do not distribute builds with
+                          --enable-official-branding unless you have
+                          permission to use trademarks per
+                          http://www.mozilla.org/foundation/trademarks/ .],
+    MOZ_OFFICIAL_BRANDING=1,
+    MOZ_OFFICIAL_BRANDING=)
+
+# Allow the application to influence configure with a confvars.sh script.
+AC_MSG_CHECKING([if app-specific confvars.sh exists])
+if test -f "${srcdir}/${MOZ_BUILD_APP}/confvars.sh" ; then
+  AC_MSG_RESULT([${srcdir}/${MOZ_BUILD_APP}/confvars.sh])
+  . "${srcdir}/${MOZ_BUILD_APP}/confvars.sh"
+else
+  AC_MSG_RESULT([no])
+fi
+
+dnl ========================================================
+dnl Ensure Android SDK and build-tools versions depending on
+dnl mobile target.
+dnl ========================================================
+
+case "$MOZ_BUILD_APP" in
+mobile/android)
+    MOZ_ANDROID_SDK
+    ;;
+esac
+
+dnl ========================================================
+dnl =
+dnl = Toolkit Options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Toolkit Options)
+
+dnl ========================================================
+dnl = Enable the toolkit as needed                         =
+dnl ========================================================
+
+case "$MOZ_WIDGET_TOOLKIT" in
+
+cocoa)
+    LDFLAGS="$LDFLAGS -framework Cocoa"
+    # Use -Wl as a trick to avoid -framework and framework names from
+    # being separated by AC_SUBST_LIST.
+    TK_LIBS='-Wl,-framework,Foundation -Wl,-framework,CoreFoundation -Wl,-framework,CoreLocation -Wl,-framework,QuartzCore -Wl,-framework,Carbon -Wl,-framework,CoreAudio -Wl,-framework,CoreVideo -Wl,-framework,AudioToolbox -Wl,-framework,AudioUnit -Wl,-framework,AddressBook -Wl,-framework,OpenGL -Wl,-framework,Security -Wl,-framework,ServiceManagement -Wl,-framework,CoreServices -Wl,-framework,ApplicationServices -Wl,-framework,AppKit'
+    TK_CFLAGS=""
+    CFLAGS="$CFLAGS $TK_CFLAGS"
+    CXXFLAGS="$CXXFLAGS $TK_CFLAGS"
+    MOZ_USER_DIR="Mozilla"
+    MOZ_FS_LAYOUT=bundle
+    ;;
+
+uikit)
+    LDFLAGS="$LDFLAGS -framework UIKit"
+    TK_CFLAGS=""
+    TK_LIBS='-Wl,-framework,Foundation -Wl,-framework,CoreFoundation -Wl,-framework,CoreGraphics -Wl,-framework,CoreText -Wl,-framework,AVFoundation -Wl,-framework,AudioToolbox -Wl,-framework,CoreMedia -Wl,-framework,CoreVideo -Wl,-framework,OpenGLES -Wl,-framework,QuartzCore'
+    CFLAGS="$CFLAGS $TK_CFLAGS"
+    CXXFLAGS="$CXXFLAGS $TK_CFLAGS"
+    MOZ_USER_DIR="Mozilla"
+    MOZ_FS_LAYOUT=bundle
+    ;;
+
+esac
+
+if test "$OS_TARGET" = Darwin; then
+    LDFLAGS="$LDFLAGS -lobjc"
+fi
+
+dnl there are a lot of tests on MOZ_ENABLE_GTK below, that are more convenient
+dnl to keep that way than testing against MOZ_WIDGET_TOOLKIT
+case "$MOZ_WIDGET_TOOLKIT" in
+gtk*)
+    MOZ_ENABLE_GTK=1
+    ;;
+esac
+
+if test "$COMPILE_ENVIRONMENT"; then
+  if test "$MOZ_WIDGET_TOOLKIT" = gtk; then
+    PKG_CHECK_MODULES(MOZ_GTK3, gtk+-3.0 >= $GTK3_VERSION gtk+-unix-print-3.0 glib-2.0 gobject-2.0 gio-unix-2.0 $GDK_PACKAGES)
+    MOZ_GTK3_CFLAGS="-I${_topsrcdir}/widget/gtk/compat-gtk3 $MOZ_GTK3_CFLAGS"
+    TK_CFLAGS=$MOZ_GTK3_CFLAGS
+    TK_LIBS=$MOZ_GTK3_LIBS
+    dnl GDK_VERSION_MIN_REQUIRED is not set here as GDK3 deprecated warnings
+    dnl are suppressed by widget/gtk/compat-gtk3/gdk/gdkversionmacros.h.
+    AC_DEFINE_UNQUOTED(GDK_VERSION_MAX_ALLOWED,$GDK_VERSION_MAX_ALLOWED)
+  fi
+  if test "$MOZ_ENABLE_GTK"; then
+    AC_DEFINE_UNQUOTED(GLIB_VERSION_MIN_REQUIRED,$GLIB_VERSION_MIN_REQUIRED)
+    AC_DEFINE_UNQUOTED(GLIB_VERSION_MAX_ALLOWED,$GLIB_VERSION_MAX_ALLOWED)
+
+    if test "$MOZ_X11"; then
+      PKG_CHECK_MODULES(MOZ_GTK2, gtk+-2.0 >= $GTK2_VERSION gtk+-unix-print-2.0 glib-2.0 >= $GLIB_VERSION gobject-2.0 gio-unix-2.0 gdk-x11-2.0)
+      MOZ_GTK2_CFLAGS="-I${_topsrcdir}/widget/gtk/compat $MOZ_GTK2_CFLAGS"
+    fi
+  fi
+fi # COMPILE_ENVIRONMENT
+
+AC_SUBST(MOZ_FS_LAYOUT)
+
+AC_SUBST_LIST(TK_CFLAGS)
+AC_SUBST_LIST(TK_LIBS)
+
+dnl ========================================================
+dnl =
+dnl = Components & Features
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Components and Features)
+
+AC_SUBST(MOZ_OFFICIAL_BRANDING)
+if test -n "$MOZ_OFFICIAL_BRANDING"; then
+  if test -z "$MOZ_OFFICIAL_BRANDING_DIRECTORY"; then
+    AC_MSG_ERROR([You must specify MOZ_OFFICIAL_BRANDING_DIRECTORY to use --enable-official-branding.])
+  else
+    MOZ_BRANDING_DIRECTORY=${MOZ_OFFICIAL_BRANDING_DIRECTORY}
+    AC_DEFINE(MOZ_OFFICIAL_BRANDING)
+  fi
+fi
+
+MOZ_ARG_WITH_STRING(branding,
+[  --with-branding=dir     Use branding from the specified directory.],
+    MOZ_BRANDING_DIRECTORY=$withval)
+
+REAL_BRANDING_DIRECTORY="${MOZ_BRANDING_DIRECTORY}"
+if test -z "$REAL_BRANDING_DIRECTORY"; then
+  REAL_BRANDING_DIRECTORY=${MOZ_BUILD_APP}/branding/nightly
+fi
+
+if test -f "${_topsrcdir}/$REAL_BRANDING_DIRECTORY/configure.sh"; then
+  . "${_topsrcdir}/$REAL_BRANDING_DIRECTORY/configure.sh"
+fi
+
+AC_SUBST(MOZ_BRANDING_DIRECTORY)
+
+dnl ========================================================
+dnl = Distribution ID
+dnl ========================================================
+MOZ_ARG_WITH_STRING(distribution-id,
+[  --with-distribution-id=ID
+                          Set distribution-specific id (default=org.mozilla)],
+[ val=`echo $withval`
+    MOZ_DISTRIBUTION_ID="$val"])
+
+if test -z "$MOZ_DISTRIBUTION_ID"; then
+   MOZ_DISTRIBUTION_ID="org.mozilla"
+fi
+
+AC_DEFINE_UNQUOTED(MOZ_DISTRIBUTION_ID,"$MOZ_DISTRIBUTION_ID")
+AC_SUBST(MOZ_DISTRIBUTION_ID)
+
+dnl ========================================================
+dnl = libproxy support
+dnl ========================================================
+
+if test "$MOZ_ENABLE_GTK"
+then
+    MOZ_ENABLE_LIBPROXY=
+
+    MOZ_ARG_ENABLE_BOOL(libproxy,
+    [  --enable-libproxy         Enable libproxy support ],
+    MOZ_ENABLE_LIBPROXY=1,
+    MOZ_ENABLE_LIBPROXY=)
+
+    if test "$MOZ_ENABLE_LIBPROXY"
+    then
+        PKG_CHECK_MODULES(MOZ_LIBPROXY, libproxy-1.0)
+        AC_DEFINE(MOZ_ENABLE_LIBPROXY)
+    fi
+fi
+AC_SUBST(MOZ_ENABLE_LIBPROXY)
+
+dnl ========================================================
+dnl = dbus support
+dnl ========================================================
+
+if test "$MOZ_ENABLE_GTK"
+then
+    MOZ_ENABLE_DBUS=1
+
+    MOZ_ARG_DISABLE_BOOL(dbus,
+    [  --disable-dbus          Disable dbus support ],
+        MOZ_ENABLE_DBUS=,
+        MOZ_ENABLE_DBUS=1)
+
+    if test "$MOZ_ENABLE_DBUS"
+    then
+        PKG_CHECK_MODULES(MOZ_DBUS, dbus-1 >= $DBUS_VERSION)
+        PKG_CHECK_MODULES(MOZ_DBUS_GLIB, dbus-glib-1 >= $DBUS_VERSION)
+        AC_DEFINE(MOZ_ENABLE_DBUS)
+    fi
+fi
+AC_SUBST(MOZ_ENABLE_DBUS)
+
+AC_TRY_COMPILE([#include <linux/ethtool.h>],
+               [ struct ethtool_cmd cmd; cmd.speed_hi = 0; ],
+               MOZ_WEBRTC_HAVE_ETHTOOL_SPEED_HI=1)
+
+AC_SUBST(MOZ_WEBRTC_HAVE_ETHTOOL_SPEED_HI)
+
+if test -n "$MOZ_WEBRTC"; then
+    if test -n "$MOZ_X11"; then
+      MOZ_WEBRTC_X11_LIBS="-lXext -lXdamage -lXfixes -lXcomposite"
+    fi
+fi
+
+AC_SUBST_LIST(MOZ_WEBRTC_X11_LIBS)
+
+dnl ========================================================
+dnl = Apple platform decoder support
+dnl ========================================================
+if test "$COMPILE_ENVIRONMENT"; then
+if test -n "$MOZ_APPLEMEDIA"; then
+  # hack in frameworks for fmp4 - see bug 1029974
+  # We load VideoToolbox and CoreMedia dynamically, so they don't appear here.
+  LDFLAGS="$LDFLAGS -framework AudioToolbox"
+  dnl Verify CoreMedia is available.
+  AC_CHECK_HEADERS([CoreMedia/CoreMedia.h VideoToolbox/VideoToolbox.h], [],
+    [AC_MSG_ERROR([MacOS X 10.9 SDK or later is required])])
+fi
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl = Handle dependent MEDIA defines
+dnl ========================================================
+
+MOZ_WEBM_ENCODER=1
+AC_DEFINE(MOZ_WEBM_ENCODER)
+AC_SUBST(MOZ_WEBM_ENCODER)
+
+dnl ========================================================
+dnl NegotiateAuth
+dnl ========================================================
+
+MOZ_ARG_DISABLE_BOOL(negotiateauth,
+[  --disable-negotiateauth Disable GSS-API negotiation ],
+    MOZ_AUTH_EXTENSION=,
+    MOZ_AUTH_EXTENSION=1 )
+
+dnl ========================================================
+dnl Searching of system directories for extensions.
+dnl Note: this switch is meant to be used for test builds
+dnl whose behavior should not depend on what happens to be
+dnl installed on the local machine.
+dnl ========================================================
+MOZ_ARG_DISABLE_BOOL(system-extension-dirs,
+[  --disable-system-extension-dirs
+                          Disable searching system- and account-global
+                          directories for extensions of any kind; use
+                          only profile-specific extension directories],
+  ENABLE_SYSTEM_EXTENSION_DIRS=,
+  ENABLE_SYSTEM_EXTENSION_DIRS=1 )
+if test "$ENABLE_SYSTEM_EXTENSION_DIRS"; then
+  AC_DEFINE(ENABLE_SYSTEM_EXTENSION_DIRS)
+fi
+
+dnl ========================================================
+dnl = Universalchardet
+dnl ========================================================
+MOZ_ARG_DISABLE_BOOL(universalchardet,
+[  --disable-universalchardet
+                          Disable universal encoding detection],
+  MOZ_UNIVERSALCHARDET=,
+  MOZ_UNIVERSALCHARDET=1 )
+
+dnl ========================================================
+dnl Gamepad support
+dnl ========================================================
+
+if test "$COMPILE_ENVIRONMENT" ; then
+
+dnl Moved gamepad platform check to moz.build, linux header check still needed here.
+if test "$OS_TARGET" = "Linux"; then
+    MOZ_CHECK_HEADER([linux/joystick.h])
+    if test "$ac_cv_header_linux_joystick_h" != "yes"; then
+      AC_MSG_ERROR([Can't find header linux/joystick.h, needed for gamepad support. Please install Linux kernel headers.])
+    fi
+fi
+
+fi # COMPILE_ENVIRONMENT
+
+
+dnl ========================================================
+dnl = Breakpad crash reporting (on by default on supported platforms)
+dnl ========================================================
+
+case $target in
+i?86-*-mingw*|x86_64-*-mingw*|aarch64-*-mingw*)
+  MOZ_CRASHREPORTER=1
+  ;;
+i?86-apple-darwin*|x86_64-apple-darwin*|aarch64-apple-darwin*)
+  MOZ_CRASHREPORTER=1
+  ;;
+*-android*|*-linuxandroid*)
+  dnl Android/arm is arm-unknown-linux-androideabi, so android condition should
+  dnl be before Linux condition
+  dnl The crash reporter prevents crash stacktraces to be logged in the
+  dnl logs so we leave it out by default in developer builds.
+  if test -z "$DEVELOPER_OPTIONS"; then
+    MOZ_CRASHREPORTER=1
+  fi
+  ;;
+i?86-*-linux*|x86_64-*-linux*|arm-*-linux*)
+  if test "$MOZ_ENABLE_GTK"; then
+    MOZ_CRASHREPORTER=1
+  fi
+  ;;
+esac
+
+MOZ_ARG_DISABLE_BOOL(crashreporter,
+[  --disable-crashreporter Disable breakpad crash reporting],
+    [MOZ_CRASHREPORTER=],
+    [MOZ_CRASHREPORTER=F # Force enable breakpad])
+
+if test "$OS_ARCH" != "$HOST_OS_ARCH" -a "$OS_ARCH" != "WINNT" -a "$OS_ARCH" != "Darwin" -a "$MOZ_WIDGET_TOOLKIT" != "android"; then
+  if test "$MOZ_CRASHREPORTER" = F; then
+    AC_MSG_ERROR([Cannot --enable-crashreporter, as breakpad tools do not support compiling on $HOST_OS_ARCH while targeting $OS_ARCH.])
+  fi
+  MOZ_CRASHREPORTER=
+fi
+
+if test -n "$MOZ_CRASHREPORTER"; then
+   AC_DEFINE(MOZ_CRASHREPORTER)
+
+  if test "$OS_TARGET" = "Linux" && \
+    test -z "$SKIP_LIBRARY_CHECKS"; then
+    PKG_CHECK_MODULES(MOZ_GTHREAD, gthread-2.0)
+  fi
+
+  if test "$OS_ARCH" = "WINNT"; then
+    if test -z "$HAVE_64BIT_BUILD" -a -n "$COMPILE_ENVIRONMENT"; then
+      MOZ_CRASHREPORTER_INJECTOR=1
+      AC_DEFINE(MOZ_CRASHREPORTER_INJECTOR)
+    fi
+  fi
+fi
+
+dnl ========================================================
+dnl = Enable compilation of specific extension modules
+dnl ========================================================
+
+MOZ_ARG_ENABLE_STRING(extensions,
+[  --enable-extensions     Enable extensions],
+[ for option in `echo $enableval | sed 's/,/ /g'`; do
+    if test "$option" = "yes" -o "$option" = "all"; then
+        AC_MSG_ERROR([--enable-extensions=$option is no longer supported.])
+    elif test "$option" = "no" -o "$option" = "none"; then
+        MOZ_EXTENSIONS=""
+    elif test "$option" = "default"; then
+        MOZ_EXTENSIONS="$MOZ_EXTENSIONS $MOZ_EXTENSIONS_DEFAULT"
+    elif test `echo "$option" | grep -c \^-` != 0; then
+        option=`echo $option | sed 's/^-//'`
+        MOZ_EXTENSIONS=`echo "$MOZ_EXTENSIONS" | sed "s/ ${option}//"`
+    else
+        MOZ_EXTENSIONS="$MOZ_EXTENSIONS $option"
+    fi
+done],
+    MOZ_EXTENSIONS="$MOZ_EXTENSIONS_DEFAULT")
+
+dnl Ensure every extension exists, to avoid mostly-inscrutable error messages
+dnl when trying to build a nonexistent extension.
+for extension in $MOZ_EXTENSIONS; do
+    if test ! -d "${srcdir}/extensions/${extension}"; then
+        AC_MSG_ERROR([Unrecognized extension provided to --enable-extensions: ${extension}.])
+    fi
+done
+
+# Avoid defining MOZ_ENABLE_CAIRO_FT on Windows platforms because
+# "cairo-ft-font.c" includes <dlfcn.h>, which only exists on posix platforms
+if test -n "$MOZ_TREE_FREETYPE" -a "$OS_TARGET" != WINNT; then
+   MOZ_ENABLE_CAIRO_FT=1
+   FT_FONT_FEATURE="#define CAIRO_HAS_FT_FONT 1"
+   CAIRO_FT_CFLAGS="-I$_topsrcdir/modules/freetype2/include"
+   AC_SUBST_LIST(CAIRO_FT_CFLAGS)
+fi
+
+dnl ========================================================
+dnl Updater
+dnl ========================================================
+
+MOZ_ARG_DISABLE_BOOL(updater,
+[  --disable-updater       Disable building of updater],
+    MOZ_UPDATER=,
+    MOZ_UPDATER=1 )
+
+if test -n "$MOZ_UPDATER"; then
+    AC_DEFINE(MOZ_UPDATER)
+fi
+
+dnl ========================================================
+dnl parental controls (for Windows Vista)
+dnl ========================================================
+MOZ_ARG_DISABLE_BOOL(parental-controls,
+[  --disable-parental-controls
+                          Do not build parental controls],
+   MOZ_DISABLE_PARENTAL_CONTROLS=1,
+   MOZ_DISABLE_PARENTAL_CONTROLS=)
+if test -n "$MOZ_DISABLE_PARENTAL_CONTROLS"; then
+    AC_DEFINE(MOZ_DISABLE_PARENTAL_CONTROLS)
+fi
+
+AC_SUBST(MOZ_DISABLE_PARENTAL_CONTROLS)
+
+dnl ========================================================
+dnl = Disable smartcard support
+dnl ========================================================
+if test -n "$MOZ_NO_SMART_CARDS"; then
+    AC_DEFINE(MOZ_NO_SMART_CARDS)
+fi
+AC_SUBST(MOZ_NO_SMART_CARDS)
+
+dnl ========================================================
+dnl = Sandboxing support
+dnl ========================================================
+if test -n "$MOZ_TSAN" -o -n "$MOZ_ASAN"; then
+    # Bug 1182565: TSan conflicts with sandboxing on Linux.
+    # Bug 1287971: LSan also conflicts with sandboxing on Linux.
+    case $OS_TARGET in
+    Linux|Android)
+        MOZ_SANDBOX=
+        ;;
+    esac
+fi
+
+MOZ_ARG_DISABLE_BOOL(sandbox,
+[  --disable-sandbox        Disable sandboxing support],
+    MOZ_SANDBOX=,
+    MOZ_SANDBOX=1)
+
+case "$OS_TARGET" in
+WINNT|Darwin|OpenBSD)
+;;
+Linux)
+    case $CPU_ARCH in
+        x86_64|x86|arm|aarch64)
+        ;;
+        # Linux sandbox is only available on x86{,_64} and arm{,64}.
+        *)
+            MOZ_SANDBOX=
+        ;;
+    esac
+    ;;
+*)
+    # Only enable the sandbox by default on Linux, OpenBSD, macOS, and Windows
+    MOZ_SANDBOX=
+;;
+esac
+
+if test -n "$MOZ_SANDBOX"; then
+    AC_DEFINE(MOZ_SANDBOX)
+fi
+
+AC_SUBST(MOZ_SANDBOX)
+
+
+dnl ========================================================
+dnl =
+dnl = Module specific options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Individual module options)
+
+dnl ==============================
+dnl === SQLite fdatasync check ===
+dnl ==============================
+dnl Check to see if fdatasync is available and make use of it
+AC_CHECK_FUNC(fdatasync)
+
+dnl ========================================================
+dnl = Disable zipwriter
+dnl ========================================================
+MOZ_ARG_DISABLE_BOOL(zipwriter,
+[  --disable-zipwriter     Disable zipwriter component],
+    MOZ_ZIPWRITER=,
+    MOZ_ZIPWRITER=1 )
+AC_SUBST(MOZ_ZIPWRITER)
+
+dnl ========================================================
+dnl =
+dnl = Feature options that require extra sources to be pulled
+dnl =
+dnl ========================================================
+dnl MOZ_ARG_HEADER(Features that require extra sources)
+
+dnl ========================================================
+dnl =
+dnl = Runtime debugging and Optimization Options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Runtime debugging and Optimizations)
+
+dnl ========================================================
+dnl = Enable code optimization. ON by default.
+dnl ========================================================
+
+# Use value from moz.configure if one is defined. Else use our computed
+# value.
+if test -n "${MOZ_CONFIGURE_OPTIMIZE_FLAGS}"; then
+    MOZ_OPTIMIZE_FLAGS=${MOZ_CONFIGURE_OPTIMIZE_FLAGS}
+fi
+
+if test "$COMPILE_ENVIRONMENT"; then
+if test -n "$MOZ_OPTIMIZE"; then
+    AC_MSG_CHECKING([for valid C compiler optimization flags])
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS $MOZ_OPTIMIZE_FLAGS"
+    AC_TRY_COMPILE([#include <stdio.h>],
+        [printf("Hello World\n");],
+        _results=yes,
+        _results=no)
+    AC_MSG_RESULT([$_results])
+    if test "$_results" = "no"; then
+        AC_MSG_ERROR([These compiler flags for C are invalid: $MOZ_OPTIMIZE_FLAGS])
+    fi
+    CFLAGS=$_SAVE_CFLAGS
+    if test -n "$MOZ_LTO" -a -n "$CLANG_CC"; then
+        # When using llvm-based LTO, non numeric optimization levels are
+        # not supported by the linker, so force the linker to use -O2 (
+        # which doesn't influence the level compilation units are actually
+        # compiled at).
+        case " $MOZ_OPTIMIZE_FLAGS " in
+        *\ -Os\ *|*\ -Oz\ *)
+            MOZ_OPTIMIZE_LDFLAGS="$MOZ_OPTIMIZE_LDFLAGS -O2"
+            ;;
+        esac
+    fi
+fi
+fi # COMPILE_ENVIRONMENT
+
+AC_SUBST_LIST(MOZ_OPTIMIZE_FLAGS)
+AC_SUBST_LIST(MOZ_OPTIMIZE_LDFLAGS)
+AC_SUBST_LIST(MOZ_PGO_OPTIMIZE_FLAGS)
+
+dnl ========================================================
+dnl = Enable runtime logging
+dnl ========================================================
+AC_DEFINE(MOZ_LOGGING)
+AC_DEFINE(FORCE_PR_LOG)
+
+dnl ========================================================
+dnl = This will enable logging of addref, release, ctor, dtor.
+dnl ========================================================
+_ENABLE_LOGREFCNT=42
+MOZ_ARG_ENABLE_BOOL(logrefcnt,
+[  --enable-logrefcnt      Enable logging of refcounts (default=debug) ],
+    _ENABLE_LOGREFCNT=1,
+    _ENABLE_LOGREFCNT= )
+if test "$_ENABLE_LOGREFCNT" = "1"; then
+    AC_DEFINE(FORCE_BUILD_REFCNT_LOGGING)
+elif test -z "$_ENABLE_LOGREFCNT"; then
+    AC_DEFINE(NO_BUILD_REFCNT_LOGGING)
+fi
+
+dnl ========================================================
+dnl moz_dump_painting
+dnl ========================================================
+MOZ_ARG_ENABLE_BOOL(dump-painting,
+[  --enable-dump-painting          Enable paint debugging.],
+    MOZ_DUMP_PAINTING=1,
+    MOZ_DUMP_PAINTING= )
+if test -n "$MOZ_DUMP_PAINTING"; then
+    AC_DEFINE(MOZ_DUMP_PAINTING)
+    AC_DEFINE(MOZ_LAYERS_HAVE_LOG)
+fi
+if test -n "$MOZ_DEBUG"; then
+    AC_DEFINE(MOZ_DUMP_PAINTING)
+fi
+
+case "${OS_TARGET}" in
+Android|WINNT|Darwin)
+  MOZ_GLUE_IN_PROGRAM=
+  ;;
+*)
+  dnl On !Android !Windows !OSX, we only want to link executables against mozglue
+  MOZ_GLUE_IN_PROGRAM=1
+  AC_DEFINE(MOZ_GLUE_IN_PROGRAM)
+  ;;
+esac
+
+dnl ========================================================
+dnl = Jemalloc build setup
+dnl ========================================================
+if test -z "$MOZ_MEMORY"; then
+  case "${target}" in
+    *-mingw*)
+      if test -z "$WIN32_REDIST_DIR" -a -z "$MOZ_DEBUG"; then
+        AC_MSG_WARN([When not building jemalloc, you need to set WIN32_REDIST_DIR to the path to the Visual C++ Redist (usually VCINSTALLDIR/redist/x86/Microsoft.VC80.CRT, for VC++ v8) if you intend to distribute your build.])
+      fi
+      ;;
+  esac
+else
+  dnl The generic feature tests that determine how to compute ncpus are long and
+  dnl complicated.  Therefore, simply define special cpp variables for the
+  dnl platforms we have special knowledge of.
+  case "${target}" in
+  *-mingw*)
+    export MOZ_NO_DEBUG_RTL=1
+    ;;
+  esac
+fi # MOZ_MEMORY
+AC_SUBST(MOZ_GLUE_IN_PROGRAM)
+
+dnl ========================================================
+dnl = Enable using the clang plugin to build
+dnl ========================================================
+
+if test -n "$COMPILE_ENVIRONMENT"; then
+MOZ_CONFIG_CLANG_PLUGIN
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl = frontend JS debug mode
+dnl ========================================================
+
+MOZ_ARG_ENABLE_BOOL(debug-js-modules,
+[  --enable-debug-js-modules  Enable debug mode for frontend JS libraries],
+   DEBUG_JS_MODULES=1,
+   DEBUG_JS_MODULES=)
+
+AC_SUBST(DEBUG_JS_MODULES)
+
+dnl ========================================================
+dnl =
+dnl = Profiling and Instrumenting
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Profiling and Instrumenting)
+
+dnl ========================================================
+dnl = Support for demangling undefined symbols
+dnl ========================================================
+if test -z "$SKIP_LIBRARY_CHECKS"; then
+    AC_LANG_SAVE
+    AC_LANG_CPLUSPLUS
+    AC_CHECK_FUNCS(__cxa_demangle, HAVE_DEMANGLE=1, HAVE_DEMANGLE=)
+    AC_LANG_RESTORE
+fi
+
+# Demangle only for debug or DMD builds
+MOZ_DEMANGLE_SYMBOLS=
+if test "$HAVE_DEMANGLE" && test "$MOZ_DEBUG" -o "$MOZ_DMD"; then
+    MOZ_DEMANGLE_SYMBOLS=1
+    AC_DEFINE(MOZ_DEMANGLE_SYMBOLS)
+fi
+AC_SUBST(MOZ_DEMANGLE_SYMBOLS)
+
+dnl ========================================================
+dnl = Support for gcc stack unwinding (from gcc 3.3)
+dnl ========================================================
+if test -z "$SKIP_LIBRARY_CHECKS"; then
+    AC_LANG_SAVE
+    AC_LANG_CPLUSPLUS
+    MOZ_CHECK_HEADER(unwind.h, AC_CHECK_FUNCS(_Unwind_Backtrace))
+    AC_LANG_RESTORE
+fi
+
+dnl ========================================================
+dnl =
+dnl = Misc. Options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Misc. Options)
+
+dnl ========================================================
+dnl = Location of the mozilla user directory (default is ~/.mozilla).],
+dnl ========================================================
+MOZ_ARG_WITH_STRING(user-appdir,
+[  --with-user-appdir=DIR  Set user-specific appdir (default=.mozilla)],
+[ val=`echo $withval`
+if echo "$val" | grep "\/" >/dev/null; then
+    AC_MSG_ERROR("Homedir must be single relative path.")
+else
+    MOZ_USER_DIR="$val"
+fi])
+
+AC_DEFINE_UNQUOTED(MOZ_USER_DIR,"$MOZ_USER_DIR")
+
+if test -z "$SKIP_COMPILER_CHECKS"; then
+dnl ========================================================
+dnl =
+dnl = Compiler Options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Compiler Options)
+
+dnl ========================================================
+dnl Check for gcc -pipe support
+dnl ========================================================
+AC_MSG_CHECKING([for -pipe support])
+if test -n "$GNU_CC" -a -n "$GNU_CXX"; then
+    dnl Any gcc that supports firefox supports -pipe.
+    CFLAGS="$CFLAGS -pipe"
+    CXXFLAGS="$CXXFLAGS -pipe"
+    AC_MSG_RESULT([yes])
+else
+    AC_MSG_RESULT([no])
+fi
+
+fi # ! SKIP_COMPILER_CHECKS
+
+AC_LANG_C
+
+if test "$COMPILE_ENVIRONMENT"; then
+MOZ_EXPAND_LIBS
+fi # COMPILE_ENVIRONMENT
+
+dnl ========================================================
+dnl =
+dnl = Static Build Options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Static build options)
+
+if test -z "$MOZ_SYSTEM_ZLIB"; then
+if test -n "$JS_SHARED_LIBRARY" -o -n "$MOZ_LINKER" -o "$MOZ_WIDGET_TOOLKIT" = android; then
+  ZLIB_IN_MOZGLUE=1
+  AC_DEFINE(ZLIB_IN_MOZGLUE)
+fi
+fi
+
+AC_SUBST(ZLIB_IN_MOZGLUE)
+
+dnl ========================================================
+dnl =
+dnl = Standalone module options
+dnl =
+dnl ========================================================
+MOZ_ARG_HEADER(Standalone module options (Not for building Mozilla))
+
+dnl Check for GLib.
+dnl ========================================================
+
+if test -z "$SKIP_PATH_CHECKS"; then
+if test -z "${GLIB_CFLAGS}" -o -z "${GLIB_LIBS}" ; then
+    if test "$MOZ_ENABLE_GTK" ; then
+        PKG_CHECK_MODULES(GLIB, glib-2.0 >= 1.3.7 gobject-2.0)
+    fi
+fi
+fi
+
+if test -z "${GLIB_GMODULE_LIBS}" \
+   -a -n "${GLIB_CONFIG}"\
+    -a "${GLIB_CONFIG}" != no\
+; then
+    GLIB_GMODULE_LIBS=`$GLIB_CONFIG gmodule --libs`
+fi
+
+AC_SUBST_LIST(GLIB_GMODULE_LIBS)
+
+if test "$USE_FC_FREETYPE"; then
+    if test "$COMPILE_ENVIRONMENT"; then
+        dnl ========================================================
+        dnl = Check for freetype2 functionality
+        dnl ========================================================
+        if test "$_HAVE_FREETYPE2" -a -z "$MOZ_TREE_FREETYPE"; then
+            _SAVE_LIBS="$LIBS"
+            _SAVE_CFLAGS="$CFLAGS"
+            LIBS="$LIBS $FT2_LIBS"
+            CFLAGS="$CFLAGS $FT2_CFLAGS"
+
+            AC_CACHE_CHECK(for FT_Bitmap_Size.y_ppem,
+                ac_cv_member_FT_Bitmap_Size_y_ppem,
+                [AC_TRY_COMPILE([#include <ft2build.h>
+                                 #include FT_FREETYPE_H],
+                                [FT_Bitmap_Size s;
+                                 if (sizeof s.y_ppem) return 0;
+                                 return 1],
+                                ac_cv_member_FT_Bitmap_Size_y_ppem=yes,
+                                ac_cv_member_FT_Bitmap_Size_y_ppem=no)])
+            if test "$ac_cv_member_FT_Bitmap_Size_y_ppem" = yes; then
+                HAVE_FT_BITMAP_SIZE_Y_PPEM=1
+            else
+                HAVE_FT_BITMAP_SIZE_Y_PPEM=0
+            fi
+            AC_DEFINE_UNQUOTED(HAVE_FT_BITMAP_SIZE_Y_PPEM,
+                               $HAVE_FT_BITMAP_SIZE_Y_PPEM,
+                               [FT_Bitmap_Size structure includes y_ppem field])
+
+            AC_CHECK_FUNCS(FT_GlyphSlot_Embolden FT_Load_Sfnt_Table)
+
+            LIBS="$_SAVE_LIBS"
+            CFLAGS="$_SAVE_CFLAGS"
+        fi
+
+        _SAVE_CPPFLAGS="$CPPFLAGS"
+        CPPFLAGS="$CPPFLAGS $FT2_CFLAGS $XCFLAGS"
+        MOZ_CHECK_HEADERS([fontconfig/fcfreetype.h], ,
+            [AC_MSG_ERROR(Can't find header fontconfig/fcfreetype.h.)], [#include <fontconfig/fontconfig.h>])
+        CPPFLAGS="$_SAVE_CPPFLAGS"
+    fi
+fi
+
+dnl ========================================================
+dnl Check for graphite2
+dnl ========================================================
+if test -n "$MOZ_SYSTEM_GRAPHITE2"; then
+    dnl graphite2.pc has bogus version, check manually
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS $MOZ_GRAPHITE2_CFLAGS"
+    AC_TRY_COMPILE([ #include <graphite2/Font.h>
+                     #define GR2_VERSION_REQUIRE(major,minor,bugfix)  \
+                             ( GR2_VERSION_MAJOR * 10000 + GR2_VERSION_MINOR \
+                               * 100 + GR2_VERSION_BUGFIX >= \
+                               (major) * 10000 + (minor) * 100 + (bugfix) )
+                   ], [
+                     #if !GR2_VERSION_REQUIRE(1,3,8)
+                     #error "Insufficient graphite2 version."
+                     #endif
+                   ], [],
+                   [AC_MSG_ERROR([--with-system-graphite2 requested but no working libgraphite2 found])])
+    CFLAGS=$_SAVE_CFLAGS
+fi
+
+dnl ========================================================
+dnl Check if we need the 32-bit Linux SSE2 error dialog
+dnl ========================================================
+
+AC_SUBST(MOZ_LINUX_32_SSE2_STARTUP_ERROR)
+
+dnl ========================================================
+dnl Check for pixman and cairo
+dnl ========================================================
+
+MOZ_TREE_CAIRO=1
+MOZ_ARG_ENABLE_BOOL(system-cairo,
+[ --enable-system-cairo  Obsolete: do not use this option],
+AC_MSG_ERROR(--enable-system-cairo is not supported),
+MOZ_TREE_CAIRO=1 )
+
+MOZ_TREE_PIXMAN=1
+MOZ_ARG_ENABLE_BOOL(system-pixman,
+[ --enable-system-pixman Use system pixman (located with pkgconfig)],
+MOZ_TREE_PIXMAN=,
+MOZ_TREE_PIXMAN=force,
+MOZ_TREE_PIXMAN=1 )
+
+if test "$MOZ_TREE_PIXMAN"; then
+    AC_DEFINE(MOZ_TREE_PIXMAN)
+else
+    PKG_CHECK_MODULES(MOZ_PIXMAN, pixman-1 >= 0.19.2)
+fi
+
+MOZ_CAIRO_CFLAGS="-I${DIST}/include/cairo"
+AC_DEFINE(MOZ_TREE_CAIRO)
+
+if test "$OS_ARCH" = "WINNT"; then
+    # For now we assume that we will have a uint64_t available through
+    # one of the above headers or mozstdint.h.
+    AC_DEFINE(HAVE_UINT64_T)
+fi
+
+# Define macros for cairo-features.h
+TEE_SURFACE_FEATURE="#define CAIRO_HAS_TEE_SURFACE 1"
+if test "$MOZ_X11"; then
+    XLIB_SURFACE_FEATURE="#define CAIRO_HAS_XLIB_SURFACE 1"
+    XLIB_XRENDER_SURFACE_FEATURE="#define CAIRO_HAS_XLIB_XRENDER_SURFACE 1"
+    PS_SURFACE_FEATURE="#define CAIRO_HAS_PS_SURFACE 1"
+fi
+if test "$_HAVE_FREETYPE2"; then
+    FT_FONT_FEATURE="#define CAIRO_HAS_FT_FONT 1"
+    MOZ_ENABLE_CAIRO_FT=1
+    CAIRO_FT_CFLAGS="$FT2_CFLAGS"
+fi
+
+case "$MOZ_WIDGET_TOOLKIT" in
+  cocoa | uikit)
+    QUARTZ_SURFACE_FEATURE="#define CAIRO_HAS_QUARTZ_SURFACE 1"
+    QUARTZ_IMAGE_SURFACE_FEATURE="#define CAIRO_HAS_QUARTZ_IMAGE_SURFACE 1"
+    QUARTZ_FONT_FEATURE="#define CAIRO_HAS_QUARTZ_FONT 1"
+    ;;
+  windows)
+    WIN32_DWRITE_FONT_FEATURE="#define CAIRO_HAS_DWRITE_FONT 1"
+    WIN32_FONT_FEATURE="#define CAIRO_HAS_WIN32_FONT 1"
+    WIN32_SURFACE_FEATURE="#define CAIRO_HAS_WIN32_SURFACE 1"
+
+    if test "$COMPILE_ENVIRONMENT"; then
+      MOZ_CHECK_HEADER(d3d10.h, MOZ_ENABLE_D3D10_LAYER=1)
+    fi
+    ;;
+esac
+if test "$USE_FC_FREETYPE"; then
+    FC_FONT_FEATURE="#define CAIRO_HAS_FC_FONT 1"
+fi
+AC_SUBST(MOZ_ENABLE_CAIRO_FT)
+AC_SUBST(MOZ_ENABLE_D3D10_LAYER)
+
+AC_SUBST(PS_SURFACE_FEATURE)
+AC_SUBST(SVG_SURFACE_FEATURE)
+AC_SUBST(XLIB_SURFACE_FEATURE)
+AC_SUBST(XLIB_XRENDER_SURFACE_FEATURE)
+AC_SUBST(QUARTZ_SURFACE_FEATURE)
+AC_SUBST(QUARTZ_IMAGE_SURFACE_FEATURE)
+AC_SUBST(WIN32_SURFACE_FEATURE)
+AC_SUBST(OS2_SURFACE_FEATURE)
+AC_SUBST(DIRECTFB_SURFACE_FEATURE)
+AC_SUBST(FT_FONT_FEATURE)
+AC_SUBST(FC_FONT_FEATURE)
+AC_SUBST(WIN32_FONT_FEATURE)
+AC_SUBST(WIN32_DWRITE_FONT_FEATURE)
+AC_SUBST(QUARTZ_FONT_FEATURE)
+AC_SUBST(PNG_FUNCTIONS_FEATURE)
+AC_SUBST(QT_SURFACE_FEATURE)
+AC_SUBST(TEE_SURFACE_FEATURE)
+
+if test "$MOZ_X11"; then
+    MOZ_CAIRO_OSLIBS="$MOZ_CAIRO_OSLIBS $XLDFLAGS -lXrender"
+fi
+
+CAIRO_FEATURES_H=gfx/cairo/cairo/src/cairo-features.h
+
+case "$MOZ_WIDGET_TOOLKIT" in
+android)
+    TK_CFLAGS="$MOZ_CAIRO_CFLAGS $MOZ_PIXMAN_CFLAGS"
+    TK_LIBS="$MOZ_CAIRO_LIBS $MOZ_PIXMAN_LIBS"
+    ;;
+esac
+
+AC_SUBST(MOZ_TREE_CAIRO)
+AC_SUBST_LIST(MOZ_CAIRO_CFLAGS)
+AC_SUBST_LIST(MOZ_CAIRO_LIBS)
+AC_SUBST_LIST(MOZ_CAIRO_OSLIBS)
+AC_SUBST(MOZ_TREE_PIXMAN)
+
+BINDGEN_SYSTEM_FLAGS="$_BINDGEN_CFLAGS $NSPR_CFLAGS $NSS_CFLAGS $MOZ_PIXMAN_CFLAGS $MOZ_CAIRO_CFLAGS"
+AC_SUBST(BINDGEN_SYSTEM_FLAGS)
+BINDGEN_SYSTEM_TOML_FLAGS="$BINDGEN_SYSTEM_FLAGS"
+AC_SUBST_TOML_LIST(BINDGEN_SYSTEM_TOML_FLAGS)
+
+dnl ========================================================
+dnl disable xul
+dnl ========================================================
+MOZ_ARG_DISABLE_BOOL(xul,
+[  --disable-xul           Disable XUL],
+    MOZ_XUL= )
+if test "$MOZ_XUL"; then
+  AC_DEFINE(MOZ_XUL)
+else
+  dnl remove extensions that require XUL
+  MOZ_EXTENSIONS=`echo $MOZ_EXTENSIONS | sed -e 's/inspector//' -e 's/irc//' -e 's/tasks//'`
+fi
+
+AC_SUBST(MOZ_XUL)
+
+dnl ========================================================
+dnl necko configuration options
+dnl ========================================================
+
+dnl
+dnl option to disable necko's wifi scanner
+dnl
+
+if test "$MOZ_WIDGET_TOOLKIT"; then
+
+  case "$OS_TARGET" in
+    Darwin)
+      NECKO_WIFI=1
+      ;;
+    DragonFly|FreeBSD|WINNT)
+      NECKO_WIFI=1
+      ;;
+    Linux)
+      NECKO_WIFI=1
+      NECKO_WIFI_DBUS=1
+      ;;
+  esac
+
+fi
+
+MOZ_ARG_DISABLE_BOOL(necko-wifi,
+[  --disable-necko-wifi    Disable necko wifi scanner],
+    NECKO_WIFI=,
+    NECKO_WIFI=1)
+
+if test "$NECKO_WIFI"; then
+  if test -z "$MOZ_ENABLE_DBUS" -a -n "$NECKO_WIFI_DBUS"; then
+    AC_MSG_ERROR([Necko WiFi scanning needs DBus on your platform, remove --disable-dbus or use --disable-necko-wifi])
+  fi
+  AC_DEFINE(NECKO_WIFI)
+fi
+AC_SUBST(NECKO_WIFI)
+AC_SUBST(NECKO_WIFI_DBUS)
+
+dnl ========================================================
+dnl =
+dnl = Maintainer debug option (no --enable equivalent)
+dnl =
+dnl ========================================================
+
+AC_SUBST(NM)
+AC_SUBST_LIST(ASFLAGS)
+AC_SUBST(IMPLIB)
+AC_SUBST(FILTER)
+AC_SUBST(MOZ_AUTH_EXTENSION)
+AC_SUBST_LIST(MOZ_DEBUG_LDFLAGS)
+AC_SUBST_LIST(WARNINGS_CFLAGS)
+AC_SUBST_SET(MOZ_EXTENSIONS)
+
+AC_SUBST(MOZ_UNIVERSALCHARDET)
+AC_SUBST(MOZ_SPELLCHECK)
+AC_SUBST(MOZ_ANDROID_ANR_REPORTER)
+AC_SUBST(MOZ_CRASHREPORTER)
+AC_SUBST(MOZ_CRASHREPORTER_INJECTOR)
+AC_SUBST(MOZ_STUB_INSTALLER)
+AC_SUBST(MOZ_UPDATER)
+
+AC_SUBST(MOZ_ANDROID_APPLICATION_CLASS)
+AC_SUBST(MOZ_ANDROID_BROWSER_INTENT_CLASS)
+AC_SUBST(INCREMENTAL_LINKER)
+
+AC_SUBST_LIST(MOZ_FIX_LINK_PATHS)
+
+AC_SUBST(MOZ_POST_PROGRAM_COMMAND)
+AC_SUBST(MOZ_LINKER_EXTRACT)
+
+if test -n "$MOZ_BINARY_EXTENSIONS"; then
+  AC_DEFINE(MOZ_BINARY_EXTENSIONS)
+fi
+
+AC_SUBST(MOZ_REQUIRE_SIGNING)
+if test "$MOZ_REQUIRE_SIGNING" = 1; then
+  AC_DEFINE(MOZ_REQUIRE_SIGNING)
+fi
+
+dnl ========================================================
+dnl = Mac bundle name prefix
+dnl ========================================================
+MOZ_ARG_WITH_STRING(macbundlename-prefix,
+[  --with-macbundlename-prefix=prefix
+                          Prefix for MOZ_MACBUNDLE_NAME],
+[ MOZ_MACBUNDLE_NAME_PREFIX="$withval"])
+
+MOZ_MACBUNDLE_NAME=$MOZ_APP_DISPLAYNAME
+if test "$MOZ_MACBUNDLE_NAME_PREFIX"; then
+  MOZ_MACBUNDLE_NAME="${MOZ_MACBUNDLE_NAME_PREFIX}${MOZ_MACBUNDLE_NAME}"
+fi
+
+if test "$MOZ_DEBUG"; then
+  MOZ_MACBUNDLE_NAME="${MOZ_MACBUNDLE_NAME}Debug.app"
+else
+  MOZ_MACBUNDLE_NAME=${MOZ_MACBUNDLE_NAME}.app
+fi
+AC_SUBST(MOZ_MACBUNDLE_NAME)
+
+dnl Mac bundle identifier (based on MOZ_APP_DISPLAYNAME)
+# If the MOZ_MACBUNDLE_ID is defined in the configure.sh, use it
+# Otherwise, use MOZ_APP_DISPLAYNAME
+if test -z "$MOZ_MACBUNDLE_ID"; then
+   MOZ_MACBUNDLE_ID=`echo $MOZ_APP_DISPLAYNAME | tr 'A-Z' 'a-z' | tr -dc 'a-z-'`
+fi
+MOZ_MACBUNDLE_ID=${MOZ_DISTRIBUTION_ID}.${MOZ_MACBUNDLE_ID}
+if test "$MOZ_DEBUG"; then
+  MOZ_MACBUNDLE_ID=${MOZ_MACBUNDLE_ID}debug
+fi
+
+AC_DEFINE_UNQUOTED(MOZ_MACBUNDLE_ID,$MOZ_MACBUNDLE_ID)
+AC_SUBST(MOZ_MACBUNDLE_ID)
+
+dnl ========================================================
+dnl = Child Process Name for IPC
+dnl ========================================================
+if test "$MOZ_WIDGET_TOOLKIT" != "android"; then
+  MOZ_CHILD_PROCESS_NAME="plugin-container${BIN_SUFFIX}"
+else
+  # We want to let Android unpack the file at install time, but it only does
+  # so if the file is named libsomething.so. The lib/ path is also required
+  # because the unpacked file will be under the lib/ subdirectory and will
+  # need to be executed from that path.
+  MOZ_CHILD_PROCESS_NAME="libplugin-container.so"
+fi
+MOZ_CHILD_PROCESS_BUNDLE="plugin-container.app/Contents/MacOS/"
+MOZ_CHILD_PROCESS_BUNDLENAME="${MOZ_APP_DISPLAYNAME}CP"
+
+AC_SUBST(MOZ_CHILD_PROCESS_NAME)
+AC_SUBST(MOZ_CHILD_PROCESS_BUNDLE)
+AC_SUBST(MOZ_CHILD_PROCESS_BUNDLENAME)
+
+# The following variables are available to branding and application
+# configuration ($BRANDING/configure.sh and $APPLICATION/confvars.sh):
+# - MOZ_APP_VENDOR: Used for application.ini's "Vendor" field, which also
+# impacts profile location and user-visible fields.
+# - MOZ_APP_DISPLAYNAME: Used in user-visible fields (DLL properties,
+# Mac Bundle name, Updater, Installer), it is typically used for nightly
+# builds (e.g. Aurora for Firefox).
+# - MOZ_APP_PROFILE: When set, used for application.ini's
+# "Profile" field, which controls profile location.
+# - MOZ_APP_ID: When set, used for application.ini's "ID" field, and
+# crash reporter server url.
+# - MOZ_PROFILE_MIGRATOR: When set, enables profile migrator.
+
+# The following environment variables used to have an effect, but don't anymore:
+# - MOZ_APP_VERSION: Defines the application version number. This was replaced with
+# the contents from the version.txt file in the application directory, or
+# browser/config/version.txt if there isn't one.
+# - MOZ_APP_VERSION_DISPLAY: Defines the application version number. Used
+# in the "About" window. This was replaced with the contents from the
+# version_display.txt or version.txt in the application directory, or
+# browser/config/version_display.txt.
+
+# For extensions and langpacks, we require a max version that is compatible
+# across security releases. MOZ_APP_MAXVERSION is our method for doing that.
+# 24.0a1 and 24.0a2 aren't affected
+# 24.0 becomes 24.*
+# 24.1.1 becomes 24.*
+IS_ALPHA=`echo $MOZ_APP_VERSION | grep a`
+if test -z "$IS_ALPHA"; then
+  changequote(,)
+  if test "$(basename $MOZ_BUILD_APP)" = "suite"; then
+    MOZ_APP_MAXVERSION=`echo $MOZ_APP_VERSION | sed "s|\(^[0-9]*\.[0-9]*\).*|\1|"`.*
+  else
+    MOZ_APP_MAXVERSION=`echo $MOZ_APP_VERSION | sed "s|\(^[0-9]*\).*|\1|"`.*
+  fi
+  changequote([,])
+else
+  MOZ_APP_MAXVERSION=$MOZ_APP_VERSION
+fi
+
+AC_SUBST(MOZ_APP_DISPLAYNAME)
+AC_SUBST(MOZ_APP_VENDOR)
+AC_SUBST(MOZ_APP_PROFILE)
+AC_SUBST(MOZ_APP_ID)
+AC_SUBST(MAR_CHANNEL_ID)
+AC_SUBST(ACCEPTED_MAR_CHANNEL_IDS)
+AC_SUBST(MOZ_PROFILE_MIGRATOR)
+AC_DEFINE_UNQUOTED(MOZ_APP_UA_NAME, "$MOZ_APP_UA_NAME")
+AC_SUBST(MOZ_APP_UA_NAME)
+AC_DEFINE_UNQUOTED(MOZ_APP_UA_VERSION, "$MOZ_APP_VERSION")
+AC_DEFINE_UNQUOTED(BROWSER_CHROME_URL, $BROWSER_CHROME_URL)
+AC_DEFINE_UNQUOTED(BROWSER_CHROME_URL_QUOTED, "$BROWSER_CHROME_URL")
+
+AC_SUBST(MOZ_APP_MAXVERSION)
+AC_SUBST(MOZ_UA_OS_AGNOSTIC)
+if test -n "$MOZ_UA_OS_AGNOSTIC"; then
+  AC_DEFINE(MOZ_UA_OS_AGNOSTIC)
+fi
+
+AC_SUBST(MOZ_PKG_SPECIAL)
+AC_SUBST(MOZ_SIMPLE_PACKAGE_NAME)
+
+if test "$MOZILLA_OFFICIAL"; then
+    # Build revisions should always be present in official builds
+    MOZ_INCLUDE_SOURCE_INFO=1
+fi
+
+# External builds (specifically Ubuntu) may drop the hg repo information, so we allow to
+# explicitly set the repository and changeset information in.
+AC_SUBST(MOZ_SOURCE_REPO)
+AC_SUBST(MOZ_SOURCE_CHANGESET)
+AC_SUBST(MOZ_INCLUDE_SOURCE_INFO)
+
+dnl If we have any service that uploads data (and requires data submission
+dnl policy alert), set MOZ_DATA_REPORTING.
+dnl We need SUBST for build system and DEFINE for xul preprocessor.
+if test -n "$MOZ_TELEMETRY_REPORTING" || test -n "$MOZ_SERVICES_HEALTHREPORT" || test -n "$MOZ_CRASHREPORTER"  || test -n "$MOZ_NORMANDY"; then
+  MOZ_DATA_REPORTING=1
+  AC_DEFINE(MOZ_DATA_REPORTING)
+  AC_SUBST(MOZ_DATA_REPORTING)
+fi
+
+dnl win32 options
+AC_SUBST(WIN32_REDIST_DIR)
+AC_SUBST(WIN_UCRT_REDIST_DIR)
+
+dnl Echo the CFLAGS to remove extra whitespace.
+CFLAGS=`echo \
+    $_COMPILATION_CFLAGS \
+    $CFLAGS`
+
+CXXFLAGS=`echo \
+    $_WARNINGS_CXXFLAGS \
+    $_COMPILATION_CXXFLAGS \
+    $CXXFLAGS`
+
+COMPILE_CFLAGS=`echo \
+    $_DEFINES_CFLAGS \
+    $COMPILE_CFLAGS`
+
+COMPILE_CXXFLAGS=`echo \
+    $_DEFINES_CXXFLAGS \
+    $COMPILE_CXXFLAGS`
+
+HOST_CFLAGS=`echo \
+    $_WARNINGS_HOST_CFLAGS \
+    $_COMPILATION_HOST_CFLAGS \
+    $HOST_CFLAGS`
+
+HOST_CXXFLAGS=`echo \
+    $_WARNINGS_HOST_CXXFLAGS \
+    $_COMPILATION_HOST_CXXFLAGS \
+    $HOST_CXXFLAGS`
+
+AC_SUBST(MOZ_SYSTEM_PNG)
+
+AC_SUBST_LIST(MOZ_PNG_CFLAGS)
+AC_SUBST_LIST(MOZ_PNG_LIBS)
+
+HOST_CMFLAGS="-x objective-c -fobjc-exceptions"
+HOST_CMMFLAGS="-x objective-c++ -fobjc-exceptions"
+OS_COMPILE_CMFLAGS="-x objective-c -fobjc-exceptions"
+OS_COMPILE_CMMFLAGS="-x objective-c++ -fobjc-exceptions"
+if test "$MOZ_WIDGET_TOOLKIT" = uikit; then
+  OS_COMPILE_CMFLAGS="$OS_COMPILE_CMFLAGS -fobjc-abi-version=2 -fobjc-legacy-dispatch"
+  OS_COMPILE_CMMFLAGS="$OS_COMPILE_CMMFLAGS -fobjc-abi-version=2 -fobjc-legacy-dispatch"
+fi
+AC_SUBST(HOST_CMFLAGS)
+AC_SUBST(HOST_CMMFLAGS)
+AC_SUBST(OS_COMPILE_CMFLAGS)
+AC_SUBST(OS_COMPILE_CMMFLAGS)
+
+OS_CFLAGS="$CFLAGS"
+OS_CXXFLAGS="$CXXFLAGS"
+OS_CPPFLAGS="$CPPFLAGS"
+OS_COMPILE_CFLAGS="$COMPILE_CFLAGS"
+OS_COMPILE_CXXFLAGS="$COMPILE_CXXFLAGS"
+OS_LDFLAGS="$LDFLAGS"
+OS_LIBS="$LIBS"
+AC_SUBST_LIST(OS_CFLAGS)
+AC_SUBST_LIST(OS_CXXFLAGS)
+AC_SUBST_LIST(OS_CPPFLAGS)
+AC_SUBST_LIST(OS_COMPILE_CFLAGS)
+AC_SUBST_LIST(OS_COMPILE_CXXFLAGS)
+AC_SUBST_LIST(OS_LDFLAGS)
+AC_SUBST(OS_LIBS)
+
+AC_SUBST(HOST_CC)
+AC_SUBST(HOST_CXX)
+AC_SUBST_LIST(HOST_CFLAGS)
+AC_SUBST_LIST(HOST_CPPFLAGS)
+AC_SUBST_LIST(HOST_CXXFLAGS)
+AC_SUBST(HOST_LDFLAGS)
+AC_SUBST_LIST(HOST_OPTIMIZE_FLAGS)
+AC_SUBST(HOST_BIN_SUFFIX)
+
+AC_SUBST(TARGET_XPCOM_ABI)
+AC_SUBST(HAVE_TOOLCHAIN_SUPPORT_MSSSE3)
+AC_SUBST(HAVE_TOOLCHAIN_SUPPORT_MSSE4_1)
+AC_SUBST(HAVE_X86_AVX2)
+AC_SUBST(HAVE_ALTIVEC)
+
+AC_SUBST_LIST(DSO_CFLAGS)
+AC_SUBST_LIST(DSO_PIC_CFLAGS)
+AC_SUBST(DSO_LDOPTS)
+AC_SUBST(BIN_SUFFIX)
+AC_SUBST(USE_N32)
+AC_SUBST(WIN32_CONSOLE_EXE_LDFLAGS)
+AC_SUBST(WIN32_GUI_EXE_LDFLAGS)
+
+AC_SUBST(MOZ_DEVTOOLS)
+
+AC_SUBST(MOZ_PACKAGE_JSSHELL)
+
+AC_SUBST(DMG_TOOL)
+
+dnl Host JavaScript runtime, if any, to use during cross compiles.
+AC_SUBST(JS_BINARY)
+
+AC_SUBST(NSS_EXTRA_SYMBOLS_FILE)
+
+if test -n "$COMPILE_ENVIRONMENT"; then
+AC_CHECK_FUNCS(posix_fadvise posix_fallocate)
+
+dnl Check for missing components
+if test "$MOZ_X11"; then
+    dnl ====================================================
+    dnl = Check if X headers exist
+    dnl ====================================================
+    _SAVE_CFLAGS=$CFLAGS
+    CFLAGS="$CFLAGS $XCFLAGS"
+    AC_TRY_COMPILE([
+        #include <stdio.h>
+        #include <stdlib.h>
+        #include <X11/Xlib.h>
+        #include <X11/Intrinsic.h>
+        #include <X11/extensions/XShm.h>
+    ],
+    [
+        Display *dpy = 0;
+        if ((dpy = XOpenDisplay(NULL)) == NULL) {
+            fprintf(stderr, ": can't open %s\n", XDisplayName(NULL));
+            exit(1);
+        }
+    ], [],
+    [ AC_MSG_ERROR([Can't find X headers (install libxt-dev (Debian/Ubuntu), libXt-devel (Fedora), or xorg-x11-libXt-devel (SuSE)).]) ])
+    CFLAGS="$_SAVE_CFLAGS"
+
+    if test -n "$MISSING_X"; then
+        AC_MSG_ERROR([ Could not find the following X libraries: $MISSING_X ]);
+    fi
+
+fi # MOZ_X11
+
+fi # COMPILE_ENVIRONMENT
+
+dnl Set various defines and substitutions
+dnl ========================================================
+
+if test "$ACCESSIBILITY" -a "$MOZ_ENABLE_GTK" ; then
+    AC_DEFINE(MOZ_ACCESSIBILITY_ATK)
+    ATK_FULL_VERSION=`$PKG_CONFIG --modversion atk`
+    ATK_MAJOR_VERSION=`echo ${ATK_FULL_VERSION} | $AWK -F\. '{ print $1 }'`
+    ATK_MINOR_VERSION=`echo ${ATK_FULL_VERSION} | $AWK -F\. '{ print $2 }'`
+    ATK_REV_VERSION=`echo ${ATK_FULL_VERSION} | $AWK -F\. '{ print $3 }'`
+    AC_DEFINE_UNQUOTED(ATK_MAJOR_VERSION, $ATK_MAJOR_VERSION)
+    AC_DEFINE_UNQUOTED(ATK_MINOR_VERSION, $ATK_MINOR_VERSION)
+    AC_DEFINE_UNQUOTED(ATK_REV_VERSION, $ATK_REV_VERSION)
+fi
+
+AC_SUBST(MOZ_DEV_EDITION)
+if test -n "$MOZ_DEV_EDITION"; then
+    AC_DEFINE(MOZ_DEV_EDITION)
+fi
+
+if test "$MOZ_DEBUG" -o "$DEVELOPER_OPTIONS"; then
+    A11Y_LOG=1
+fi
+AC_SUBST(A11Y_LOG)
+if test -n "$A11Y_LOG"; then
+    AC_DEFINE(A11Y_LOG)
+fi
+
+dnl Spit out some output
+dnl ========================================================
+
+# Avoid using obsolete NSPR features
+AC_DEFINE(NO_NSPR_10_SUPPORT)
+
+MOZ_CREATE_CONFIG_STATUS()
+
+rm -fr confdefs* $ac_clean_files
diff --git a/security/sandbox/linux/broker/SandboxBrokerPolicyFactory.cpp b/security/sandbox/linux/broker/SandboxBrokerPolicyFactory.cpp
index 953d50cfed..d107f85db3 100644
--- a/security/sandbox/linux/broker/SandboxBrokerPolicyFactory.cpp
+++ b/security/sandbox/linux/broker/SandboxBrokerPolicyFactory.cpp
@@ -40,7 +40,9 @@
 #  include <glib.h>
 #  ifdef MOZ_WAYLAND
 #    include <gdk/gdk.h>
-#    include <gdk/gdkx.h>
+#    ifdef MOZ_X11
+#      include <gdk/gdkx.h>
+#    endif
 #  endif
 #endif
 
diff --git a/toolkit/components/remote/moz.build b/toolkit/components/remote/moz.build
index 235580d6b7..c068ec8933 100644
--- a/toolkit/components/remote/moz.build
+++ b/toolkit/components/remote/moz.build
@@ -13,10 +13,7 @@ SOURCES += [
 
 if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
     SOURCES += [
-        "nsGTKRemoteServer.cpp",
         "nsUnixRemoteServer.cpp",
-        "nsXRemoteClient.cpp",
-        "nsXRemoteServer.cpp",
         "RemoteUtils.cpp",
     ]
     if CONFIG["MOZ_ENABLE_DBUS"]:
@@ -31,6 +28,13 @@ if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
         ]
     CXXFLAGS += CONFIG["TK_CFLAGS"]
 
+if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk" and CONFIG['MOZ_X11']:
+    SOURCES += [
+        "nsGTKRemoteServer.cpp",
+        "nsXRemoteClient.cpp",
+        "nsXRemoteServer.cpp",
+    ]
+
 if CONFIG["MOZ_WIDGET_TOOLKIT"] == "windows":
     SOURCES += [
         "nsWinRemoteClient.cpp",
diff --git a/toolkit/components/remote/nsGTKRemoteServer.h b/toolkit/components/remote/nsGTKRemoteServer.h
index 767f2f54ad..276c98e74d 100644
--- a/toolkit/components/remote/nsGTKRemoteServer.h
+++ b/toolkit/components/remote/nsGTKRemoteServer.h
@@ -9,7 +9,6 @@
 #define __nsGTKRemoteServer_h__
 
 #include <gdk/gdk.h>
-#include <gdk/gdkx.h>
 #include <gtk/gtk.h>
 
 #include "nsRemoteServer.h"
diff --git a/toolkit/components/remote/nsRemoteService.cpp b/toolkit/components/remote/nsRemoteService.cpp
index 4a876c32b2..d1aba2f469 100644
--- a/toolkit/components/remote/nsRemoteService.cpp
+++ b/toolkit/components/remote/nsRemoteService.cpp
@@ -11,8 +11,12 @@
 #endif
 
 #ifdef MOZ_WIDGET_GTK
-#  include "nsGTKRemoteServer.h"
-#  include "nsXRemoteClient.h"
+#  include <gdk/gdk.h>
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#    include "nsGTKRemoteServer.h"
+#    include "nsXRemoteClient.h"
+#  endif
 #  ifdef MOZ_ENABLE_DBUS
 #    include "nsDBusRemoteServer.h"
 #    include "nsDBusRemoteClient.h"
@@ -103,16 +107,21 @@ RemoteResult nsRemoteService::StartClient(const char* aDesktopStartupID) {
   UniquePtr<nsRemoteClient> client;
 
 #ifdef MOZ_WIDGET_GTK
-  bool useX11Remote = GDK_IS_X11_DISPLAY(gdk_display_get_default());
+  bool useX11Remote = false;
+#  ifdef MOZ_X11
+  useX11Remote = GDK_IS_X11_DISPLAY(gdk_display_get_default());
+#  endif
 
 #  if defined(MOZ_ENABLE_DBUS)
   if (!useX11Remote || getenv(DBUS_REMOTE_ENV)) {
     client = MakeUnique<nsDBusRemoteClient>();
   }
 #  endif
+#  if defined(MOZ_X11)
   if (!client && useX11Remote) {
     client = MakeUnique<nsXRemoteClient>();
   }
+#  endif
 #elif defined(XP_WIN)
   client = MakeUnique<nsWinRemoteClient>();
 #elif defined(XP_DARWIN)
@@ -152,16 +161,21 @@ void nsRemoteService::StartupServer() {
   }
 
 #ifdef MOZ_WIDGET_GTK
-  bool useX11Remote = GDK_IS_X11_DISPLAY(gdk_display_get_default());
+  bool useX11Remote = false;
+#  ifdef MOZ_X11
+  useX11Remote = GDK_IS_X11_DISPLAY(gdk_display_get_default());
+#  endif
 
 #  if defined(MOZ_ENABLE_DBUS)
   if (!useX11Remote || getenv(DBUS_REMOTE_ENV)) {
     mRemoteServer = MakeUnique<nsDBusRemoteServer>();
   }
 #  endif
+#  ifdef MOZ_X11
   if (!mRemoteServer && useX11Remote) {
     mRemoteServer = MakeUnique<nsGTKRemoteServer>();
   }
+#  endif
 #elif defined(XP_WIN)
   mRemoteServer = MakeUnique<nsWinRemoteServer>();
 #elif defined(XP_DARWIN)
diff --git a/toolkit/moz.configure b/toolkit/moz.configure
index 5e74e1f3f4..28556f413f 100644
--- a/toolkit/moz.configure
+++ b/toolkit/moz.configure
@@ -313,11 +313,6 @@ set_define(toolkit_define, True)
 def toolkit_gtk(toolkit):
     return toolkit == "gtk"
 
-
-set_config("MOZ_X11", True, when=toolkit_gtk)
-set_define("MOZ_X11", True, when=toolkit_gtk)
-add_old_configure_assignment("MOZ_X11", True, when=toolkit_gtk)
-
 # Wayland support
 # ==============================================================
 wayland_headers = pkg_check_modules(
@@ -338,6 +333,20 @@ def wayland_headers(wayland, toolkit_gtk, artifacts):
 set_config("MOZ_WAYLAND", depends_if(wayland_headers)(lambda _: True))
 set_define("MOZ_WAYLAND", depends_if(wayland_headers)(lambda _: True))
 
+# X11 optional if wayland is enabled
+# ==============================================================
+
+x11_headers = pkg_check_modules(
+    "MOZ_X11",
+    "gtk+-x11-3.0 >= 3.14",
+    allow_missing=depends(full_toolkit)(lambda t: t == "cairo-gtk3-wayland"),
+    when=toolkit_gtk,
+)
+
+set_config("MOZ_X11", depends_if(x11_headers)(lambda _: True))
+set_define("MOZ_X11", depends_if(x11_headers)(lambda _: True))
+add_old_configure_assignment("MOZ_X11", depends_if(x11_headers)(lambda _: True))
+
 # GL Provider
 # ==============================================================
 option("--with-gl-provider", nargs=1, help="Set GL provider backend type")
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
index df53d2f835..06a166e50f 100644
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -4285,11 +4285,13 @@ int XREMain::XRE_mainStartup(bool* aExitFlag) {
       gdk_display_manager_set_default_display(gdk_display_manager_get(),
                                               mGdkDisplay);
       if (saveDisplayArg) {
+#  ifdef MOZ_X11
         if (GDK_IS_X11_DISPLAY(mGdkDisplay)) {
           SaveWordToEnv("DISPLAY", nsDependentCString(display_name));
         }
+#  endif
 #  ifdef MOZ_WAYLAND
-        else if (!GDK_IS_X11_DISPLAY(mGdkDisplay)) {
+        if (GDK_IS_WAYLAND_DISPLAY(mGdkDisplay)) {
           SaveWordToEnv("WAYLAND_DISPLAY", nsDependentCString(display_name));
         }
 #  endif
diff --git a/toolkit/xre/nsAppRunner.cpp.orig b/toolkit/xre/nsAppRunner.cpp.orig
new file mode 100644
index 0000000000..a34322c5bf
--- /dev/null
+++ b/toolkit/xre/nsAppRunner.cpp.orig
@@ -0,0 +1,5598 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/dom/ContentParent.h"
+#include "mozilla/dom/ContentChild.h"
+#include "mozilla/ipc/GeckoChildProcessHost.h"
+
+#include "mozilla/AppShutdown.h"
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/Assertions.h"
+#include "mozilla/Attributes.h"
+#include "mozilla/Components.h"
+#include "mozilla/FilePreferences.h"
+#include "mozilla/ChaosMode.h"
+#include "mozilla/CmdLineAndEnvUtils.h"
+#include "mozilla/IOInterposer.h"
+#include "mozilla/Likely.h"
+#include "mozilla/MemoryChecking.h"
+#include "mozilla/Poison.h"
+#include "mozilla/Preferences.h"
+#include "mozilla/Printf.h"
+#include "mozilla/ResultExtensions.h"
+#include "mozilla/ScopeExit.h"
+#include "mozilla/Services.h"
+#include "mozilla/StaticPrefs_fission.h"
+#include "mozilla/Telemetry.h"
+#include "mozilla/Utf8.h"
+#include "mozilla/intl/LocaleService.h"
+#include "mozilla/JSONWriter.h"
+#include "BaseProfiler.h"
+
+#include "nsAppRunner.h"
+#include "mozilla/XREAppData.h"
+#include "mozilla/Bootstrap.h"
+#if defined(MOZ_UPDATER) && !defined(MOZ_WIDGET_ANDROID)
+#  include "nsUpdateDriver.h"
+#endif
+#include "ProfileReset.h"
+
+#ifdef MOZ_INSTRUMENT_EVENT_LOOP
+#  include "EventTracer.h"
+#endif
+
+#ifdef XP_MACOSX
+#  include "nsVersionComparator.h"
+#  include "MacLaunchHelper.h"
+#  include "MacApplicationDelegate.h"
+#  include "MacAutoreleasePool.h"
+// these are needed for sysctl
+#  include <sys/types.h>
+#  include <sys/sysctl.h>
+#endif
+
+#include "prnetdb.h"
+#include "prprf.h"
+#include "prproces.h"
+#include "prenv.h"
+#include "prtime.h"
+
+#include "nsIAppStartup.h"
+#include "nsAppStartupNotifier.h"
+#include "nsIMutableArray.h"
+#include "nsCommandLine.h"
+#include "nsIComponentRegistrar.h"
+#include "nsIDialogParamBlock.h"
+#include "mozilla/ModuleUtils.h"
+#include "nsIIOService.h"
+#include "nsIObserverService.h"
+#include "nsINativeAppSupport.h"
+#include "nsIPlatformInfo.h"
+#include "nsIProcess.h"
+#include "nsIProfileUnlocker.h"
+#include "nsIPromptService.h"
+#include "nsIPropertyBag2.h"
+#include "nsIServiceManager.h"
+#include "nsIStringBundle.h"
+#include "nsISupportsPrimitives.h"
+#include "nsIToolkitProfile.h"
+#include "nsIUUIDGenerator.h"
+#include "nsToolkitProfileService.h"
+#include "nsIURI.h"
+#include "nsIURL.h"
+#include "nsIWindowCreator.h"
+#include "nsIWindowWatcher.h"
+#include "nsIXULAppInfo.h"
+#include "nsIXULRuntime.h"
+#include "nsPIDOMWindow.h"
+#include "nsIWidget.h"
+#include "nsAppShellCID.h"
+#include "mozilla/dom/quota/QuotaManager.h"
+#include "mozilla/scache/StartupCache.h"
+#include "gfxPlatform.h"
+
+#include "mozilla/Unused.h"
+
+#ifdef XP_WIN
+#  include "nsIWinAppHelper.h"
+#  include <windows.h>
+#  include <intrin.h>
+#  include <math.h>
+#  include "cairo/cairo-features.h"
+#  include "mozilla/PreXULSkeletonUI.h"
+#  include "mozilla/DllPrefetchExperimentRegistryInfo.h"
+#  include "mozilla/WindowsDllBlocklist.h"
+#  include "mozilla/WindowsProcessMitigations.h"
+#  include "mozilla/WinHeaderOnlyUtils.h"
+#  include "mozilla/mscom/ProcessRuntime.h"
+#  if defined(MOZ_GECKO_PROFILER)
+#    include "mozilla/mscom/ProfilerMarkers.h"
+#  endif  // defined(MOZ_GECKO_PROFILER)
+#  include "mozilla/widget/AudioSession.h"
+#  include "WinTokenUtils.h"
+
+#  if defined(MOZ_LAUNCHER_PROCESS)
+#    include "mozilla/LauncherRegistryInfo.h"
+#  endif
+
+#  if defined(MOZ_DEFAULT_BROWSER_AGENT)
+#    include "nsIWindowsRegKey.h"
+#  endif
+
+#  ifndef PROCESS_DEP_ENABLE
+#    define PROCESS_DEP_ENABLE 0x1
+#  endif
+#endif
+
+#if defined(MOZ_SANDBOX)
+#  include "mozilla/SandboxSettings.h"
+#  if (defined(XP_WIN) || defined(XP_MACOSX))
+#    include "nsIUUIDGenerator.h"
+#  endif
+#endif
+
+#ifdef ACCESSIBILITY
+#  include "nsAccessibilityService.h"
+#  if defined(XP_WIN)
+#    include "mozilla/a11y/Compatibility.h"
+#    include "mozilla/a11y/Platform.h"
+#  endif
+#endif
+
+#include "nsCRT.h"
+#include "nsCOMPtr.h"
+#include "nsDirectoryServiceDefs.h"
+#include "nsDirectoryServiceUtils.h"
+#include "nsEmbedCID.h"
+#include "nsNetUtil.h"
+#include "nsReadableUtils.h"
+#include "nsXPCOM.h"
+#include "nsXPCOMCIDInternal.h"
+#include "nsString.h"
+#include "nsPrintfCString.h"
+#include "nsVersionComparator.h"
+
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsXULAppAPI.h"
+#include "nsXREDirProvider.h"
+
+#include "nsINIParser.h"
+#include "mozilla/Omnijar.h"
+#include "mozilla/StartupTimeline.h"
+#include "mozilla/LateWriteChecks.h"
+
+#include <stdlib.h>
+#include <locale.h>
+
+#ifdef XP_UNIX
+#  include <errno.h>
+#  include <pwd.h>
+#  include <string.h>
+#  include <sys/resource.h>
+#  include <sys/stat.h>
+#  include <unistd.h>
+#endif
+
+#ifdef XP_WIN
+#  include <process.h>
+#  include <shlobj.h>
+#  include "mozilla/WinDllServices.h"
+#  include "nsThreadUtils.h"
+#  include <comdef.h>
+#  include <wbemidl.h>
+#  include "WinUtils.h"
+#endif
+
+#ifdef XP_MACOSX
+#  include "nsILocalFileMac.h"
+#  include "nsCommandLineServiceMac.h"
+#endif
+
+// for X remote support
+#if defined(MOZ_HAS_REMOTE)
+#  include "nsRemoteService.h"
+#endif
+
+#if defined(DEBUG) && defined(XP_WIN)
+#  include <malloc.h>
+#endif
+
+#if defined(XP_MACOSX)
+#  include <Carbon/Carbon.h>
+#endif
+
+#ifdef DEBUG
+#  include "mozilla/Logging.h"
+#endif
+
+#ifdef MOZ_JPROF
+#  include "jprof.h"
+#endif
+
+#include "nsExceptionHandler.h"
+#include "nsICrashReporter.h"
+#define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
+#include "nsIPrefService.h"
+#include "nsIMemoryInfoDumper.h"
+#if defined(XP_LINUX) && !defined(ANDROID)
+#  include "mozilla/widget/LSBUtils.h"
+#endif
+
+#include "base/command_line.h"
+#include "GTestRunner.h"
+
+#ifdef MOZ_WIDGET_ANDROID
+#  include "mozilla/java/GeckoAppShellWrappers.h"
+#endif
+
+#if defined(MOZ_SANDBOX)
+#  if defined(XP_LINUX) && !defined(ANDROID)
+#    include "mozilla/SandboxInfo.h"
+#  elif defined(XP_WIN)
+#    include "sandboxBroker.h"
+#    include "sandboxPermissions.h"
+#  endif
+#endif
+
+#ifdef MOZ_CODE_COVERAGE
+#  include "mozilla/CodeCoverageHandler.h"
+#endif
+
+#include "mozilla/mozalloc_oom.h"
+#include "SafeMode.h"
+
+#ifdef MOZ_THUNDERBIRD
+#  include "nsIPK11TokenDB.h"
+#  include "nsIPK11Token.h"
+#endif
+
+extern uint32_t gRestartMode;
+extern void InstallSignalHandlers(const char* ProgramName);
+
+#define FILE_COMPATIBILITY_INFO "compatibility.ini"_ns
+#define FILE_INVALIDATE_CACHES ".purgecaches"_ns
+#define FILE_STARTUP_INCOMPLETE u".startup-incomplete"_ns
+
+#if defined(MOZ_BLOCK_PROFILE_DOWNGRADE) || defined(MOZ_LAUNCHER_PROCESS) || \
+    defined(MOZ_DEFAULT_BROWSER_AGENT)
+static const char kPrefHealthReportUploadEnabled[] =
+    "datareporting.healthreport.uploadEnabled";
+#endif  // defined(MOZ_BLOCK_PROFILE_DOWNGRADE) || defined(MOZ_LAUNCHER_PROCESS)
+        // || defined(MOZ_DEFAULT_BROWSER_AGENT)
+#if defined(MOZ_DEFAULT_BROWSER_AGENT)
+static const char kPrefDefaultAgentEnabled[] = "default-browser-agent.enabled";
+
+static const char kPrefServicesSettingsServer[] = "services.settings.server";
+static const char kPrefSecurityContentSignatureRootHash[] =
+    "security.content.signature.root_hash";
+#endif  // defined(MOZ_DEFAULT_BROWSER_AGENT)
+
+#if defined(XP_WIN)
+static const char kPrefThemeId[] = "extensions.activeThemeID";
+static const char kPrefBrowserStartupBlankWindow[] =
+    "browser.startup.blankWindow";
+static const char kPrefPreXulSkeletonUI[] = "browser.startup.preXulSkeletonUI";
+static const char kPrefDrawTabsInTitlebar[] = "browser.tabs.drawInTitlebar";
+#endif  // defined(XP_WIN)
+
+int gArgc;
+char** gArgv;
+
+static const char gToolkitVersion[] = MOZ_STRINGIFY(GRE_MILESTONE);
+// The gToolkitBuildID global is defined to MOZ_BUILDID via gen_buildid.py
+// in toolkit/library. See related comment in toolkit/library/moz.build.
+extern const char gToolkitBuildID[];
+
+static nsIProfileLock* gProfileLock;
+
+int gRestartArgc;
+char** gRestartArgv;
+
+// If gRestartedByOS is set, we were automatically restarted by the OS.
+bool gRestartedByOS = false;
+
+bool gIsGtest = false;
+
+nsString gAbsoluteArgv0Path;
+
+#if defined(MOZ_WIDGET_GTK)
+#  include <glib.h>
+#  if defined(DEBUG) || defined(NS_BUILD_REFCNT_LOGGING)
+#    define CLEANUP_MEMORY 1
+#    define PANGO_ENABLE_BACKEND
+#    include <pango/pangofc-fontmap.h>
+#  endif
+#  include <gtk/gtk.h>
+#  ifdef MOZ_WAYLAND
+#    include <gdk/gdkwayland.h>
+#    include "mozilla/widget/nsWaylandDisplay.h"
+#  endif
+#  ifdef MOZ_X11
+#    include <gdk/gdkx.h>
+#  endif /* MOZ_X11 */
+#  include <fontconfig/fontconfig.h>
+#endif
+#include "BinaryPath.h"
+
+#ifdef MOZ_LINKER
+extern "C" MFBT_API bool IsSignalHandlingBroken();
+#endif
+
+#ifdef FUZZING
+#  include "FuzzerRunner.h"
+
+namespace mozilla {
+FuzzerRunner* fuzzerRunner = 0;
+}  // namespace mozilla
+
+#  ifdef LIBFUZZER
+void XRE_LibFuzzerSetDriver(LibFuzzerDriver aDriver) {
+  mozilla::fuzzerRunner->setParams(aDriver);
+}
+#  endif
+#endif  // FUZZING
+
+// Undo X11/X.h's definition of None
+#undef None
+
+namespace mozilla {
+int (*RunGTest)(int*, char**) = 0;
+
+bool RunningGTest() { return RunGTest; }
+}  // namespace mozilla
+
+using namespace mozilla;
+using namespace mozilla::widget;
+using namespace mozilla::startup;
+using mozilla::Unused;
+using mozilla::dom::ContentChild;
+using mozilla::dom::ContentParent;
+using mozilla::dom::quota::QuotaManager;
+using mozilla::intl::LocaleService;
+using mozilla::scache::StartupCache;
+
+// Save the given word to the specified environment variable.
+static void MOZ_NEVER_INLINE SaveWordToEnv(const char* name,
+                                           const nsACString& word) {
+  char* expr =
+      Smprintf("%s=%s", name, PromiseFlatCString(word).get()).release();
+  if (expr) PR_SetEnv(expr);
+  // We intentionally leak |expr| here since it is required by PR_SetEnv.
+}
+
+// Save the path of the given file to the specified environment variable.
+static void SaveFileToEnv(const char* name, nsIFile* file) {
+#ifdef XP_WIN
+  nsAutoString path;
+  file->GetPath(path);
+  SetEnvironmentVariableW(NS_ConvertASCIItoUTF16(name).get(), path.get());
+#else
+  nsAutoCString path;
+  file->GetNativePath(path);
+  SaveWordToEnv(name, path);
+#endif
+}
+
+static bool gIsExpectedExit = false;
+
+void MozExpectedExit() { gIsExpectedExit = true; }
+
+/**
+ * Runs atexit() to catch unexpected exit from 3rd party libraries like the
+ * Intel graphics driver calling exit in an error condition. When they
+ * call exit() to report an error we won't shutdown correctly and wont catch
+ * the issue with our crash reporter.
+ */
+static void UnexpectedExit() {
+  if (!gIsExpectedExit) {
+    gIsExpectedExit = true;  // Don't risk re-entrency issues when crashing.
+    MOZ_CRASH("Exit called by third party code.");
+  }
+}
+
+/**
+ * Output a string to the user.  This method is really only meant to be used to
+ * output last-ditch error messages designed for developers NOT END USERS.
+ *
+ * @param isError
+ *        Pass true to indicate severe errors.
+ * @param fmt
+ *        printf-style format string followed by arguments.
+ */
+static MOZ_FORMAT_PRINTF(2, 3) void Output(bool isError, const char* fmt, ...) {
+  va_list ap;
+  va_start(ap, fmt);
+
+#if defined(XP_WIN) && !MOZ_WINCONSOLE
+  SmprintfPointer msg = mozilla::Vsmprintf(fmt, ap);
+  if (msg) {
+    UINT flags = MB_OK;
+    if (isError)
+      flags |= MB_ICONERROR;
+    else
+      flags |= MB_ICONINFORMATION;
+
+    wchar_t wide_msg[1024];
+    MultiByteToWideChar(CP_ACP, 0, msg.get(), -1, wide_msg,
+                        sizeof(wide_msg) / sizeof(wchar_t));
+
+    MessageBoxW(nullptr, wide_msg, L"XULRunner", flags);
+  }
+#else
+  vfprintf(stderr, fmt, ap);
+#endif
+
+  va_end(ap);
+}
+
+/**
+ * Check for a commandline flag. If the flag takes a parameter, the
+ * parameter is returned in aParam. Flags may be in the form -arg or
+ * --arg (or /arg on win32).
+ *
+ * @param aArg the parameter to check. Must be lowercase.
+ * @param aParam if non-null, the -arg <data> will be stored in this pointer.
+ *        This is *not* allocated, but rather a pointer to the argv data.
+ * @param aFlags flags @see CheckArgFlag
+ */
+static ArgResult CheckArg(const char* aArg, const char** aParam = nullptr,
+                          CheckArgFlag aFlags = CheckArgFlag::RemoveArg) {
+  MOZ_ASSERT(gArgv, "gArgv must be initialized before CheckArg()");
+  return CheckArg(gArgc, gArgv, aArg, aParam, aFlags);
+}
+
+/**
+ * Check for a commandline flag. Ignore data that's passed in with the flag.
+ * Flags may be in the form -arg or --arg (or /arg on win32).
+ * Will not remove flag if found.
+ *
+ * @param aArg the parameter to check. Must be lowercase.
+ */
+static ArgResult CheckArgExists(const char* aArg) {
+  return CheckArg(aArg, nullptr, CheckArgFlag::None);
+}
+
+bool gSafeMode = false;
+bool gFxREmbedded = false;
+
+// Fission enablement for the current session is determined once, at startup,
+// and then remains the same for the duration of the session.
+//
+// The following factors determine whether or not Fission is enabled for a
+// session, in order of precedence:
+//
+// - Safe mode: In safe mode, Fission is never enabled.
+//
+// - The MOZ_FORCE_ENABLE_FISSION environment variable: If set to any value,
+//   Fission will be enabled.
+//
+// - The 'fission.autostart' preference, if it has been configured by the user.
+static const char kPrefFissionAutostart[] = "fission.autostart";
+//
+// - The fission experiment enrollment status set during the previous run, which
+//   is controlled by the following preferences:
+//
+// The current enrollment status as controlled by Normandy. This value is only
+// stored in the default preference branch, and is not persisted across
+// sessions by the preference service. It therefore isn't available early
+// enough at startup, and needs to be synced to a preference in the user
+// branch which is persisted across sessions.
+static const char kPrefFissionExperimentEnrollmentStatus[] =
+    "fission.experiment.enrollmentStatus";
+//
+// The enrollment status to be used at browser startup. This automatically
+// synced from the above enrollmentStatus preference whenever the latter is
+// changed. It can have any of the values defined in the
+// `nsIXULRuntime_ExperimentStatus` enum. Meanings are documented in
+// the declaration of `nsIXULRuntime.fissionExperimentStatus`
+static const char kPrefFissionExperimentStartupEnrollmentStatus[] =
+    "fission.experiment.startupEnrollmentStatus";
+
+// The computed FissionAutostart value for the session, read by content
+// processes to initialize gFissionAutostart.
+//
+// This pref is locked, and only configured on the default branch, so should
+// never be persisted in a profile.
+static const char kPrefFissionAutostartSession[] = "fission.autostart.session";
+
+static nsIXULRuntime::ExperimentStatus gFissionExperimentStatus =
+    nsIXULRuntime::eExperimentStatusUnenrolled;
+static bool gFissionAutostart = false;
+static bool gFissionAutostartInitialized = false;
+static nsIXULRuntime::FissionDecisionStatus gFissionDecisionStatus;
+
+enum E10sStatus {
+  kE10sEnabledByDefault,
+  kE10sDisabledByUser,
+  kE10sForceDisabled,
+};
+
+static bool gBrowserTabsRemoteAutostart = false;
+static E10sStatus gBrowserTabsRemoteStatus;
+static bool gBrowserTabsRemoteAutostartInitialized = false;
+
+namespace mozilla {
+
+bool BrowserTabsRemoteAutostart() {
+  if (gBrowserTabsRemoteAutostartInitialized) {
+    return gBrowserTabsRemoteAutostart;
+  }
+  gBrowserTabsRemoteAutostartInitialized = true;
+
+  // If we're not in the parent process, we are running E10s.
+  if (!XRE_IsParentProcess()) {
+    gBrowserTabsRemoteAutostart = true;
+    return gBrowserTabsRemoteAutostart;
+  }
+
+#if defined(MOZILLA_OFFICIAL) && MOZ_BUILD_APP_IS_BROWSER
+  bool allowSingleProcessOutsideAutomation = false;
+#else
+  bool allowSingleProcessOutsideAutomation = true;
+#endif
+
+  E10sStatus status = kE10sEnabledByDefault;
+  // We use "are non-local connections disabled" as a proxy for
+  // "are we running some kind of automated test". It would be nicer to use
+  // xpc::IsInAutomation(), but that depends on some prefs being set, which
+  // they are not in (at least) gtests (where we can't) and xpcshell.
+  // Long-term, hopefully we can make tests switch to environment variables
+  // to disable e10s and then we can get rid of this.
+  if (allowSingleProcessOutsideAutomation ||
+      xpc::AreNonLocalConnectionsDisabled()) {
+    bool optInPref =
+        Preferences::GetBool("browser.tabs.remote.autostart", true);
+
+    if (optInPref) {
+      gBrowserTabsRemoteAutostart = true;
+    } else {
+      status = kE10sDisabledByUser;
+    }
+  } else {
+    gBrowserTabsRemoteAutostart = true;
+  }
+
+  // Uber override pref for emergency blocking
+  if (gBrowserTabsRemoteAutostart) {
+    const char* forceDisable = PR_GetEnv("MOZ_FORCE_DISABLE_E10S");
+#if defined(MOZ_WIDGET_ANDROID)
+    // We need this for xpcshell on Android
+    if (forceDisable && *forceDisable) {
+#else
+    // The environment variable must match the application version to apply.
+    if (forceDisable && gAppData && !strcmp(forceDisable, gAppData->version)) {
+#endif
+      gBrowserTabsRemoteAutostart = false;
+      status = kE10sForceDisabled;
+    }
+  }
+
+  gBrowserTabsRemoteStatus = status;
+
+  return gBrowserTabsRemoteAutostart;
+}
+
+}  // namespace mozilla
+
+static bool FissionExperimentEnrolled() {
+  MOZ_ASSERT(XRE_IsParentProcess());
+  return gFissionExperimentStatus == nsIXULRuntime::eExperimentStatusControl ||
+         gFissionExperimentStatus == nsIXULRuntime::eExperimentStatusTreatment;
+}
+
+static void FissionExperimentDisqualify() {
+  MOZ_ASSERT(XRE_IsParentProcess());
+  // Setting this pref's user value will be detected by Normandy, causing the
+  // client to be unenrolled from the experiment.
+  Preferences::SetUint(kPrefFissionExperimentEnrollmentStatus,
+                       nsIXULRuntime::eExperimentStatusDisqualified);
+}
+
+static void OnFissionEnrollmentStatusChanged(const char* aPref, void* aData) {
+  Preferences::SetUint(
+      kPrefFissionExperimentStartupEnrollmentStatus,
+      Preferences::GetUint(kPrefFissionExperimentEnrollmentStatus,
+                           nsIXULRuntime::eExperimentStatusUnenrolled));
+}
+
+namespace {
+// This observer is notified during `profile-before-change`, and ensures that
+// the experiment enrollment status is synced over before the browser shuts
+// down, even if it was not modified since FissionAutostart was initialized.
+class FissionEnrollmentStatusShutdownObserver final : public nsIObserver {
+ public:
+  NS_DECL_ISUPPORTS
+
+  NS_IMETHOD Observe(nsISupports* aSubject, const char* aTopic,
+                     const char16_t* aData) override {
+    MOZ_ASSERT(!strcmp("profile-before-change", aTopic));
+    OnFissionEnrollmentStatusChanged(kPrefFissionExperimentEnrollmentStatus,
+                                     nullptr);
+    return NS_OK;
+  }
+
+ private:
+  ~FissionEnrollmentStatusShutdownObserver() = default;
+};
+NS_IMPL_ISUPPORTS(FissionEnrollmentStatusShutdownObserver, nsIObserver)
+}  // namespace
+
+static void OnFissionAutostartChanged(const char* aPref, void* aData) {
+  MOZ_ASSERT(FissionExperimentEnrolled());
+  if (Preferences::HasUserValue(kPrefFissionAutostart)) {
+    FissionExperimentDisqualify();
+  }
+}
+
+static void EnsureFissionAutostartInitialized() {
+  if (gFissionAutostartInitialized) {
+    return;
+  }
+  gFissionAutostartInitialized = true;
+
+  if (!XRE_IsParentProcess()) {
+    // This pref is configured for the current session by the parent process.
+    gFissionAutostart = Preferences::GetBool(kPrefFissionAutostartSession,
+                                             false, PrefValueKind::Default);
+    return;
+  }
+
+  // Initialize the fission experiment, configuring fission.autostart's
+  // default, before checking other overrides. This allows opting-out of a
+  // fission experiment through about:preferences or about:config from a
+  // safemode session.
+  uint32_t experimentRaw =
+      Preferences::GetUint(kPrefFissionExperimentStartupEnrollmentStatus,
+                           nsIXULRuntime::eExperimentStatusUnenrolled);
+  gFissionExperimentStatus =
+      experimentRaw < nsIXULRuntime::eExperimentStatusCount
+          ? nsIXULRuntime::ExperimentStatus(experimentRaw)
+          : nsIXULRuntime::eExperimentStatusDisqualified;
+
+  // Watch the experiment enrollment status pref to detect experiment
+  // disqualification, and ensure it is propagated for the next restart.
+  Preferences::RegisterCallback(&OnFissionEnrollmentStatusChanged,
+                                kPrefFissionExperimentEnrollmentStatus);
+  if (nsCOMPtr<nsIObserverService> observerService =
+          mozilla::services::GetObserverService()) {
+    nsCOMPtr<nsIObserver> shutdownObserver =
+        new FissionEnrollmentStatusShutdownObserver();
+    observerService->AddObserver(shutdownObserver, "profile-before-change",
+                                 false);
+  }
+
+  // If the user has overridden an active experiment by setting a user value for
+  // "fission.autostart", disqualify the user from the experiment.
+  if (Preferences::HasUserValue(kPrefFissionAutostart) &&
+      FissionExperimentEnrolled()) {
+    FissionExperimentDisqualify();
+    gFissionExperimentStatus = nsIXULRuntime::eExperimentStatusDisqualified;
+  }
+
+  // Configure the default branch for "fission.autostart" based on experiment
+  // enrollment status.
+  if (FissionExperimentEnrolled()) {
+    bool isTreatment =
+        gFissionExperimentStatus == nsIXULRuntime::eExperimentStatusTreatment;
+    Preferences::SetBool(kPrefFissionAutostart, isTreatment,
+                         PrefValueKind::Default);
+  }
+
+  if (!BrowserTabsRemoteAutostart()) {
+    gFissionAutostart = false;
+    if (gBrowserTabsRemoteStatus == kE10sForceDisabled) {
+      gFissionDecisionStatus = nsIXULRuntime::eFissionDisabledByE10sEnv;
+    } else {
+      gFissionDecisionStatus = nsIXULRuntime::eFissionDisabledByE10sOther;
+    }
+  } else if (gSafeMode) {
+    gFissionAutostart = false;
+    gFissionDecisionStatus = nsIXULRuntime::eFissionDisabledBySafeMode;
+  } else if (EnvHasValue("MOZ_FORCE_ENABLE_FISSION")) {
+    gFissionAutostart = true;
+    gFissionDecisionStatus = nsIXULRuntime::eFissionEnabledByEnv;
+  } else {
+    // NOTE: This will take into account changes to the default due to
+    // `InitializeFissionExperimentStatus`.
+    gFissionAutostart = Preferences::GetBool(kPrefFissionAutostart, false);
+    if (gFissionExperimentStatus == nsIXULRuntime::eExperimentStatusControl) {
+      gFissionDecisionStatus = nsIXULRuntime::eFissionExperimentControl;
+    } else if (gFissionExperimentStatus ==
+               nsIXULRuntime::eExperimentStatusTreatment) {
+      gFissionDecisionStatus = nsIXULRuntime::eFissionExperimentTreatment;
+    } else if (Preferences::HasUserValue(kPrefFissionAutostart)) {
+      gFissionDecisionStatus = gFissionAutostart
+                                   ? nsIXULRuntime::eFissionEnabledByUserPref
+                                   : nsIXULRuntime::eFissionDisabledByUserPref;
+    } else {
+      gFissionDecisionStatus = gFissionAutostart
+                                   ? nsIXULRuntime::eFissionEnabledByDefault
+                                   : nsIXULRuntime::eFissionDisabledByDefault;
+    }
+  }
+
+  // Content processes cannot run the same logic as we're running in the parent
+  // process, as the current value of various preferences may have changed
+  // between launches. Instead, the content process will read the default branch
+  // of the locked `fission.autostart.session` preference to determine the value
+  // determined by this method.
+  Preferences::Unlock(kPrefFissionAutostartSession);
+  Preferences::ClearUser(kPrefFissionAutostartSession);
+  Preferences::SetBool(kPrefFissionAutostartSession, gFissionAutostart,
+                       PrefValueKind::Default);
+  Preferences::Lock(kPrefFissionAutostartSession);
+
+  // If we're actively enrolled in the fission experiment, disqualify the user
+  // from the experiment if the fission pref is modified.
+  if (FissionExperimentEnrolled()) {
+    Preferences::RegisterCallback(&OnFissionAutostartChanged,
+                                  kPrefFissionAutostart);
+  }
+}
+
+namespace mozilla {
+
+bool FissionAutostart() {
+  EnsureFissionAutostartInitialized();
+  return gFissionAutostart;
+}
+
+bool SessionHistoryInParent() {
+  return FissionAutostart() ||
+         StaticPrefs::
+             fission_sessionHistoryInParent_AtStartup_DoNotUseDirectly();
+}
+
+}  // namespace mozilla
+
+/**
+ * The nsXULAppInfo object implements nsIFactory so that it can be its own
+ * singleton.
+ */
+class nsXULAppInfo : public nsIXULAppInfo,
+#ifdef XP_WIN
+                     public nsIWinAppHelper,
+#endif
+                     public nsICrashReporter,
+                     public nsIFinishDumpingCallback,
+                     public nsIXULRuntime
+
+{
+ public:
+  constexpr nsXULAppInfo() = default;
+  NS_DECL_ISUPPORTS_INHERITED
+  NS_DECL_NSIPLATFORMINFO
+  NS_DECL_NSIXULAPPINFO
+  NS_DECL_NSIXULRUNTIME
+  NS_DECL_NSICRASHREPORTER
+  NS_DECL_NSIFINISHDUMPINGCALLBACK
+#ifdef XP_WIN
+  NS_DECL_NSIWINAPPHELPER
+#endif
+};
+
+NS_INTERFACE_MAP_BEGIN(nsXULAppInfo)
+  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXULRuntime)
+  NS_INTERFACE_MAP_ENTRY(nsIXULRuntime)
+#ifdef XP_WIN
+  NS_INTERFACE_MAP_ENTRY(nsIWinAppHelper)
+#endif
+  NS_INTERFACE_MAP_ENTRY(nsICrashReporter)
+  NS_INTERFACE_MAP_ENTRY(nsIFinishDumpingCallback)
+  NS_INTERFACE_MAP_ENTRY(nsIPlatformInfo)
+  NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIXULAppInfo,
+                                     gAppData || XRE_IsContentProcess())
+NS_INTERFACE_MAP_END
+
+NS_IMETHODIMP_(MozExternalRefCountType)
+nsXULAppInfo::AddRef() { return 1; }
+
+NS_IMETHODIMP_(MozExternalRefCountType)
+nsXULAppInfo::Release() { return 1; }
+
+NS_IMETHODIMP
+nsXULAppInfo::GetVendor(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    aResult = cc->GetAppInfo().vendor;
+    return NS_OK;
+  }
+  aResult.Assign(gAppData->vendor);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetName(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    aResult = cc->GetAppInfo().name;
+    return NS_OK;
+  }
+
+#ifdef MOZ_WIDGET_ANDROID
+  nsCString name = java::GeckoAppShell::GetAppName()->ToCString();
+  aResult.Assign(std::move(name));
+#else
+  aResult.Assign(gAppData->name);
+#endif
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetID(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    aResult = cc->GetAppInfo().ID;
+    return NS_OK;
+  }
+  aResult.Assign(gAppData->ID);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetVersion(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    aResult = cc->GetAppInfo().version;
+    return NS_OK;
+  }
+  aResult.Assign(gAppData->version);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetPlatformVersion(nsACString& aResult) {
+  aResult.Assign(gToolkitVersion);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetAppBuildID(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    aResult = cc->GetAppInfo().buildID;
+    return NS_OK;
+  }
+  aResult.Assign(gAppData->buildID);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetPlatformBuildID(nsACString& aResult) {
+  aResult.Assign(gToolkitBuildID);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetUAName(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    aResult = cc->GetAppInfo().UAName;
+    return NS_OK;
+  }
+  aResult.Assign(gAppData->UAName);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetSourceURL(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    aResult = cc->GetAppInfo().sourceURL;
+    return NS_OK;
+  }
+  aResult.Assign(gAppData->sourceURL);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetUpdateURL(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    aResult = cc->GetAppInfo().updateURL;
+    return NS_OK;
+  }
+  aResult.Assign(gAppData->updateURL);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetLogConsoleErrors(bool* aResult) {
+  *aResult = gLogConsoleErrors;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::SetLogConsoleErrors(bool aValue) {
+  gLogConsoleErrors = aValue;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetInSafeMode(bool* aResult) {
+  *aResult = gSafeMode;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetOS(nsACString& aResult) {
+  aResult.AssignLiteral(OS_TARGET);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetXPCOMABI(nsACString& aResult) {
+#ifdef TARGET_XPCOM_ABI
+  aResult.AssignLiteral(TARGET_XPCOM_ABI);
+  return NS_OK;
+#else
+  return NS_ERROR_NOT_AVAILABLE;
+#endif
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetWidgetToolkit(nsACString& aResult) {
+  aResult.AssignLiteral(MOZ_WIDGET_TOOLKIT);
+  return NS_OK;
+}
+
+// Ensure that the GeckoProcessType enum, defined in xpcom/build/nsXULAppAPI.h,
+// is synchronized with the const unsigned longs defined in
+// xpcom/system/nsIXULRuntime.idl.
+#define SYNC_ENUMS(a, b)                                                   \
+  static_assert(nsIXULRuntime::PROCESS_TYPE_##a ==                         \
+                    static_cast<int>(GeckoProcessType_##b),                \
+                "GeckoProcessType in nsXULAppAPI.h not synchronized with " \
+                "nsIXULRuntime.idl");
+
+SYNC_ENUMS(DEFAULT, Default)
+SYNC_ENUMS(PLUGIN, Plugin)
+SYNC_ENUMS(CONTENT, Content)
+SYNC_ENUMS(IPDLUNITTEST, IPDLUnitTest)
+SYNC_ENUMS(GMPLUGIN, GMPlugin)
+SYNC_ENUMS(GPU, GPU)
+SYNC_ENUMS(VR, VR)
+SYNC_ENUMS(RDD, RDD)
+SYNC_ENUMS(SOCKET, Socket)
+SYNC_ENUMS(SANDBOX_BROKER, RemoteSandboxBroker)
+SYNC_ENUMS(FORKSERVER, ForkServer)
+
+// .. and ensure that that is all of them:
+static_assert(GeckoProcessType_ForkServer + 1 == GeckoProcessType_End,
+              "Did not find the final GeckoProcessType");
+
+NS_IMETHODIMP
+nsXULAppInfo::GetProcessType(uint32_t* aResult) {
+  NS_ENSURE_ARG_POINTER(aResult);
+  *aResult = XRE_GetProcessType();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetProcessID(uint32_t* aResult) {
+#ifdef XP_WIN
+  *aResult = GetCurrentProcessId();
+#else
+  *aResult = getpid();
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetUniqueProcessID(uint64_t* aResult) {
+  if (XRE_IsContentProcess()) {
+    ContentChild* cc = ContentChild::GetSingleton();
+    *aResult = cc->GetID();
+  } else {
+    *aResult = 0;
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetRemoteType(nsACString& aRemoteType) {
+  if (XRE_IsContentProcess()) {
+    aRemoteType = ContentChild::GetSingleton()->GetRemoteType();
+  } else {
+    aRemoteType = NOT_REMOTE_TYPE;
+  }
+
+  return NS_OK;
+}
+
+static nsCString gLastAppVersion;
+static nsCString gLastAppBuildID;
+
+NS_IMETHODIMP
+nsXULAppInfo::GetLastAppVersion(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  if (!gLastAppVersion.IsVoid() && gLastAppVersion.IsEmpty()) {
+    NS_WARNING("Attempt to retrieve lastAppVersion before it has been set.");
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  aResult.Assign(gLastAppVersion);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetLastAppBuildID(nsACString& aResult) {
+  if (XRE_IsContentProcess()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  if (!gLastAppBuildID.IsVoid() && gLastAppBuildID.IsEmpty()) {
+    NS_WARNING("Attempt to retrieve lastAppBuildID before it has been set.");
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  aResult.Assign(gLastAppBuildID);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetFissionAutostart(bool* aResult) {
+  *aResult = FissionAutostart();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetFissionExperimentStatus(ExperimentStatus* aResult) {
+  if (!XRE_IsParentProcess()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  EnsureFissionAutostartInitialized();
+  *aResult = gFissionExperimentStatus;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetFissionDecisionStatus(FissionDecisionStatus* aResult) {
+  if (!XRE_IsParentProcess()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  EnsureFissionAutostartInitialized();
+
+  MOZ_ASSERT(gFissionDecisionStatus != eFissionStatusUnknown);
+  *aResult = gFissionDecisionStatus;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetFissionDecisionStatusString(nsACString& aResult) {
+  if (!XRE_IsParentProcess()) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  EnsureFissionAutostartInitialized();
+  switch (gFissionDecisionStatus) {
+    case eFissionExperimentControl:
+      aResult = "experimentControl";
+      break;
+    case eFissionExperimentTreatment:
+      aResult = "experimentTreatment";
+      break;
+    case eFissionDisabledByE10sEnv:
+      aResult = "disabledByE10sEnv";
+      break;
+    case eFissionEnabledByEnv:
+      aResult = "enabledByEnv";
+      break;
+    case eFissionDisabledBySafeMode:
+      aResult = "disabledBySafeMode";
+      break;
+    case eFissionEnabledByDefault:
+      aResult = "enabledByDefault";
+      break;
+    case eFissionDisabledByDefault:
+      aResult = "disabledByDefault";
+      break;
+    case eFissionEnabledByUserPref:
+      aResult = "enabledByUserPref";
+      break;
+    case eFissionDisabledByUserPref:
+      aResult = "disabledByUserPref";
+      break;
+    case eFissionDisabledByE10sOther:
+      aResult = "disabledByE10sOther";
+      break;
+    default:
+      MOZ_ASSERT_UNREACHABLE("Unexpected enum value");
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetSessionHistoryInParent(bool* aResult) {
+  *aResult = SessionHistoryInParent();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetBrowserTabsRemoteAutostart(bool* aResult) {
+  *aResult = BrowserTabsRemoteAutostart();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetMaxWebProcessCount(uint32_t* aResult) {
+  *aResult = mozilla::GetMaxWebProcessCount();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetAccessibilityEnabled(bool* aResult) {
+#ifdef ACCESSIBILITY
+  *aResult = GetAccService() != nullptr;
+#else
+  *aResult = false;
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetAccessibleHandlerUsed(bool* aResult) {
+#if defined(ACCESSIBILITY) && defined(XP_WIN)
+  *aResult = Preferences::GetBool("accessibility.handler.enabled", false) &&
+             a11y::IsHandlerRegistered();
+#else
+  *aResult = false;
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetAccessibilityInstantiator(nsAString& aInstantiator) {
+#if defined(ACCESSIBILITY) && defined(XP_WIN)
+  if (!GetAccService()) {
+    aInstantiator.Truncate();
+    return NS_OK;
+  }
+  nsAutoString ipClientInfo;
+  a11y::Compatibility::GetHumanReadableConsumersStr(ipClientInfo);
+  aInstantiator.Append(ipClientInfo);
+  aInstantiator.AppendLiteral("|");
+
+  nsCOMPtr<nsIFile> oopClientExe;
+  if (a11y::GetInstantiator(getter_AddRefs(oopClientExe))) {
+    nsAutoString oopClientInfo;
+    if (NS_SUCCEEDED(oopClientExe->GetPath(oopClientInfo))) {
+      aInstantiator.Append(oopClientInfo);
+    }
+  }
+#else
+  aInstantiator.Truncate();
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetShouldBlockIncompatJaws(bool* aResult) {
+  *aResult = false;
+#if defined(ACCESSIBILITY) && defined(XP_WIN)
+  *aResult = mozilla::a11y::Compatibility::IsOldJAWS();
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetIs64Bit(bool* aResult) {
+#ifdef HAVE_64BIT_BUILD
+  *aResult = true;
+#else
+  *aResult = false;
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::EnsureContentProcess() {
+  if (!XRE_IsParentProcess()) return NS_ERROR_NOT_AVAILABLE;
+
+  RefPtr<ContentParent> unused =
+      ContentParent::GetNewOrUsedBrowserProcess(DEFAULT_REMOTE_TYPE);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::InvalidateCachesOnRestart() {
+  nsCOMPtr<nsIFile> file;
+  nsresult rv =
+      NS_GetSpecialDirectory(NS_APP_PROFILE_DIR_STARTUP, getter_AddRefs(file));
+  if (NS_FAILED(rv)) return rv;
+  if (!file) return NS_ERROR_NOT_AVAILABLE;
+
+  file->AppendNative(FILE_COMPATIBILITY_INFO);
+
+  nsINIParser parser;
+  rv = parser.Init(file);
+  if (NS_FAILED(rv)) {
+    // This fails if compatibility.ini is not there, so we'll
+    // flush the caches on the next restart anyways.
+    return NS_OK;
+  }
+
+  nsAutoCString buf;
+  rv = parser.GetString("Compatibility", "InvalidateCaches", buf);
+
+  if (NS_FAILED(rv)) {
+    PRFileDesc* fd;
+    rv = file->OpenNSPRFileDesc(PR_RDWR | PR_APPEND, 0600, &fd);
+    if (NS_FAILED(rv)) {
+      NS_ERROR("could not create output stream");
+      return NS_ERROR_NOT_AVAILABLE;
+    }
+    static const char kInvalidationHeader[] =
+        NS_LINEBREAK "InvalidateCaches=1" NS_LINEBREAK;
+    PR_Write(fd, kInvalidationHeader, sizeof(kInvalidationHeader) - 1);
+    PR_Close(fd);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetReplacedLockTime(PRTime* aReplacedLockTime) {
+  if (!gProfileLock) return NS_ERROR_NOT_AVAILABLE;
+  gProfileLock->GetReplacedLockTime(aReplacedLockTime);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetIsReleaseOrBeta(bool* aResult) {
+#ifdef RELEASE_OR_BETA
+  *aResult = true;
+#else
+  *aResult = false;
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetIsOfficialBranding(bool* aResult) {
+#ifdef MOZ_OFFICIAL_BRANDING
+  *aResult = true;
+#else
+  *aResult = false;
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetDefaultUpdateChannel(nsACString& aResult) {
+  aResult.AssignLiteral(MOZ_STRINGIFY(MOZ_UPDATE_CHANNEL));
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetDistributionID(nsACString& aResult) {
+  aResult.AssignLiteral(MOZ_DISTRIBUTION_ID);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetWindowsDLLBlocklistStatus(bool* aResult) {
+#if defined(HAS_DLL_BLOCKLIST)
+  *aResult = DllBlocklist_CheckStatus();
+#else
+  *aResult = false;
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetRestartedByOS(bool* aResult) {
+  *aResult = gRestartedByOS;
+  return NS_OK;
+}
+
+#if defined(XP_WIN) && defined(MOZ_LAUNCHER_PROCESS)
+// Forward declaration
+void SetupLauncherProcessPref();
+
+static Maybe<LauncherRegistryInfo::EnabledState> gLauncherProcessState;
+#endif  // defined(XP_WIN) && defined(MOZ_LAUNCHER_PROCESS)
+
+NS_IMETHODIMP
+nsXULAppInfo::GetLauncherProcessState(uint32_t* aResult) {
+#if defined(XP_WIN) && defined(MOZ_LAUNCHER_PROCESS)
+  SetupLauncherProcessPref();
+
+  if (!gLauncherProcessState) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  *aResult = static_cast<uint32_t>(gLauncherProcessState.value());
+  return NS_OK;
+#else
+  return NS_ERROR_NOT_AVAILABLE;
+#endif
+}
+
+#ifdef XP_WIN
+NS_IMETHODIMP
+nsXULAppInfo::GetUserCanElevate(bool* aUserCanElevate) {
+  HANDLE rawToken;
+  if (!::OpenProcessToken(::GetCurrentProcess(), TOKEN_QUERY, &rawToken)) {
+    *aUserCanElevate = false;
+    return NS_OK;
+  }
+
+  nsAutoHandle token(rawToken);
+  LauncherResult<TOKEN_ELEVATION_TYPE> elevationType = GetElevationType(token);
+  if (elevationType.isErr()) {
+    *aUserCanElevate = false;
+    return NS_OK;
+  }
+
+  // The possible values returned for elevationType and their meanings are:
+  //   TokenElevationTypeDefault: The token does not have a linked token
+  //     (e.g. UAC disabled or a standard user, so they can't be elevated)
+  //   TokenElevationTypeFull: The token is linked to an elevated token
+  //     (e.g. UAC is enabled and the user is already elevated so they can't
+  //      be elevated again)
+  //   TokenElevationTypeLimited: The token is linked to a limited token
+  //     (e.g. UAC is enabled and the user is not elevated, so they can be
+  //      elevated)
+  *aUserCanElevate = (elevationType.inspect() == TokenElevationTypeLimited);
+  return NS_OK;
+}
+#endif
+
+NS_IMETHODIMP
+nsXULAppInfo::GetEnabled(bool* aEnabled) {
+  *aEnabled = CrashReporter::GetEnabled();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::SetEnabled(bool aEnabled) {
+  if (aEnabled) {
+    if (CrashReporter::GetEnabled()) {
+      // no point in erroring for double-enabling
+      return NS_OK;
+    }
+
+    nsCOMPtr<nsIFile> greBinDir;
+    NS_GetSpecialDirectory(NS_GRE_BIN_DIR, getter_AddRefs(greBinDir));
+    if (!greBinDir) {
+      return NS_ERROR_FAILURE;
+    }
+
+    nsCOMPtr<nsIFile> xreBinDirectory = greBinDir;
+    if (!xreBinDirectory) {
+      return NS_ERROR_FAILURE;
+    }
+
+    return CrashReporter::SetExceptionHandler(xreBinDirectory, true);
+  }
+
+  if (!CrashReporter::GetEnabled()) {
+    // no point in erroring for double-disabling
+    return NS_OK;
+  }
+
+  return CrashReporter::UnsetExceptionHandler();
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetServerURL(nsIURL** aServerURL) {
+  NS_ENSURE_ARG_POINTER(aServerURL);
+  if (!CrashReporter::GetEnabled()) return NS_ERROR_NOT_INITIALIZED;
+
+  nsAutoCString data;
+  if (!CrashReporter::GetServerURL(data)) {
+    return NS_ERROR_FAILURE;
+  }
+  nsCOMPtr<nsIURI> uri;
+  NS_NewURI(getter_AddRefs(uri), data);
+  if (!uri) return NS_ERROR_FAILURE;
+
+  nsCOMPtr<nsIURL> url;
+  url = do_QueryInterface(uri);
+  NS_ADDREF(*aServerURL = url);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::SetServerURL(nsIURL* aServerURL) {
+  // Only allow https or http URLs
+  if (!aServerURL->SchemeIs("http") && !aServerURL->SchemeIs("https")) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  nsAutoCString spec;
+  nsresult rv = aServerURL->GetSpec(spec);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return CrashReporter::SetServerURL(spec);
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetMinidumpPath(nsIFile** aMinidumpPath) {
+  if (!CrashReporter::GetEnabled()) return NS_ERROR_NOT_INITIALIZED;
+
+  nsAutoString path;
+  if (!CrashReporter::GetMinidumpPath(path)) return NS_ERROR_FAILURE;
+
+  nsresult rv = NS_NewLocalFile(path, false, aMinidumpPath);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::SetMinidumpPath(nsIFile* aMinidumpPath) {
+  nsAutoString path;
+  nsresult rv = aMinidumpPath->GetPath(path);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return CrashReporter::SetMinidumpPath(path);
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetMinidumpForID(const nsAString& aId, nsIFile** aMinidump) {
+  if (!CrashReporter::GetMinidumpForID(aId, aMinidump)) {
+    return NS_ERROR_FILE_NOT_FOUND;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetExtraFileForID(const nsAString& aId, nsIFile** aExtraFile) {
+  if (!CrashReporter::GetExtraFileForID(aId, aExtraFile)) {
+    return NS_ERROR_FILE_NOT_FOUND;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::AnnotateCrashReport(const nsACString& key,
+                                  const nsACString& data) {
+  CrashReporter::Annotation annotation;
+
+  if (!AnnotationFromString(annotation, PromiseFlatCString(key).get())) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  return CrashReporter::AnnotateCrashReport(annotation, data);
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::RemoveCrashReportAnnotation(const nsACString& key) {
+  CrashReporter::Annotation annotation;
+
+  if (!AnnotationFromString(annotation, PromiseFlatCString(key).get())) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  return CrashReporter::RemoveCrashReportAnnotation(annotation);
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::IsAnnotationWhitelistedForPing(const nsACString& aValue,
+                                             bool* aIsWhitelisted) {
+  CrashReporter::Annotation annotation;
+
+  if (!AnnotationFromString(annotation, PromiseFlatCString(aValue).get())) {
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  *aIsWhitelisted = CrashReporter::IsAnnotationWhitelistedForPing(annotation);
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::AppendAppNotesToCrashReport(const nsACString& data) {
+  return CrashReporter::AppendAppNotesToCrashReport(data);
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::RegisterAppMemory(uint64_t pointer, uint64_t len) {
+  return CrashReporter::RegisterAppMemory((void*)pointer, len);
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::WriteMinidumpForException(void* aExceptionInfo) {
+#ifdef XP_WIN
+  return CrashReporter::WriteMinidumpForException(
+      static_cast<EXCEPTION_POINTERS*>(aExceptionInfo));
+#else
+  return NS_ERROR_NOT_IMPLEMENTED;
+#endif
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::AppendObjCExceptionInfoToAppNotes(void* aException) {
+#ifdef XP_MACOSX
+  return CrashReporter::AppendObjCExceptionInfoToAppNotes(aException);
+#else
+  return NS_ERROR_NOT_IMPLEMENTED;
+#endif
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::GetSubmitReports(bool* aEnabled) {
+  return CrashReporter::GetSubmitReports(aEnabled);
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::SetSubmitReports(bool aEnabled) {
+  return CrashReporter::SetSubmitReports(aEnabled);
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::UpdateCrashEventsDir() {
+  CrashReporter::UpdateCrashEventsDir();
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsXULAppInfo::SaveMemoryReport() {
+  if (!CrashReporter::GetEnabled()) {
+    return NS_ERROR_NOT_INITIALIZED;
+  }
+  nsCOMPtr<nsIFile> file;
+  nsresult rv = CrashReporter::GetDefaultMemoryReportFile(getter_AddRefs(file));
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+
+  nsString path;
+  file->GetPath(path);
+
+  nsCOMPtr<nsIMemoryInfoDumper> dumper =
+      do_GetService("@mozilla.org/memory-info-dumper;1");
+  if (NS_WARN_IF(!dumper)) {
+    return NS_ERROR_UNEXPECTED;
+  }
+
+  rv = dumper->DumpMemoryReportsToNamedFile(
+      path, this, file, true /* anonymize */, false /* minimizeMemoryUsage */);
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    return rv;
+  }
+  return NS_OK;
+}
+
+// This method is from nsIFInishDumpingCallback.
+NS_IMETHODIMP
+nsXULAppInfo::Callback(nsISupports* aData) {
+  nsCOMPtr<nsIFile> file = do_QueryInterface(aData);
+  MOZ_ASSERT(file);
+
+  CrashReporter::SetMemoryReportFile(file);
+  return NS_OK;
+}
+
+static const nsXULAppInfo kAppInfo;
+namespace mozilla {
+nsresult AppInfoConstructor(nsISupports* aOuter, REFNSIID aIID,
+                            void** aResult) {
+  NS_ENSURE_NO_AGGREGATION(aOuter);
+
+  return const_cast<nsXULAppInfo*>(&kAppInfo)->QueryInterface(aIID, aResult);
+}
+}  // namespace mozilla
+
+bool gLogConsoleErrors = false;
+
+#define NS_ENSURE_TRUE_LOG(x, ret)               \
+  PR_BEGIN_MACRO                                 \
+  if (MOZ_UNLIKELY(!(x))) {                      \
+    NS_WARNING("NS_ENSURE_TRUE(" #x ") failed"); \
+    gLogConsoleErrors = true;                    \
+    return ret;                                  \
+  }                                              \
+  PR_END_MACRO
+
+#define NS_ENSURE_SUCCESS_LOG(res, ret) \
+  NS_ENSURE_TRUE_LOG(NS_SUCCEEDED(res), ret)
+
+/**
+ * Because we're starting/stopping XPCOM several times in different scenarios,
+ * this class is a stack-based critter that makes sure that XPCOM is shut down
+ * during early returns.
+ */
+
+class ScopedXPCOMStartup {
+ public:
+  ScopedXPCOMStartup() : mServiceManager(nullptr) {}
+  ~ScopedXPCOMStartup();
+
+  nsresult Initialize(bool aInitJSContext = true);
+  nsresult SetWindowCreator(nsINativeAppSupport* native);
+
+ private:
+  nsIServiceManager* mServiceManager;
+  static nsINativeAppSupport* gNativeAppSupport;
+
+  friend already_AddRefed<nsINativeAppSupport> NS_GetNativeAppSupport();
+};
+
+ScopedXPCOMStartup::~ScopedXPCOMStartup() {
+  NS_IF_RELEASE(gNativeAppSupport);
+
+  if (mServiceManager) {
+#ifdef XP_MACOSX
+    // On OS X, we need a pool to catch cocoa objects that are autoreleased
+    // during teardown.
+    mozilla::MacAutoreleasePool pool;
+#endif
+
+    nsCOMPtr<nsIAppStartup> appStartup(components::AppStartup::Service());
+    if (appStartup) appStartup->DestroyHiddenWindow();
+
+    gDirServiceProvider->DoShutdown();
+    PROFILER_MARKER_UNTYPED("Shutdown early", OTHER);
+
+    WriteConsoleLog();
+
+    NS_ShutdownXPCOM(mServiceManager);
+    mServiceManager = nullptr;
+  }
+}
+
+// {5F5E59CE-27BC-47eb-9D1F-B09CA9049836}
+static const nsCID kProfileServiceCID = {
+    0x5f5e59ce,
+    0x27bc,
+    0x47eb,
+    {0x9d, 0x1f, 0xb0, 0x9c, 0xa9, 0x4, 0x98, 0x36}};
+
+static already_AddRefed<nsIFactory> ProfileServiceFactoryConstructor(
+    const mozilla::Module& module, const mozilla::Module::CIDEntry& entry) {
+  nsCOMPtr<nsIFactory> factory;
+  NS_NewToolkitProfileFactory(getter_AddRefs(factory));
+  return factory.forget();
+}
+
+static const mozilla::Module::CIDEntry kXRECIDs[] = {
+    {&kProfileServiceCID, false, ProfileServiceFactoryConstructor, nullptr},
+    {nullptr}};
+
+static const mozilla::Module::ContractIDEntry kXREContracts[] = {
+    {NS_PROFILESERVICE_CONTRACTID, &kProfileServiceCID}, {nullptr}};
+
+extern const mozilla::Module kXREModule = {mozilla::Module::kVersion, kXRECIDs,
+                                           kXREContracts};
+
+nsresult ScopedXPCOMStartup::Initialize(bool aInitJSContext) {
+  NS_ASSERTION(gDirServiceProvider, "Should not get here!");
+
+  nsresult rv;
+
+  rv = NS_InitXPCOM(&mServiceManager, gDirServiceProvider->GetAppDir(),
+                    gDirServiceProvider, aInitJSContext);
+  if (NS_FAILED(rv)) {
+    NS_ERROR("Couldn't start xpcom!");
+    mServiceManager = nullptr;
+  } else {
+#ifdef DEBUG
+    nsCOMPtr<nsIComponentRegistrar> reg = do_QueryInterface(mServiceManager);
+    NS_ASSERTION(reg, "Service Manager doesn't QI to Registrar.");
+#endif
+  }
+
+  return rv;
+}
+
+/**
+ * This is a little factory class that serves as a singleton-service-factory
+ * for the nativeappsupport object.
+ */
+class nsSingletonFactory final : public nsIFactory {
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIFACTORY
+
+  explicit nsSingletonFactory(nsISupports* aSingleton);
+
+ private:
+  ~nsSingletonFactory() = default;
+  nsCOMPtr<nsISupports> mSingleton;
+};
+
+nsSingletonFactory::nsSingletonFactory(nsISupports* aSingleton)
+    : mSingleton(aSingleton) {
+  NS_ASSERTION(mSingleton, "Singleton was null!");
+}
+
+NS_IMPL_ISUPPORTS(nsSingletonFactory, nsIFactory)
+
+NS_IMETHODIMP
+nsSingletonFactory::CreateInstance(nsISupports* aOuter, const nsIID& aIID,
+                                   void** aResult) {
+  NS_ENSURE_NO_AGGREGATION(aOuter);
+
+  return mSingleton->QueryInterface(aIID, aResult);
+}
+
+NS_IMETHODIMP
+nsSingletonFactory::LockFactory(bool) { return NS_OK; }
+
+/**
+ * Set our windowcreator on the WindowWatcher service.
+ */
+nsresult ScopedXPCOMStartup::SetWindowCreator(nsINativeAppSupport* native) {
+  nsresult rv;
+
+  NS_IF_ADDREF(gNativeAppSupport = native);
+
+  nsCOMPtr<nsIWindowCreator> creator(components::AppStartup::Service());
+  if (!creator) return NS_ERROR_UNEXPECTED;
+
+  nsCOMPtr<nsIWindowWatcher> wwatch(
+      do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return wwatch->SetWindowCreator(creator);
+}
+
+/* static */ already_AddRefed<nsINativeAppSupport> NS_GetNativeAppSupport() {
+  if (!ScopedXPCOMStartup::gNativeAppSupport) {
+    return nullptr;
+  }
+
+  return do_AddRef(ScopedXPCOMStartup::gNativeAppSupport);
+}
+
+nsINativeAppSupport* ScopedXPCOMStartup::gNativeAppSupport;
+
+static void DumpArbitraryHelp() {
+  nsresult rv;
+
+  ScopedLogging log;
+
+  {
+    ScopedXPCOMStartup xpcom;
+    xpcom.Initialize();
+
+    nsCOMPtr<nsICommandLineRunner> cmdline(new nsCommandLine());
+
+    nsCString text;
+    rv = cmdline->GetHelpText(text);
+    if (NS_SUCCEEDED(rv)) printf("%s", text.get());
+  }
+}
+
+// English text needs to go into a dtd file.
+// But when this is called we have no components etc. These strings must either
+// be here, or in a native resource file.
+static void DumpHelp() {
+  printf(
+      "Usage: %s [ options ... ] [URL]\n"
+      "       where options include:\n\n",
+      gArgv[0]);
+
+#ifdef MOZ_X11
+  printf(
+      "X11 options\n"
+      "  --display=DISPLAY  X display to use\n"
+      "  --sync             Make X calls synchronous\n");
+#endif
+#ifdef XP_UNIX
+  printf(
+      "  --g-fatal-warnings Make all warnings fatal\n"
+      "\n%s options\n",
+      (const char*)gAppData->name);
+#endif
+
+  printf(
+      "  -h or --help       Print this message.\n"
+      "  -v or --version    Print %s version.\n"
+      "  --full-version     Print %s version, build and platform build ids.\n"
+      "  -P <profile>       Start with <profile>.\n"
+      "  --profile <path>   Start with profile at <path>.\n"
+      "  --migration        Start with migration wizard.\n"
+      "  --ProfileManager   Start with ProfileManager.\n"
+#ifdef MOZ_HAS_REMOTE
+      "  --no-remote        Do not accept or send remote commands; implies\n"
+      "                     --new-instance.\n"
+      "  --new-instance     Open new instance, not a new window in running "
+      "instance.\n"
+#endif
+      "  --safe-mode        Disables extensions and themes for this session.\n"
+#ifdef MOZ_BLOCK_PROFILE_DOWNGRADE
+      "  --allow-downgrade  Allows downgrading a profile.\n"
+#endif
+      "  --MOZ_LOG=<modules> Treated as MOZ_LOG=<modules> environment "
+      "variable,\n"
+      "                     overrides it.\n"
+      "  --MOZ_LOG_FILE=<file> Treated as MOZ_LOG_FILE=<file> environment "
+      "variable,\n"
+      "                     overrides it. If MOZ_LOG_FILE is not specified as "
+      "an\n"
+      "                     argument or as an environment variable, logging "
+      "will be\n"
+      "                     written to stdout.\n",
+      (const char*)gAppData->name, (const char*)gAppData->name);
+
+#if defined(XP_WIN)
+  printf("  --console          Start %s with a debugging console.\n",
+         (const char*)gAppData->name);
+#endif
+
+#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK) || defined(XP_MACOSX)
+  printf("  --headless         Run without a GUI.\n");
+#endif
+
+  // this works, but only after the components have registered.  so if you drop
+  // in a new command line handler, --help won't not until the second run. out
+  // of the bug, because we ship a component.reg file, it works correctly.
+  DumpArbitraryHelp();
+}
+
+static inline void DumpVersion() {
+  if (gAppData->vendor) {
+    printf("%s ", (const char*)gAppData->vendor);
+  }
+  printf("%s ", (const char*)gAppData->name);
+
+  // Use the displayed version
+  // For example, for beta, we would display 42.0b2 instead of 42.0
+  printf("%s", MOZ_STRINGIFY(MOZ_APP_VERSION_DISPLAY));
+
+  if (gAppData->copyright) {
+    printf(", %s", (const char*)gAppData->copyright);
+  }
+  printf("\n");
+}
+
+static inline void DumpFullVersion() {
+  if (gAppData->vendor) {
+    printf("%s ", (const char*)gAppData->vendor);
+  }
+  printf("%s ", (const char*)gAppData->name);
+
+  // Use the displayed version
+  // For example, for beta, we would display 42.0b2 instead of 42.0
+  printf("%s ", MOZ_STRINGIFY(MOZ_APP_VERSION_DISPLAY));
+
+  printf("%s ", (const char*)gAppData->buildID);
+  printf("%s ", (const char*)PlatformBuildID());
+  if (gAppData->copyright) {
+    printf(", %s", (const char*)gAppData->copyright);
+  }
+  printf("\n");
+}
+
+void XRE_InitOmnijar(nsIFile* greOmni, nsIFile* appOmni) {
+  mozilla::Omnijar::Init(greOmni, appOmni);
+}
+
+nsresult XRE_GetBinaryPath(nsIFile** aResult) {
+  return mozilla::BinaryPath::GetFile(aResult);
+}
+
+#ifdef XP_WIN
+#  include "nsWindowsRestart.cpp"
+#  include <shellapi.h>
+
+typedef BOOL(WINAPI* SetProcessDEPPolicyFunc)(DWORD dwFlags);
+
+static void RegisterApplicationRestartChanged(const char* aPref, void* aData) {
+  DWORD cchCmdLine = 0;
+  HRESULT rc = ::GetApplicationRestartSettings(::GetCurrentProcess(), nullptr,
+                                               &cchCmdLine, nullptr);
+  bool wasRegistered = false;
+  if (rc == S_OK) {
+    wasRegistered = true;
+  }
+
+  if (Preferences::GetBool(PREF_WIN_REGISTER_APPLICATION_RESTART, false) &&
+      !wasRegistered) {
+    // Make the command line to use when restarting.
+    // Excludes argv[0] because RegisterApplicationRestart adds the
+    // executable name, replace that temporarily with -os-restarted
+    char* exeName = gRestartArgv[0];
+    gRestartArgv[0] = const_cast<char*>("-os-restarted");
+    wchar_t** restartArgvConverted =
+        AllocConvertUTF8toUTF16Strings(gRestartArgc, gRestartArgv);
+    gRestartArgv[0] = exeName;
+
+    mozilla::UniquePtr<wchar_t[]> restartCommandLine;
+    if (restartArgvConverted) {
+      restartCommandLine =
+          mozilla::MakeCommandLine(gRestartArgc, restartArgvConverted);
+      FreeAllocStrings(gRestartArgc, restartArgvConverted);
+    }
+
+    if (restartCommandLine) {
+      // Flags RESTART_NO_PATCH and RESTART_NO_REBOOT are not set, so we
+      // should be restarted if terminated by an update or restart.
+      ::RegisterApplicationRestart(restartCommandLine.get(),
+                                   RESTART_NO_CRASH | RESTART_NO_HANG);
+    }
+  } else if (wasRegistered) {
+    ::UnregisterApplicationRestart();
+  }
+}
+
+static void OnAlteredPrefetchPrefChanged(const char* aPref, void* aData) {
+  int32_t prefVal = Preferences::GetInt(PREF_WIN_ALTERED_DLL_PREFETCH, 0);
+
+  mozilla::DllPrefetchExperimentRegistryInfo prefetchRegInfo;
+  mozilla::DebugOnly<mozilla::Result<Ok, nsresult>> reflectResult =
+      prefetchRegInfo.ReflectPrefToRegistry(prefVal);
+
+  MOZ_ASSERT(reflectResult.value.isOk());
+}
+
+static void SetupAlteredPrefetchPref() {
+  mozilla::DllPrefetchExperimentRegistryInfo prefetchRegInfo;
+
+  mozilla::DebugOnly<mozilla::Result<Ok, nsresult>> reflectResult =
+      prefetchRegInfo.ReflectPrefToRegistry(
+          Preferences::GetInt(PREF_WIN_ALTERED_DLL_PREFETCH, 0));
+  MOZ_ASSERT(reflectResult.value.isOk());
+
+  Preferences::RegisterCallback(&OnAlteredPrefetchPrefChanged,
+                                PREF_WIN_ALTERED_DLL_PREFETCH);
+}
+
+static void ReflectSkeletonUIPrefToRegistry(const char* aPref, void* aData) {
+  Unused << aPref;
+  Unused << aData;
+
+  bool shouldBeEnabled =
+      Preferences::GetBool(kPrefPreXulSkeletonUI, false) &&
+      Preferences::GetBool(kPrefBrowserStartupBlankWindow, false) &&
+      Preferences::GetBool(kPrefDrawTabsInTitlebar, false);
+  if (shouldBeEnabled && Preferences::HasUserValue(kPrefThemeId)) {
+    nsCString themeId;
+    Preferences::GetCString(kPrefThemeId, themeId);
+    if (themeId.EqualsLiteral("default-theme@mozilla.org")) {
+      SetPreXULSkeletonUIThemeId(ThemeMode::Default);
+    } else if (themeId.EqualsLiteral("firefox-compact-dark@mozilla.org")) {
+      SetPreXULSkeletonUIThemeId(ThemeMode::Dark);
+    } else if (themeId.EqualsLiteral("firefox-compact-light@mozilla.org")) {
+      SetPreXULSkeletonUIThemeId(ThemeMode::Light);
+    } else {
+      shouldBeEnabled = false;
+    }
+  } else if (shouldBeEnabled) {
+    SetPreXULSkeletonUIThemeId(ThemeMode::Default);
+  }
+
+  if (GetPreXULSkeletonUIEnabled() != shouldBeEnabled) {
+    SetPreXULSkeletonUIEnabledIfAllowed(shouldBeEnabled);
+  }
+}
+
+static void SetupSkeletonUIPrefs() {
+  ReflectSkeletonUIPrefToRegistry(nullptr, nullptr);
+  Preferences::RegisterCallback(&ReflectSkeletonUIPrefToRegistry,
+                                kPrefPreXulSkeletonUI);
+  Preferences::RegisterCallback(&ReflectSkeletonUIPrefToRegistry,
+                                kPrefBrowserStartupBlankWindow);
+  Preferences::RegisterCallback(&ReflectSkeletonUIPrefToRegistry, kPrefThemeId);
+  Preferences::RegisterCallback(&ReflectSkeletonUIPrefToRegistry,
+                                kPrefDrawTabsInTitlebar);
+}
+
+#  if defined(MOZ_LAUNCHER_PROCESS)
+
+static void OnLauncherPrefChanged(const char* aPref, void* aData) {
+  bool prefVal = Preferences::GetBool(PREF_WIN_LAUNCHER_PROCESS_ENABLED, true);
+
+  mozilla::LauncherRegistryInfo launcherRegInfo;
+  mozilla::DebugOnly<mozilla::LauncherVoidResult> reflectResult =
+      launcherRegInfo.ReflectPrefToRegistry(prefVal);
+  MOZ_ASSERT(reflectResult.inspect().isOk());
+}
+
+static void OnLauncherTelemetryPrefChanged(const char* aPref, void* aData) {
+  bool prefVal = Preferences::GetBool(kPrefHealthReportUploadEnabled, true);
+
+  mozilla::LauncherRegistryInfo launcherRegInfo;
+  mozilla::DebugOnly<mozilla::LauncherVoidResult> reflectResult =
+      launcherRegInfo.ReflectTelemetryPrefToRegistry(prefVal);
+  MOZ_ASSERT(reflectResult.inspect().isOk());
+}
+
+static void SetupLauncherProcessPref() {
+  if (gLauncherProcessState) {
+    // We've already successfully run
+    return;
+  }
+
+  mozilla::LauncherRegistryInfo launcherRegInfo;
+
+  mozilla::LauncherResult<mozilla::LauncherRegistryInfo::EnabledState>
+      enabledState = launcherRegInfo.IsEnabled();
+
+  if (enabledState.isOk()) {
+    gLauncherProcessState = Some(enabledState.unwrap());
+
+    CrashReporter::AnnotateCrashReport(
+        CrashReporter::Annotation::LauncherProcessState,
+        static_cast<uint32_t>(enabledState.unwrap()));
+
+    // Reflect the launcher process registry state into user prefs
+    Preferences::SetBool(
+        PREF_WIN_LAUNCHER_PROCESS_ENABLED,
+        enabledState.unwrap() !=
+            mozilla::LauncherRegistryInfo::EnabledState::ForceDisabled);
+  }
+
+  mozilla::DebugOnly<mozilla::LauncherVoidResult> reflectResult =
+      launcherRegInfo.ReflectTelemetryPrefToRegistry(
+          Preferences::GetBool(kPrefHealthReportUploadEnabled, true));
+  MOZ_ASSERT(reflectResult.inspect().isOk());
+
+  Preferences::RegisterCallback(&OnLauncherPrefChanged,
+                                PREF_WIN_LAUNCHER_PROCESS_ENABLED);
+  Preferences::RegisterCallback(&OnLauncherTelemetryPrefChanged,
+                                kPrefHealthReportUploadEnabled);
+}
+
+#  endif  // defined(MOZ_LAUNCHER_PROCESS)
+
+#  if defined(MOZ_DEFAULT_BROWSER_AGENT)
+
+#    define DEFAULT_BROWSER_AGENT_KEY_NAME \
+      "SOFTWARE\\" MOZ_APP_VENDOR "\\" MOZ_APP_NAME "\\Default Browser Agent"
+
+static nsresult PrependRegistryValueName(nsAutoString& aValueName) {
+  nsresult rv;
+
+  nsCOMPtr<nsIFile> binaryPath;
+  rv = XRE_GetBinaryPath(getter_AddRefs(binaryPath));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIFile> binaryDir;
+  rv = binaryPath->GetParent(getter_AddRefs(binaryDir));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsAutoString prefix;
+  rv = binaryDir->GetPath(prefix);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  prefix.AppendLiteral("|");
+  aValueName.Insert(prefix, 0);
+
+  return NS_OK;
+}
+
+static void OnDefaultAgentTelemetryPrefChanged(const char* aPref, void* aData) {
+  nsresult rv;
+  nsAutoString valueName;
+  if (strcmp(aPref, kPrefHealthReportUploadEnabled) == 0) {
+    valueName.AssignLiteral("DisableTelemetry");
+  } else if (strcmp(aPref, kPrefDefaultAgentEnabled) == 0) {
+    valueName.AssignLiteral("DisableDefaultBrowserAgent");
+  } else {
+    return;
+  }
+  rv = PrependRegistryValueName(valueName);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsCOMPtr<nsIWindowsRegKey> regKey =
+      do_CreateInstance("@mozilla.org/windows-registry-key;1", &rv);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsAutoString keyName;
+  keyName.AppendLiteral(DEFAULT_BROWSER_AGENT_KEY_NAME);
+  rv = regKey->Create(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER, keyName,
+                      nsIWindowsRegKey::ACCESS_WRITE);
+
+  bool prefVal = Preferences::GetBool(aPref, true);
+
+  // We're recording whether the pref is *disabled*, so invert the value.
+  rv = regKey->WriteIntValue(valueName, prefVal ? 0 : 1);
+  NS_ENSURE_SUCCESS_VOID(rv);
+}
+
+static void OnDefaultAgentRemoteSettingsPrefChanged(const char* aPref,
+                                                    void* aData) {
+  nsresult rv;
+  nsAutoString valueName;
+  if (strcmp(aPref, kPrefServicesSettingsServer) == 0) {
+    valueName.AssignLiteral("ServicesSettingsServer");
+  } else if (strcmp(aPref, kPrefSecurityContentSignatureRootHash) == 0) {
+    valueName.AssignLiteral("SecurityContentSignatureRootHash");
+  } else {
+    return;
+  }
+  rv = PrependRegistryValueName(valueName);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsCOMPtr<nsIWindowsRegKey> regKey =
+      do_CreateInstance("@mozilla.org/windows-registry-key;1", &rv);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsAutoString keyName;
+  keyName.AppendLiteral(DEFAULT_BROWSER_AGENT_KEY_NAME);
+  rv = regKey->Create(nsIWindowsRegKey::ROOT_KEY_CURRENT_USER, keyName,
+                      nsIWindowsRegKey::ACCESS_WRITE);
+
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsAutoString prefVal;
+  rv = Preferences::GetString(aPref, prefVal);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  if (prefVal.IsEmpty()) {
+    rv = regKey->RemoveValue(valueName);
+  } else {
+    rv = regKey->WriteStringValue(valueName, prefVal);
+  }
+  NS_ENSURE_SUCCESS_VOID(rv);
+}
+
+#  endif  // defined(MOZ_DEFAULT_BROWSER_AGENT)
+
+#endif  // XP_WIN
+
+void UnlockProfile() {
+  if (gProfileLock) {
+    gProfileLock->Unlock();
+  }
+}
+
+// If aBlankCommandLine is true, then the application will be launched with a
+// blank command line instead of being launched with the same command line that
+// it was initially started with.
+nsresult LaunchChild(bool aBlankCommandLine) {
+  // Restart this process by exec'ing it into the current process
+  // if supported by the platform.  Otherwise, use NSPR.
+
+#ifdef MOZ_JPROF
+  // make sure JPROF doesn't think we're E10s
+  unsetenv("JPROF_SLAVE");
+#endif
+
+  if (aBlankCommandLine) {
+    gRestartArgc = 1;
+    gRestartArgv[gRestartArgc] = nullptr;
+  }
+
+  SaveToEnv("MOZ_LAUNCHED_CHILD=1");
+#if defined(MOZ_LAUNCHER_PROCESS)
+  SaveToEnv("MOZ_LAUNCHER_PROCESS=1");
+#endif  // defined(MOZ_LAUNCHER_PROCESS)
+
+#if !defined(MOZ_WIDGET_ANDROID)  // Android has separate restart code.
+#  if defined(XP_MACOSX)
+  CommandLineServiceMac::SetupMacCommandLine(gRestartArgc, gRestartArgv, true);
+  LaunchChildMac(gRestartArgc, gRestartArgv);
+#  else
+  nsCOMPtr<nsIFile> lf;
+  nsresult rv = XRE_GetBinaryPath(getter_AddRefs(lf));
+  if (NS_FAILED(rv)) return rv;
+
+#    if defined(XP_WIN)
+  nsAutoString exePath;
+  rv = lf->GetPath(exePath);
+  if (NS_FAILED(rv)) return rv;
+
+  HANDLE hProcess;
+  if (!WinLaunchChild(exePath.get(), gRestartArgc, gRestartArgv, nullptr,
+                      &hProcess))
+    return NS_ERROR_FAILURE;
+  // Keep the current process around until the restarted process has created
+  // its message queue, to avoid the launched process's windows being forced
+  // into the background.
+  mozilla::WaitForInputIdle(hProcess);
+  ::CloseHandle(hProcess);
+
+#    else
+  nsAutoCString exePath;
+  rv = lf->GetNativePath(exePath);
+  if (NS_FAILED(rv)) return rv;
+
+#      if defined(XP_UNIX)
+  if (execv(exePath.get(), gRestartArgv) == -1) return NS_ERROR_FAILURE;
+#      else
+  PRProcess* process =
+      PR_CreateProcess(exePath.get(), gRestartArgv, nullptr, nullptr);
+  if (!process) return NS_ERROR_FAILURE;
+
+  int32_t exitCode;
+  PRStatus failed = PR_WaitProcess(process, &exitCode);
+  if (failed || exitCode) return NS_ERROR_FAILURE;
+#      endif  // XP_UNIX
+#    endif  // WP_WIN
+#  endif  // WP_MACOSX
+#endif  // MOZ_WIDGET_ANDROID
+
+  return NS_ERROR_LAUNCHED_CHILD_PROCESS;
+}
+
+static const char kProfileProperties[] =
+    "chrome://mozapps/locale/profile/profileSelection.properties";
+
+namespace {
+
+/**
+ * This class, instead of a raw nsresult, should be the return type of any
+ * function called by SelectProfile that initializes XPCOM.
+ */
+class ReturnAbortOnError {
+ public:
+  MOZ_IMPLICIT ReturnAbortOnError(nsresult aRv) { mRv = ConvertRv(aRv); }
+
+  operator nsresult() { return mRv; }
+
+ private:
+  inline nsresult ConvertRv(nsresult aRv) {
+    if (NS_SUCCEEDED(aRv) || aRv == NS_ERROR_LAUNCHED_CHILD_PROCESS) {
+      return aRv;
+    }
+    return NS_ERROR_ABORT;
+  }
+
+  nsresult mRv;
+};
+
+}  // namespace
+
+static nsresult ProfileMissingDialog(nsINativeAppSupport* aNative) {
+  nsresult rv;
+
+  ScopedXPCOMStartup xpcom;
+  rv = xpcom.Initialize();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = xpcom.SetWindowCreator(aNative);
+  NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+  {  // extra scoping is needed so we release these components before xpcom
+     // shutdown
+    nsCOMPtr<nsIStringBundleService> sbs =
+        mozilla::services::GetStringBundleService();
+    NS_ENSURE_TRUE(sbs, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIStringBundle> sb;
+    sbs->CreateBundle(kProfileProperties, getter_AddRefs(sb));
+    NS_ENSURE_TRUE_LOG(sbs, NS_ERROR_FAILURE);
+
+    NS_ConvertUTF8toUTF16 appName(gAppData->name);
+    AutoTArray<nsString, 2> params = {appName, appName};
+
+    // profileMissing
+    nsAutoString missingMessage;
+    rv = sb->FormatStringFromName("profileMissing", params, missingMessage);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_ABORT);
+
+    nsAutoString missingTitle;
+    params.SetLength(1);
+    rv = sb->FormatStringFromName("profileMissingTitle", params, missingTitle);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_ABORT);
+
+    nsCOMPtr<nsIPromptService> ps(do_GetService(NS_PROMPTSERVICE_CONTRACTID));
+    NS_ENSURE_TRUE(ps, NS_ERROR_FAILURE);
+
+    ps->Alert(nullptr, missingTitle.get(), missingMessage.get());
+
+    return NS_ERROR_ABORT;
+  }
+}
+
+static ReturnAbortOnError ProfileLockedDialog(nsIFile* aProfileDir,
+                                              nsIFile* aProfileLocalDir,
+                                              nsIProfileUnlocker* aUnlocker,
+                                              nsINativeAppSupport* aNative,
+                                              nsIProfileLock** aResult) {
+  nsresult rv;
+
+  bool exists;
+  aProfileDir->Exists(&exists);
+  if (!exists) {
+    return ProfileMissingDialog(aNative);
+  }
+
+  ScopedXPCOMStartup xpcom;
+  rv = xpcom.Initialize();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  mozilla::Telemetry::WriteFailedProfileLock(aProfileDir);
+
+  rv = xpcom.SetWindowCreator(aNative);
+  NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+  {  // extra scoping is needed so we release these components before xpcom
+     // shutdown
+    nsCOMPtr<nsIStringBundleService> sbs =
+        mozilla::services::GetStringBundleService();
+    NS_ENSURE_TRUE(sbs, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIStringBundle> sb;
+    sbs->CreateBundle(kProfileProperties, getter_AddRefs(sb));
+    NS_ENSURE_TRUE_LOG(sbs, NS_ERROR_FAILURE);
+
+    NS_ConvertUTF8toUTF16 appName(gAppData->name);
+    AutoTArray<nsString, 3> params = {appName, appName, appName};
+
+    nsAutoString killMessage;
+#ifndef XP_MACOSX
+    rv = sb->FormatStringFromName(
+        aUnlocker ? "restartMessageUnlocker" : "restartMessageNoUnlocker2",
+        params, killMessage);
+#else
+    rv = sb->FormatStringFromName(
+        aUnlocker ? "restartMessageUnlockerMac" : "restartMessageNoUnlockerMac",
+        params, killMessage);
+#endif
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+    params.SetLength(1);
+    nsAutoString killTitle;
+    rv = sb->FormatStringFromName("restartTitle", params, killTitle);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+    if (gfxPlatform::IsHeadless()) {
+      // TODO: make a way to turn off all dialogs when headless.
+      Output(true, "%s\n", NS_LossyConvertUTF16toASCII(killMessage).get());
+      return NS_ERROR_FAILURE;
+    }
+
+    nsCOMPtr<nsIPromptService> ps(do_GetService(NS_PROMPTSERVICE_CONTRACTID));
+    NS_ENSURE_TRUE(ps, NS_ERROR_FAILURE);
+
+    if (aUnlocker) {
+      int32_t button;
+#ifdef MOZ_WIDGET_ANDROID
+      java::GeckoAppShell::KillAnyZombies();
+      button = 0;
+#else
+      const uint32_t flags = (nsIPromptService::BUTTON_TITLE_IS_STRING *
+                              nsIPromptService::BUTTON_POS_0) +
+                             (nsIPromptService::BUTTON_TITLE_CANCEL *
+                              nsIPromptService::BUTTON_POS_1);
+
+      bool checkState = false;
+      rv = ps->ConfirmEx(nullptr, killTitle.get(), killMessage.get(), flags,
+                         killTitle.get(), nullptr, nullptr, nullptr,
+                         &checkState, &button);
+      NS_ENSURE_SUCCESS_LOG(rv, rv);
+#endif
+
+      if (button == 0) {
+        rv = aUnlocker->Unlock(nsIProfileUnlocker::FORCE_QUIT);
+        if (NS_FAILED(rv)) {
+          return rv;
+        }
+
+        SaveFileToEnv("XRE_PROFILE_PATH", aProfileDir);
+        SaveFileToEnv("XRE_PROFILE_LOCAL_PATH", aProfileLocalDir);
+
+        return LaunchChild(false);
+      }
+    } else {
+#ifdef MOZ_WIDGET_ANDROID
+      if (java::GeckoAppShell::UnlockProfile()) {
+        return NS_LockProfilePath(aProfileDir, aProfileLocalDir, nullptr,
+                                  aResult);
+      }
+#else
+      rv = ps->Alert(nullptr, killTitle.get(), killMessage.get());
+      NS_ENSURE_SUCCESS_LOG(rv, rv);
+#endif
+    }
+
+    return NS_ERROR_ABORT;
+  }
+}
+
+static const char kProfileManagerURL[] =
+    "chrome://mozapps/content/profile/profileSelection.xhtml";
+
+static ReturnAbortOnError ShowProfileManager(
+    nsIToolkitProfileService* aProfileSvc, nsINativeAppSupport* aNative) {
+  nsresult rv;
+
+  nsCOMPtr<nsIFile> profD, profLD;
+  bool offline = false;
+  int32_t dialogReturn;
+
+  {
+    ScopedXPCOMStartup xpcom;
+    rv = xpcom.Initialize();
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = xpcom.SetWindowCreator(aNative);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+#ifdef XP_MACOSX
+    CommandLineServiceMac::SetupMacCommandLine(gRestartArgc, gRestartArgv,
+                                               true);
+#endif
+
+    {  // extra scoping is needed so we release these components before xpcom
+       // shutdown
+      nsCOMPtr<nsIWindowWatcher> windowWatcher(
+          do_GetService(NS_WINDOWWATCHER_CONTRACTID));
+      nsCOMPtr<nsIDialogParamBlock> ioParamBlock(
+          do_CreateInstance(NS_DIALOGPARAMBLOCK_CONTRACTID));
+      nsCOMPtr<nsIMutableArray> dlgArray(
+          do_CreateInstance(NS_ARRAY_CONTRACTID));
+      NS_ENSURE_TRUE(windowWatcher && ioParamBlock && dlgArray,
+                     NS_ERROR_FAILURE);
+
+      ioParamBlock->SetObjects(dlgArray);
+
+      nsCOMPtr<nsIAppStartup> appStartup(components::AppStartup::Service());
+      NS_ENSURE_TRUE(appStartup, NS_ERROR_FAILURE);
+
+      nsCOMPtr<mozIDOMWindowProxy> newWindow;
+      rv = windowWatcher->OpenWindow(
+          nullptr, nsDependentCString(kProfileManagerURL), "_blank"_ns,
+          "centerscreen,chrome,modal,titlebar"_ns, ioParamBlock,
+          getter_AddRefs(newWindow));
+
+      NS_ENSURE_SUCCESS_LOG(rv, rv);
+
+      rv = ioParamBlock->GetInt(0, &dialogReturn);
+      if (NS_FAILED(rv) || dialogReturn == nsIToolkitProfileService::exit) {
+        return NS_ERROR_ABORT;
+      }
+
+      int32_t startOffline;
+      rv = ioParamBlock->GetInt(1, &startOffline);
+      offline = NS_SUCCEEDED(rv) && startOffline == 1;
+
+      rv = dlgArray->QueryElementAt(0, NS_GET_IID(nsIFile),
+                                    getter_AddRefs(profD));
+      NS_ENSURE_SUCCESS_LOG(rv, rv);
+
+      rv = dlgArray->QueryElementAt(1, NS_GET_IID(nsIFile),
+                                    getter_AddRefs(profLD));
+      NS_ENSURE_SUCCESS_LOG(rv, rv);
+    }
+  }
+
+  if (offline) {
+    SaveToEnv("XRE_START_OFFLINE=1");
+  }
+
+  // User requested that we restart back into the profile manager.
+  if (dialogReturn == nsIToolkitProfileService::restart) {
+    SaveToEnv("XRE_RESTART_TO_PROFILE_MANAGER=1");
+    SaveToEnv("XRE_RESTARTED_BY_PROFILE_MANAGER=1");
+  } else {
+    MOZ_ASSERT(dialogReturn == nsIToolkitProfileService::launchWithProfile);
+    SaveFileToEnv("XRE_PROFILE_PATH", profD);
+    SaveFileToEnv("XRE_PROFILE_LOCAL_PATH", profLD);
+    SaveToEnv("XRE_RESTARTED_BY_PROFILE_MANAGER=1");
+  }
+
+  if (gRestartedByOS) {
+    // Re-add this argument when actually starting the application.
+    char** newArgv =
+        (char**)realloc(gRestartArgv, sizeof(char*) * (gRestartArgc + 2));
+    NS_ENSURE_TRUE(newArgv, NS_ERROR_OUT_OF_MEMORY);
+    gRestartArgv = newArgv;
+    gRestartArgv[gRestartArgc++] = const_cast<char*>("-os-restarted");
+    gRestartArgv[gRestartArgc] = nullptr;
+  }
+
+  return LaunchChild(false);
+}
+
+static bool gDoMigration = false;
+static bool gDoProfileReset = false;
+static nsCOMPtr<nsIToolkitProfile> gResetOldProfile;
+
+static nsresult LockProfile(nsINativeAppSupport* aNative, nsIFile* aRootDir,
+                            nsIFile* aLocalDir, nsIToolkitProfile* aProfile,
+                            nsIProfileLock** aResult) {
+  // If you close Firefox and very quickly reopen it, the old Firefox may
+  // still be closing down. Rather than immediately showing the
+  // "Firefox is running but is not responding" message, we spend a few
+  // seconds retrying first.
+
+  static const int kLockRetrySeconds = 5;
+  static const int kLockRetrySleepMS = 100;
+
+  nsresult rv;
+  nsCOMPtr<nsIProfileUnlocker> unlocker;
+  const TimeStamp start = TimeStamp::Now();
+  do {
+    if (aProfile) {
+      rv = aProfile->Lock(getter_AddRefs(unlocker), aResult);
+    } else {
+      rv = NS_LockProfilePath(aRootDir, aLocalDir, getter_AddRefs(unlocker),
+                              aResult);
+    }
+    if (NS_SUCCEEDED(rv)) {
+      StartupTimeline::Record(StartupTimeline::AFTER_PROFILE_LOCKED);
+      return NS_OK;
+    }
+    PR_Sleep(kLockRetrySleepMS);
+  } while (TimeStamp::Now() - start <
+           TimeDuration::FromSeconds(kLockRetrySeconds));
+
+  return ProfileLockedDialog(aRootDir, aLocalDir, unlocker, aNative, aResult);
+}
+
+// Pick a profile. We need to end up with a profile root dir, local dir and
+// potentially an nsIToolkitProfile instance.
+//
+// 1) check for --profile <path>
+// 2) check for -P <name>
+// 3) check for --ProfileManager
+// 4) use the default profile, if there is one
+// 5) if there are *no* profiles, set up profile-migration
+// 6) display the profile-manager UI
+static nsresult SelectProfile(nsToolkitProfileService* aProfileSvc,
+                              nsINativeAppSupport* aNative, nsIFile** aRootDir,
+                              nsIFile** aLocalDir, nsIToolkitProfile** aProfile,
+                              bool* aWasDefaultSelection) {
+  StartupTimeline::Record(StartupTimeline::SELECT_PROFILE);
+
+  nsresult rv;
+
+  if (EnvHasValue("MOZ_RESET_PROFILE_RESTART")) {
+    gDoProfileReset = true;
+    gDoMigration = true;
+    SaveToEnv("MOZ_RESET_PROFILE_RESTART=");
+    // We only want to restore the previous session if the profile refresh was
+    // triggered by user. And if it was a user-triggered profile refresh
+    // through, say, the safeMode dialog or the troubleshooting page, the
+    // MOZ_RESET_PROFILE_RESTART env variable would be set. Hence we set
+    // MOZ_RESET_PROFILE_MIGRATE_SESSION here so that Firefox profile migrator
+    // would migrate old session data later.
+    SaveToEnv("MOZ_RESET_PROFILE_MIGRATE_SESSION=1");
+  }
+
+  // reset-profile and migration args need to be checked before any profiles are
+  // chosen below.
+  ArgResult ar = CheckArg("reset-profile");
+  if (ar == ARG_FOUND) {
+    gDoProfileReset = true;
+  }
+
+  ar = CheckArg("migration");
+  if (ar == ARG_FOUND) {
+    gDoMigration = true;
+  }
+
+#if defined(XP_WIN)
+  // This arg is only used to indicate to telemetry that a profile refresh
+  // (reset+migration) was requested from the uninstaller, pass this along
+  // via an environment variable for simplicity.
+  ar = CheckArg("uninstaller-profile-refresh");
+  if (ar == ARG_FOUND) {
+    SaveToEnv("MOZ_UNINSTALLER_PROFILE_REFRESH=1");
+  }
+#endif
+
+  if (EnvHasValue("XRE_RESTART_TO_PROFILE_MANAGER")) {
+    return ShowProfileManager(aProfileSvc, aNative);
+  }
+
+  // Ask the profile manager to select the profile directories to use.
+  bool didCreate = false;
+  rv = aProfileSvc->SelectStartupProfile(&gArgc, gArgv, gDoProfileReset,
+                                         aRootDir, aLocalDir, aProfile,
+                                         &didCreate, aWasDefaultSelection);
+
+  if (rv == NS_ERROR_SHOW_PROFILE_MANAGER) {
+    return ShowProfileManager(aProfileSvc, aNative);
+  }
+
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (didCreate) {
+    // For a fresh install, we would like to let users decide
+    // to do profile migration on their own later after using.
+    gDoProfileReset = false;
+    gDoMigration = false;
+  }
+
+  if (gDoProfileReset && !*aProfile) {
+    NS_WARNING("Profile reset is only supported for named profiles.");
+    return NS_ERROR_ABORT;
+  }
+
+  // No profile could be found. This generally shouldn't happen, a new profile
+  // should be created in all cases except for profile reset which is covered
+  // above, but just in case...
+  if (!*aRootDir) {
+    NS_WARNING("Failed to select or create profile.");
+    return NS_ERROR_ABORT;
+  }
+
+  return NS_OK;
+}
+
+#ifdef MOZ_BLOCK_PROFILE_DOWNGRADE
+struct FileWriteFunc : public JSONWriteFunc {
+  FILE* mFile;
+  explicit FileWriteFunc(FILE* aFile) : mFile(aFile) {}
+
+  void Write(const Span<const char>& aStr) override {
+    fprintf(mFile, "%.*s", int(aStr.size()), aStr.data());
+  }
+};
+
+static void SubmitDowngradeTelemetry(const nsCString& aLastVersion,
+                                     bool aHasSync, int32_t aButton) {
+  nsCOMPtr<nsIPrefService> prefSvc =
+      do_GetService("@mozilla.org/preferences-service;1");
+  NS_ENSURE_TRUE_VOID(prefSvc);
+
+  nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(prefSvc);
+  NS_ENSURE_TRUE_VOID(prefBranch);
+
+  bool enabled;
+  nsresult rv =
+      prefBranch->GetBoolPref(kPrefHealthReportUploadEnabled, &enabled);
+  NS_ENSURE_SUCCESS_VOID(rv);
+  if (!enabled) {
+    return;
+  }
+
+  nsCString server;
+  rv = prefBranch->GetCharPref("toolkit.telemetry.server", server);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsCString clientId;
+  rv = prefBranch->GetCharPref("toolkit.telemetry.cachedClientID", clientId);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  rv = prefSvc->GetDefaultBranch(nullptr, getter_AddRefs(prefBranch));
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsCString channel("default");
+  rv = prefBranch->GetCharPref("app.update.channel", channel);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsID uuid;
+  nsCOMPtr<nsIUUIDGenerator> uuidGen =
+      do_GetService("@mozilla.org/uuid-generator;1");
+  NS_ENSURE_TRUE_VOID(uuidGen);
+  rv = uuidGen->GenerateUUIDInPlace(&uuid);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  char strid[NSID_LENGTH];
+  uuid.ToProvidedString(strid);
+
+  nsCString arch("null");
+  nsCOMPtr<nsIPropertyBag2> sysInfo =
+      do_GetService("@mozilla.org/system-info;1");
+  NS_ENSURE_TRUE_VOID(sysInfo);
+  sysInfo->GetPropertyAsACString(u"arch"_ns, arch);
+
+  time_t now;
+  time(&now);
+  char date[sizeof "YYYY-MM-DDThh:mm:ss.000Z"];
+  strftime(date, sizeof date, "%FT%T.000Z", gmtime(&now));
+
+  // NSID_LENGTH includes the trailing \0 and we also want to strip off the
+  // surrounding braces so the length becomes NSID_LENGTH - 3.
+  nsDependentCSubstring pingId(strid + 1, NSID_LENGTH - 3);
+  constexpr auto pingType = "downgrade"_ns;
+
+  int32_t pos = aLastVersion.Find("_");
+  if (pos == kNotFound) {
+    return;
+  }
+
+  const nsDependentCSubstring lastVersion = Substring(aLastVersion, 0, pos);
+  const nsDependentCSubstring lastBuildId =
+      Substring(aLastVersion, pos + 1, 14);
+
+  nsPrintfCString url("%s/submit/telemetry/%s/%s/%s/%s/%s/%s?v=%d",
+                      server.get(), PromiseFlatCString(pingId).get(),
+                      pingType.get(), (const char*)gAppData->name,
+                      (const char*)gAppData->version, channel.get(),
+                      (const char*)gAppData->buildID,
+                      TELEMETRY_PING_FORMAT_VERSION);
+
+  nsCOMPtr<nsIFile> pingFile;
+  rv = NS_GetSpecialDirectory(XRE_USER_APP_DATA_DIR, getter_AddRefs(pingFile));
+  NS_ENSURE_SUCCESS_VOID(rv);
+  rv = pingFile->Append(u"Pending Pings"_ns);
+  NS_ENSURE_SUCCESS_VOID(rv);
+  rv = pingFile->Create(nsIFile::DIRECTORY_TYPE, 0755);
+  if (NS_FAILED(rv) && rv != NS_ERROR_FILE_ALREADY_EXISTS) {
+    return;
+  }
+  rv = pingFile->Append(NS_ConvertUTF8toUTF16(pingId));
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  nsCOMPtr<nsIFile> pingSender;
+  rv = NS_GetSpecialDirectory(NS_GRE_BIN_DIR, getter_AddRefs(pingSender));
+  NS_ENSURE_SUCCESS_VOID(rv);
+#  ifdef XP_WIN
+  pingSender->Append(u"pingsender.exe"_ns);
+#  else
+  pingSender->Append(u"pingsender"_ns);
+#  endif
+
+  bool exists;
+  rv = pingSender->Exists(&exists);
+  NS_ENSURE_SUCCESS_VOID(rv);
+  if (!exists) {
+    return;
+  }
+
+  FILE* file;
+  rv = pingFile->OpenANSIFileDesc("w", &file);
+  NS_ENSURE_SUCCESS_VOID(rv);
+
+  JSONWriter w(MakeUnique<FileWriteFunc>(file));
+  w.Start();
+  {
+    w.StringProperty("type",
+                     Span<const char>(pingType.Data(), pingType.Length()));
+    w.StringProperty("id", PromiseFlatCString(pingId));
+    w.StringProperty("creationDate", MakeStringSpan(date));
+    w.IntProperty("version", TELEMETRY_PING_FORMAT_VERSION);
+    w.StringProperty("clientId", clientId);
+    w.StartObjectProperty("application");
+    {
+      w.StringProperty("architecture", arch);
+      w.StringProperty(
+          "buildId",
+          MakeStringSpan(static_cast<const char*>(gAppData->buildID)));
+      w.StringProperty(
+          "name", MakeStringSpan(static_cast<const char*>(gAppData->name)));
+      w.StringProperty(
+          "version",
+          MakeStringSpan(static_cast<const char*>(gAppData->version)));
+      w.StringProperty("displayVersion",
+                       MOZ_STRINGIFY(MOZ_APP_VERSION_DISPLAY));
+      w.StringProperty(
+          "vendor", MakeStringSpan(static_cast<const char*>(gAppData->vendor)));
+      w.StringProperty("platformVersion", gToolkitVersion);
+#  ifdef TARGET_XPCOM_ABI
+      w.StringProperty("xpcomAbi", TARGET_XPCOM_ABI);
+#  else
+      w.StringProperty("xpcomAbi", "unknown");
+#  endif
+      w.StringProperty("channel", channel);
+    }
+    w.EndObject();
+    w.StartObjectProperty("payload");
+    {
+      w.StringProperty("lastVersion", PromiseFlatCString(lastVersion));
+      w.StringProperty("lastBuildId", PromiseFlatCString(lastBuildId));
+      w.BoolProperty("hasSync", aHasSync);
+      w.IntProperty("button", aButton);
+    }
+    w.EndObject();
+  }
+  w.End();
+
+  fclose(file);
+
+  PathString filePath = pingFile->NativePath();
+  const filesystem::Path::value_type* args[2];
+#  ifdef XP_WIN
+  nsString urlw = NS_ConvertUTF8toUTF16(url);
+  args[0] = urlw.get();
+#  else
+  args[0] = url.get();
+#  endif
+  args[1] = filePath.get();
+
+  nsCOMPtr<nsIProcess> process =
+      do_CreateInstance("@mozilla.org/process/util;1");
+  NS_ENSURE_TRUE_VOID(process);
+  process->Init(pingSender);
+  process->SetStartHidden(true);
+  process->SetNoShell(true);
+
+#  ifdef XP_WIN
+  process->Runw(false, args, 2);
+#  else
+  process->Run(false, args, 2);
+#  endif
+}
+
+static const char kProfileDowngradeURL[] =
+    "chrome://mozapps/content/profile/profileDowngrade.xhtml";
+
+static ReturnAbortOnError CheckDowngrade(nsIFile* aProfileDir,
+                                         nsINativeAppSupport* aNative,
+                                         nsIToolkitProfileService* aProfileSvc,
+                                         const nsCString& aLastVersion) {
+  int32_t result = 0;
+  nsresult rv;
+
+  {
+    if (gfxPlatform::IsHeadless()) {
+      // TODO: make a way to turn off all dialogs when headless.
+      Output(true,
+             "This profile was last used with a newer version of this "
+             "application. Please create a new profile.\n");
+      return NS_ERROR_ABORT;
+    }
+
+    ScopedXPCOMStartup xpcom;
+    rv = xpcom.Initialize();
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = xpcom.SetWindowCreator(aNative);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    {  // extra scoping is needed so we release these components before xpcom
+       // shutdown
+      bool hasSync = false;
+      nsCOMPtr<nsIPrefService> prefSvc =
+          do_GetService("@mozilla.org/preferences-service;1");
+      NS_ENSURE_TRUE(prefSvc, rv);
+
+      nsCOMPtr<nsIFile> prefsFile;
+      rv = aProfileDir->Clone(getter_AddRefs(prefsFile));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = prefsFile->Append(u"prefs.js"_ns);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      rv = prefSvc->ReadUserPrefsFromFile(prefsFile);
+      if (NS_SUCCEEDED(rv)) {
+        nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(prefSvc);
+
+        rv = prefBranch->PrefHasUserValue("services.sync.username", &hasSync);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
+
+      nsCOMPtr<nsIWindowWatcher> windowWatcher =
+          do_GetService(NS_WINDOWWATCHER_CONTRACTID);
+      NS_ENSURE_TRUE(windowWatcher, NS_ERROR_ABORT);
+
+      nsCOMPtr<nsIAppStartup> appStartup(components::AppStartup::Service());
+      NS_ENSURE_TRUE(appStartup, NS_ERROR_FAILURE);
+
+      nsCOMPtr<nsIDialogParamBlock> paramBlock =
+          do_CreateInstance(NS_DIALOGPARAMBLOCK_CONTRACTID);
+      NS_ENSURE_TRUE(paramBlock, NS_ERROR_ABORT);
+
+      uint8_t flags = 0;
+      if (hasSync) {
+        flags |= nsIToolkitProfileService::hasSync;
+      }
+
+      paramBlock->SetInt(0, flags);
+
+      nsCOMPtr<mozIDOMWindowProxy> newWindow;
+      rv = windowWatcher->OpenWindow(
+          nullptr, nsDependentCString(kProfileDowngradeURL), "_blank"_ns,
+          "centerscreen,chrome,modal,titlebar"_ns, paramBlock,
+          getter_AddRefs(newWindow));
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      paramBlock->GetInt(1, &result);
+
+      SubmitDowngradeTelemetry(aLastVersion, hasSync, result);
+    }
+  }
+
+  if (result == nsIToolkitProfileService::createNewProfile) {
+    // Create a new profile and start it.
+    nsCString profileName;
+    profileName.AssignLiteral("default");
+#  ifdef MOZ_DEDICATED_PROFILES
+    profileName.Append("-" MOZ_STRINGIFY(MOZ_UPDATE_CHANNEL));
+#  endif
+    nsCOMPtr<nsIToolkitProfile> newProfile;
+    rv = aProfileSvc->CreateUniqueProfile(nullptr, profileName,
+                                          getter_AddRefs(newProfile));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = aProfileSvc->SetDefaultProfile(newProfile);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = aProfileSvc->Flush();
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsCOMPtr<nsIFile> profD, profLD;
+    rv = newProfile->GetRootDir(getter_AddRefs(profD));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = newProfile->GetLocalDir(getter_AddRefs(profLD));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    SaveFileToEnv("XRE_PROFILE_PATH", profD);
+    SaveFileToEnv("XRE_PROFILE_LOCAL_PATH", profLD);
+
+    return LaunchChild(false);
+  }
+
+  // Cancel
+  return NS_ERROR_ABORT;
+}
+#endif
+
+/**
+ * Extracts the various parts of a compatibility version string.
+ *
+ * Compatibility versions are of the form
+ * "<appversion>_<appbuildid>/<platformbuildid>". The toolkit version comparator
+ * can only handle 32-bit numbers and in the normal case build IDs are larger
+ * than this. So if the build ID is numeric we split it into two version parts.
+ */
+static void ExtractCompatVersionInfo(const nsACString& aCompatVersion,
+                                     nsACString& aAppVersion,
+                                     nsACString& aAppBuildID) {
+  int32_t underscorePos = aCompatVersion.FindChar('_');
+  int32_t slashPos = aCompatVersion.FindChar('/');
+
+  if (underscorePos == kNotFound || slashPos == kNotFound ||
+      slashPos < underscorePos) {
+    NS_WARNING(
+        "compatibility.ini Version string does not match the expected format.");
+
+    // Fall back to just using the entire string as the version.
+    aAppVersion = aCompatVersion;
+    aAppBuildID.Truncate(0);
+    return;
+  }
+
+  aAppVersion = Substring(aCompatVersion, 0, underscorePos);
+  aAppBuildID = Substring(aCompatVersion, underscorePos + 1,
+                          slashPos - (underscorePos + 1));
+}
+
+/**
+ * Compares the provided compatibility versions. Returns 0 if they match,
+ * < 0 if the new version is considered an upgrade from the old version and
+ * > 0 if the new version is considered a downgrade from the old version.
+ */
+int32_t CompareCompatVersions(const nsACString& aOldCompatVersion,
+                              const nsACString& aNewCompatVersion) {
+  // Hardcode the case where the last run was in safe mode (Bug 1556612). We
+  // cannot tell if this is a downgrade or not so just assume it isn't and let
+  // the user proceed.
+  if (aOldCompatVersion.EqualsLiteral("Safe Mode")) {
+    return -1;
+  }
+
+  // Extract the major version part from the version string and only use that
+  // for version comparison.
+  int32_t index = aOldCompatVersion.FindChar('.');
+  const nsACString& oldMajorVersion = Substring(
+      aOldCompatVersion, 0, index < 0 ? aOldCompatVersion.Length() : index);
+  index = aNewCompatVersion.FindChar('.');
+  const nsACString& newMajorVersion = Substring(
+      aNewCompatVersion, 0, index < 0 ? aNewCompatVersion.Length() : index);
+
+  return CompareVersions(PromiseFlatCString(oldMajorVersion).get(),
+                         PromiseFlatCString(newMajorVersion).get());
+}
+
+/**
+ * Checks the compatibility.ini file to see if we have updated our application
+ * or otherwise invalidated our caches. If the application has been updated,
+ * we return false; otherwise, we return true.
+ *
+ * We also write the status of the caches (valid/invalid) into the return param
+ * aCachesOK. The aCachesOK is always invalid if the application has been
+ * updated.
+ *
+ * Finally, aIsDowngrade is set to true if the current application is older
+ * than that previously used by the profile.
+ */
+static bool CheckCompatibility(nsIFile* aProfileDir, const nsCString& aVersion,
+                               const nsCString& aOSABI, nsIFile* aXULRunnerDir,
+                               nsIFile* aAppDir, nsIFile* aFlagFile,
+                               bool* aCachesOK, bool* aIsDowngrade,
+                               nsCString& aLastVersion) {
+  *aCachesOK = false;
+  *aIsDowngrade = false;
+  gLastAppVersion.SetIsVoid(true);
+  gLastAppBuildID.SetIsVoid(true);
+
+  nsCOMPtr<nsIFile> file;
+  aProfileDir->Clone(getter_AddRefs(file));
+  if (!file) return false;
+  file->AppendNative(FILE_COMPATIBILITY_INFO);
+
+  nsINIParser parser;
+  nsresult rv = parser.Init(file);
+  if (NS_FAILED(rv)) return false;
+
+  rv = parser.GetString("Compatibility", "LastVersion", aLastVersion);
+  if (NS_FAILED(rv)) {
+    return false;
+  }
+
+  if (!aLastVersion.Equals(aVersion)) {
+    // The version is not the same. Whether it's a downgrade depends on an
+    // actual comparison:
+    *aIsDowngrade = 0 < CompareCompatVersions(aLastVersion, aVersion);
+    ExtractCompatVersionInfo(aLastVersion, gLastAppVersion, gLastAppBuildID);
+    return false;
+  }
+
+  // If we get here, the version matched, but there may still be other
+  // differences between us and the build that the profile last ran under.
+
+  gLastAppVersion.Assign(gAppData->version);
+  gLastAppBuildID.Assign(gAppData->buildID);
+
+  nsAutoCString buf;
+  rv = parser.GetString("Compatibility", "LastOSABI", buf);
+  if (NS_FAILED(rv) || !aOSABI.Equals(buf)) return false;
+
+  rv = parser.GetString("Compatibility", "LastPlatformDir", buf);
+  if (NS_FAILED(rv)) return false;
+
+  nsCOMPtr<nsIFile> lf;
+  rv = NS_NewNativeLocalFile(""_ns, false, getter_AddRefs(lf));
+  if (NS_FAILED(rv)) return false;
+
+  rv = lf->SetPersistentDescriptor(buf);
+  if (NS_FAILED(rv)) return false;
+
+  bool eq;
+  rv = lf->Equals(aXULRunnerDir, &eq);
+  if (NS_FAILED(rv) || !eq) return false;
+
+  if (aAppDir) {
+    rv = parser.GetString("Compatibility", "LastAppDir", buf);
+    if (NS_FAILED(rv)) return false;
+
+    rv = NS_NewNativeLocalFile(""_ns, false, getter_AddRefs(lf));
+    if (NS_FAILED(rv)) return false;
+
+    rv = lf->SetPersistentDescriptor(buf);
+    if (NS_FAILED(rv)) return false;
+
+    rv = lf->Equals(aAppDir, &eq);
+    if (NS_FAILED(rv) || !eq) return false;
+  }
+
+  // If we see this flag, caches are invalid.
+  rv = parser.GetString("Compatibility", "InvalidateCaches", buf);
+  *aCachesOK = (NS_FAILED(rv) || !buf.EqualsLiteral("1"));
+
+  bool purgeCaches = false;
+  if (aFlagFile && NS_SUCCEEDED(aFlagFile->Exists(&purgeCaches)) &&
+      purgeCaches) {
+    *aCachesOK = false;
+  }
+
+  return true;
+}
+
+void BuildCompatVersion(const char* aAppVersion, const char* aAppBuildID,
+                        const char* aToolkitBuildID, nsACString& aBuf) {
+  aBuf.Assign(aAppVersion);
+  aBuf.Append('_');
+  aBuf.Append(aAppBuildID);
+  aBuf.Append('/');
+  aBuf.Append(aToolkitBuildID);
+}
+
+static void BuildVersion(nsCString& aBuf) {
+  BuildCompatVersion(gAppData->version, gAppData->buildID, gToolkitBuildID,
+                     aBuf);
+}
+
+static void WriteVersion(nsIFile* aProfileDir, const nsCString& aVersion,
+                         const nsCString& aOSABI, nsIFile* aXULRunnerDir,
+                         nsIFile* aAppDir, bool invalidateCache) {
+  nsCOMPtr<nsIFile> file;
+  aProfileDir->Clone(getter_AddRefs(file));
+  if (!file) return;
+  file->AppendNative(FILE_COMPATIBILITY_INFO);
+
+  nsAutoCString platformDir;
+  Unused << aXULRunnerDir->GetPersistentDescriptor(platformDir);
+
+  nsAutoCString appDir;
+  if (aAppDir) Unused << aAppDir->GetPersistentDescriptor(appDir);
+
+  PRFileDesc* fd;
+  nsresult rv = file->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_TRUNCATE,
+                                       0600, &fd);
+  if (NS_FAILED(rv)) {
+    NS_ERROR("could not create output stream");
+    return;
+  }
+
+  static const char kHeader[] = "[Compatibility]" NS_LINEBREAK "LastVersion=";
+
+  PR_Write(fd, kHeader, sizeof(kHeader) - 1);
+  PR_Write(fd, aVersion.get(), aVersion.Length());
+
+  static const char kOSABIHeader[] = NS_LINEBREAK "LastOSABI=";
+  PR_Write(fd, kOSABIHeader, sizeof(kOSABIHeader) - 1);
+  PR_Write(fd, aOSABI.get(), aOSABI.Length());
+
+  static const char kPlatformDirHeader[] = NS_LINEBREAK "LastPlatformDir=";
+
+  PR_Write(fd, kPlatformDirHeader, sizeof(kPlatformDirHeader) - 1);
+  PR_Write(fd, platformDir.get(), platformDir.Length());
+
+  static const char kAppDirHeader[] = NS_LINEBREAK "LastAppDir=";
+  if (aAppDir) {
+    PR_Write(fd, kAppDirHeader, sizeof(kAppDirHeader) - 1);
+    PR_Write(fd, appDir.get(), appDir.Length());
+  }
+
+  static const char kInvalidationHeader[] = NS_LINEBREAK "InvalidateCaches=1";
+  if (invalidateCache)
+    PR_Write(fd, kInvalidationHeader, sizeof(kInvalidationHeader) - 1);
+
+  static const char kNL[] = NS_LINEBREAK;
+  PR_Write(fd, kNL, sizeof(kNL) - 1);
+
+  PR_Close(fd);
+}
+
+/**
+ * Returns true if the startup cache file was successfully removed.
+ * Returns false if file->Clone fails at any point (OOM) or if unable
+ * to remove the startup cache file. Note in particular the return value
+ * is unaffected by a failure to remove extensions.ini
+ */
+static bool RemoveComponentRegistries(nsIFile* aProfileDir,
+                                      nsIFile* aLocalProfileDir,
+                                      bool aRemoveEMFiles) {
+  nsCOMPtr<nsIFile> file;
+  aProfileDir->Clone(getter_AddRefs(file));
+  if (!file) return false;
+
+  if (aRemoveEMFiles) {
+    file->SetNativeLeafName("extensions.ini"_ns);
+    file->Remove(false);
+  }
+
+  aLocalProfileDir->Clone(getter_AddRefs(file));
+  if (!file) return false;
+
+#if defined(XP_UNIX) || defined(XP_BEOS)
+#  define PLATFORM_FASL_SUFFIX ".mfasl"
+#elif defined(XP_WIN)
+#  define PLATFORM_FASL_SUFFIX ".mfl"
+#endif
+
+  file->AppendNative(nsLiteralCString("XUL" PLATFORM_FASL_SUFFIX));
+  file->Remove(false);
+
+  file->SetNativeLeafName(nsLiteralCString("XPC" PLATFORM_FASL_SUFFIX));
+  file->Remove(false);
+
+  file->SetNativeLeafName("startupCache"_ns);
+  nsresult rv = file->Remove(true);
+  return NS_SUCCEEDED(rv) || rv == NS_ERROR_FILE_TARGET_DOES_NOT_EXIST ||
+         rv == NS_ERROR_FILE_NOT_FOUND;
+}
+
+// When we first initialize the crash reporter we don't have a profile,
+// so we set the minidump path to $TEMP.  Once we have a profile,
+// we set it to $PROFILE/minidumps, creating the directory
+// if needed.
+static void MakeOrSetMinidumpPath(nsIFile* profD) {
+  nsCOMPtr<nsIFile> dumpD;
+  profD->Clone(getter_AddRefs(dumpD));
+
+  if (dumpD) {
+    bool fileExists;
+    // XXX: do some more error checking here
+    dumpD->Append(u"minidumps"_ns);
+    dumpD->Exists(&fileExists);
+    if (!fileExists) {
+      nsresult rv = dumpD->Create(nsIFile::DIRECTORY_TYPE, 0700);
+      NS_ENSURE_SUCCESS_VOID(rv);
+    }
+
+    nsAutoString pathStr;
+    if (NS_SUCCEEDED(dumpD->GetPath(pathStr)))
+      CrashReporter::SetMinidumpPath(pathStr);
+  }
+}
+
+const XREAppData* gAppData = nullptr;
+
+/**
+ * NSPR will search for the "nspr_use_zone_allocator" symbol throughout
+ * the process and use it to determine whether the application defines its own
+ * memory allocator or not.
+ *
+ * Since most applications (e.g. Firefox and Thunderbird) don't use any special
+ * allocators and therefore don't define this symbol, NSPR must search the
+ * entire process, which reduces startup performance.
+ *
+ * By defining the symbol here, we can avoid the wasted lookup and hopefully
+ * improve startup performance.
+ */
+NS_VISIBILITY_DEFAULT PRBool nspr_use_zone_allocator = PR_FALSE;
+
+#ifdef CAIRO_HAS_DWRITE_FONT
+
+#  include <dwrite.h>
+#  include "nsWindowsHelpers.h"
+
+#  ifdef DEBUG_DWRITE_STARTUP
+
+#    define LOGREGISTRY(msg) LogRegistryEvent(msg)
+
+// for use when monitoring process
+static void LogRegistryEvent(const wchar_t* msg) {
+  HKEY dummyKey;
+  HRESULT hr;
+  wchar_t buf[512];
+
+  wsprintf(buf, L" log %s", msg);
+  hr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, buf, 0, KEY_READ, &dummyKey);
+  if (SUCCEEDED(hr)) {
+    RegCloseKey(dummyKey);
+  }
+}
+#  else
+
+#    define LOGREGISTRY(msg)
+
+#  endif
+
+static DWORD WINAPI InitDwriteBG(LPVOID lpdwThreadParam) {
+  SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_BEGIN);
+  LOGREGISTRY(L"loading dwrite.dll");
+  HMODULE dwdll = LoadLibrarySystem32(L"dwrite.dll");
+  if (dwdll) {
+    decltype(DWriteCreateFactory)* createDWriteFactory =
+        (decltype(DWriteCreateFactory)*)GetProcAddress(dwdll,
+                                                       "DWriteCreateFactory");
+    if (createDWriteFactory) {
+      LOGREGISTRY(L"creating dwrite factory");
+      IDWriteFactory* factory;
+      HRESULT hr = createDWriteFactory(DWRITE_FACTORY_TYPE_SHARED,
+                                       __uuidof(IDWriteFactory),
+                                       reinterpret_cast<IUnknown**>(&factory));
+      if (SUCCEEDED(hr)) {
+        LOGREGISTRY(L"dwrite factory done");
+        factory->Release();
+        LOGREGISTRY(L"freed factory");
+      } else {
+        LOGREGISTRY(L"failed to create factory");
+      }
+    }
+  }
+  SetThreadPriority(GetCurrentThread(), THREAD_MODE_BACKGROUND_END);
+  return 0;
+}
+#endif
+
+#ifdef USE_GLX_TEST
+bool fire_glxtest_process();
+#endif
+
+#include "GeckoProfiler.h"
+
+// Encapsulates startup and shutdown state for XRE_main
+class XREMain {
+ public:
+  XREMain()
+      : mStartOffline(false),
+        mShuttingDown(false)
+#ifdef MOZ_HAS_REMOTE
+        ,
+        mDisableRemoteClient(false),
+        mDisableRemoteServer(false)
+#endif
+#if defined(MOZ_WIDGET_GTK)
+        ,
+        mGdkDisplay(nullptr)
+#endif
+            {};
+
+  ~XREMain() {
+    mScopedXPCOM = nullptr;
+    mAppData = nullptr;
+  }
+
+  int XRE_main(int argc, char* argv[], const BootstrapConfig& aConfig);
+  int XRE_mainInit(bool* aExitFlag);
+  int XRE_mainStartup(bool* aExitFlag);
+  nsresult XRE_mainRun();
+
+  Result<bool, nsresult> CheckLastStartupWasCrash();
+
+  nsCOMPtr<nsINativeAppSupport> mNativeApp;
+  RefPtr<nsToolkitProfileService> mProfileSvc;
+  nsCOMPtr<nsIFile> mProfD;
+  nsCOMPtr<nsIFile> mProfLD;
+  nsCOMPtr<nsIProfileLock> mProfileLock;
+#if defined(MOZ_HAS_REMOTE)
+  RefPtr<nsRemoteService> mRemoteService;
+#endif
+
+  UniquePtr<ScopedXPCOMStartup> mScopedXPCOM;
+  UniquePtr<XREAppData> mAppData;
+
+  nsXREDirProvider mDirProvider;
+  nsAutoCString mDesktopStartupID;
+
+  bool mStartOffline;
+  bool mShuttingDown;
+#if defined(MOZ_HAS_REMOTE)
+  bool mDisableRemoteClient;
+  bool mDisableRemoteServer;
+#endif
+
+#if defined(MOZ_WIDGET_GTK)
+  GdkDisplay* mGdkDisplay;
+#endif
+};
+
+#if defined(XP_UNIX) && !defined(ANDROID)
+static SmprintfPointer FormatUid(uid_t aId) {
+  if (const auto pw = getpwuid(aId)) {
+    return mozilla::Smprintf("%s", pw->pw_name);
+  }
+  return mozilla::Smprintf("uid %d", static_cast<int>(aId));
+}
+
+// Bug 1323302: refuse to run under sudo or similar.
+static bool CheckForUserMismatch() {
+  static char const* const kVars[] = {
+      "HOME",
+#  ifdef MOZ_WIDGET_GTK
+      "XDG_RUNTIME_DIR",
+#  endif
+#  ifdef MOZ_X11
+      "XAUTHORITY",
+#  endif
+  };
+
+  const uid_t euid = geteuid();
+  if (euid != 0) {
+    // On Linux it's possible to have superuser capabilities with a
+    // nonzero uid, but anyone who knows enough to make that happen
+    // probably knows enough to debug the resulting problems.
+    // Otherwise, a non-root user can't cause the problems we're
+    // concerned about.
+    return false;
+  }
+
+  for (const auto var : kVars) {
+    if (const auto path = PR_GetEnv(var)) {
+      struct stat st;
+      if (stat(path, &st) == 0) {
+        if (st.st_uid != euid) {
+          const auto owner = FormatUid(st.st_uid);
+          Output(true,
+                 "Running " MOZ_APP_DISPLAYNAME
+                 " as root in a regular"
+                 " user's session is not supported.  ($%s is %s which is"
+                 " owned by %s.)\n",
+                 var, path, owner.get());
+          return true;
+        }
+      }
+    }
+  }
+  return false;
+}
+#else  // !XP_UNIX || ANDROID
+static bool CheckForUserMismatch() { return false; }
+#endif
+
+static void IncreaseDescriptorLimits() {
+#ifdef XP_UNIX
+  // Increase the fd limit to accomodate IPC resources like shared memory.
+  // See also the Darwin case in config/external/nspr/pr/moz.build
+  static const rlim_t kFDs = 4096;
+  struct rlimit rlim;
+
+  if (getrlimit(RLIMIT_NOFILE, &rlim) != 0) {
+    Output(false, "getrlimit: %s\n", strerror(errno));
+    return;
+  }
+  // Don't decrease the limit if it's already high enough, but don't
+  // try to go over the hard limit.  (RLIM_INFINITY isn't required to
+  // be the numerically largest rlim_t, so don't assume that.)
+  if (rlim.rlim_cur != RLIM_INFINITY && rlim.rlim_cur < kFDs &&
+      rlim.rlim_cur < rlim.rlim_max) {
+    if (rlim.rlim_max != RLIM_INFINITY && rlim.rlim_max < kFDs) {
+      rlim.rlim_cur = rlim.rlim_max;
+    } else {
+      rlim.rlim_cur = kFDs;
+    }
+    if (setrlimit(RLIMIT_NOFILE, &rlim) != 0) {
+      Output(false, "setrlimit: %s\n", strerror(errno));
+    }
+  }
+#endif
+}
+
+/*
+ * XRE_mainInit - Initial setup and command line parameter processing.
+ * Main() will exit early if either return value != 0 or if aExitFlag is
+ * true.
+ */
+int XREMain::XRE_mainInit(bool* aExitFlag) {
+  if (!aExitFlag) return 1;
+  *aExitFlag = false;
+
+  atexit(UnexpectedExit);
+  auto expectedShutdown = mozilla::MakeScopeExit([&] { MozExpectedExit(); });
+
+  StartupTimeline::Record(StartupTimeline::MAIN);
+
+  if (CheckForUserMismatch()) {
+    return 1;
+  }
+
+#ifdef XP_MACOSX
+  DisableAppNap();
+#endif
+
+#ifndef ANDROID
+  if (PR_GetEnv("MOZ_RUN_GTEST")
+#  ifdef FUZZING
+      || PR_GetEnv("FUZZER")
+#  endif
+  ) {
+    // Enable headless mode and assert that it worked, since gfxPlatform
+    // uses a static bool set after the first call to `IsHeadless`.
+    // Note: Android gtests seem to require an Activity and fail to start
+    // with headless mode enabled.
+    PR_SetEnv("MOZ_HEADLESS=1");
+    MOZ_ASSERT(gfxPlatform::IsHeadless());
+  }
+#endif  // ANDROID
+
+  if (PR_GetEnv("MOZ_CHAOSMODE")) {
+    ChaosFeature feature = ChaosFeature::Any;
+    long featureInt = strtol(PR_GetEnv("MOZ_CHAOSMODE"), nullptr, 16);
+    if (featureInt) {
+      // NOTE: MOZ_CHAOSMODE=0 or a non-hex value maps to Any feature.
+      feature = static_cast<ChaosFeature>(featureInt);
+    }
+    ChaosMode::SetChaosFeature(feature);
+  }
+
+  if (CheckArgExists("fxr")) {
+    gFxREmbedded = true;
+  }
+
+  if (ChaosMode::isActive(ChaosFeature::Any)) {
+    printf_stderr(
+        "*** You are running in chaos test mode. See ChaosMode.h. ***\n");
+  }
+
+  if (CheckArg("headless") || CheckArgExists("screenshot")) {
+    PR_SetEnv("MOZ_HEADLESS=1");
+  }
+
+  if (gfxPlatform::IsHeadless()) {
+#if defined(XP_WIN) || defined(MOZ_WIDGET_GTK) || defined(XP_MACOSX)
+    printf_stderr("*** You are running in headless mode.\n");
+#else
+    Output(
+        true,
+        "Error: headless mode is not currently supported on this platform.\n");
+    return 1;
+#endif
+
+#ifdef XP_MACOSX
+    // To avoid taking focus when running in headless mode immediately
+    // transition Firefox to a background application.
+    ProcessSerialNumber psn = {0, kCurrentProcess};
+    OSStatus transformStatus =
+        TransformProcessType(&psn, kProcessTransformToBackgroundApplication);
+    if (transformStatus != noErr) {
+      NS_ERROR("Failed to make process a background application.");
+      return 1;
+    }
+#endif
+  }
+
+  nsresult rv;
+  ArgResult ar;
+
+#ifdef DEBUG
+  if (PR_GetEnv("XRE_MAIN_BREAK")) NS_BREAK();
+#endif
+
+  IncreaseDescriptorLimits();
+
+#ifdef USE_GLX_TEST
+  // bug 639842 - it's very important to fire this process BEFORE we set up
+  // error handling. indeed, this process is expected to be crashy, and we
+  // don't want the user to see its crashes. That's the whole reason for
+  // doing this in a separate process.
+  //
+  // This call will cause a fork and the fork will terminate itself separately
+  // from the usual shutdown sequence
+  fire_glxtest_process();
+#endif
+
+  SetupErrorHandling(gArgv[0]);
+
+#ifdef CAIRO_HAS_DWRITE_FONT
+  {
+    // Bug 602792 - when DWriteCreateFactory is called the dwrite client dll
+    // starts the FntCache service if it isn't already running (it's set
+    // to manual startup by default in Windows 7 RTM).  Subsequent DirectWrite
+    // calls cause the IDWriteFactory object to communicate with the FntCache
+    // service with a timeout; if there's no response after the timeout, the
+    // DirectWrite client library will assume the service isn't around and do
+    // manual font file I/O on _all_ system fonts.  To avoid this, load the
+    // dwrite library and create a factory as early as possible so that the
+    // FntCache service is ready by the time it's needed.
+
+    CreateThread(nullptr, 0, &InitDwriteBG, nullptr, 0, nullptr);
+  }
+#endif
+
+#ifdef XP_UNIX
+  const char* home = PR_GetEnv("HOME");
+  if (!home || !*home) {
+    struct passwd* pw = getpwuid(geteuid());
+    if (!pw || !pw->pw_dir) {
+      Output(true, "Could not determine HOME directory");
+      return 1;
+    }
+    SaveWordToEnv("HOME", nsDependentCString(pw->pw_dir));
+  }
+#endif
+
+#ifdef MOZ_ACCESSIBILITY_ATK
+  // Suppress atk-bridge init at startup, until mozilla accessibility is
+  // initialized.  This works after gnome 2.24.2.
+  SaveToEnv("NO_AT_BRIDGE=1");
+#endif
+
+  // Check for application.ini overrides
+  const char* override = nullptr;
+  ar = CheckArg("override", &override);
+  if (ar == ARG_BAD) {
+    Output(true, "Incorrect number of arguments passed to --override");
+    return 1;
+  }
+  if (ar == ARG_FOUND) {
+    nsCOMPtr<nsIFile> overrideLF;
+    rv = XRE_GetFileFromPath(override, getter_AddRefs(overrideLF));
+    if (NS_FAILED(rv)) {
+      Output(true, "Error: unrecognized override.ini path.\n");
+      return 1;
+    }
+
+    rv = XRE_ParseAppData(overrideLF, *mAppData);
+    if (NS_FAILED(rv)) {
+      Output(true, "Couldn't read override.ini");
+      return 1;
+    }
+  }
+
+  // Check sanity and correctness of app data.
+
+  if (!mAppData->name) {
+    Output(true, "Error: App:Name not specified in application.ini\n");
+    return 1;
+  }
+  if (!mAppData->buildID) {
+    Output(true, "Error: App:BuildID not specified in application.ini\n");
+    return 1;
+  }
+
+  // XXX Originally ScopedLogging was here? Now it's in XRE_main above
+  // XRE_mainInit.
+
+  if (!mAppData->minVersion) {
+    Output(true, "Error: Gecko:MinVersion not specified in application.ini\n");
+    return 1;
+  }
+
+  if (!mAppData->maxVersion) {
+    // If no maxVersion is specified, we assume the app is only compatible
+    // with the initial preview release. Do not increment this number ever!
+    mAppData->maxVersion = "1.*";
+  }
+
+  if (mozilla::Version(mAppData->minVersion) > gToolkitVersion ||
+      mozilla::Version(mAppData->maxVersion) < gToolkitVersion) {
+    Output(true,
+           "Error: Platform version '%s' is not compatible with\n"
+           "minVersion >= %s\nmaxVersion <= %s\n",
+           (const char*)gToolkitVersion, (const char*)mAppData->minVersion,
+           (const char*)mAppData->maxVersion);
+    return 1;
+  }
+
+  rv = mDirProvider.Initialize(mAppData->directory, mAppData->xreDirectory);
+  if (NS_FAILED(rv)) return 1;
+
+  if (EnvHasValue("MOZ_CRASHREPORTER")) {
+    mAppData->flags |= NS_XRE_ENABLE_CRASH_REPORTER;
+  }
+
+  nsCOMPtr<nsIFile> xreBinDirectory;
+  xreBinDirectory = mDirProvider.GetGREBinDir();
+
+  if ((mAppData->flags & NS_XRE_ENABLE_CRASH_REPORTER) &&
+      NS_SUCCEEDED(CrashReporter::SetExceptionHandler(xreBinDirectory))) {
+    nsCOMPtr<nsIFile> file;
+    rv = nsXREDirProvider::GetUserAppDataDirectory(getter_AddRefs(file));
+    if (NS_SUCCEEDED(rv)) {
+      CrashReporter::SetUserAppDataDirectory(file);
+    }
+    if (mAppData->crashReporterURL)
+      CrashReporter::SetServerURL(
+          nsDependentCString(mAppData->crashReporterURL));
+
+    // We overwrite this once we finish starting up.
+    CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::StartupCrash,
+                                       true);
+
+    // pass some basic info from the app data
+    if (mAppData->vendor)
+      CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::Vendor,
+                                         nsDependentCString(mAppData->vendor));
+    if (mAppData->name)
+      CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::ProductName,
+                                         nsDependentCString(mAppData->name));
+    if (mAppData->ID)
+      CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::ProductID,
+                                         nsDependentCString(mAppData->ID));
+    if (mAppData->version)
+      CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::Version,
+                                         nsDependentCString(mAppData->version));
+    if (mAppData->buildID)
+      CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::BuildID,
+                                         nsDependentCString(mAppData->buildID));
+
+    nsDependentCString releaseChannel(MOZ_STRINGIFY(MOZ_UPDATE_CHANNEL));
+    CrashReporter::AnnotateCrashReport(
+        CrashReporter::Annotation::ReleaseChannel, releaseChannel);
+#ifdef MOZ_LINKER
+    CrashReporter::AnnotateCrashReport(
+        CrashReporter::Annotation::CrashAddressLikelyWrong,
+        IsSignalHandlingBroken());
+#endif
+
+#ifdef XP_WIN
+    nsAutoString appInitDLLs;
+    if (widget::WinUtils::GetAppInitDLLs(appInitDLLs)) {
+      CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::AppInitDLLs,
+                                         NS_ConvertUTF16toUTF8(appInitDLLs));
+    }
+#endif
+
+    CrashReporter::SetRestartArgs(gArgc, gArgv);
+
+    // annotate other data (user id etc)
+    nsCOMPtr<nsIFile> userAppDataDir;
+    if (NS_SUCCEEDED(mDirProvider.GetUserAppDataDirectory(
+            getter_AddRefs(userAppDataDir)))) {
+      CrashReporter::SetupExtraData(userAppDataDir,
+                                    nsDependentCString(mAppData->buildID));
+
+      // see if we have a crashreporter-override.ini in the application
+      // directory
+      nsCOMPtr<nsIFile> overrideini;
+      if (NS_SUCCEEDED(
+              mDirProvider.GetAppDir()->Clone(getter_AddRefs(overrideini))) &&
+          NS_SUCCEEDED(
+              overrideini->AppendNative("crashreporter-override.ini"_ns))) {
+#ifdef XP_WIN
+        nsAutoString overridePathW;
+        overrideini->GetPath(overridePathW);
+        NS_ConvertUTF16toUTF8 overridePath(overridePathW);
+#else
+        nsAutoCString overridePath;
+        overrideini->GetNativePath(overridePath);
+#endif
+
+        SaveWordToEnv("MOZ_CRASHREPORTER_STRINGS_OVERRIDE", overridePath);
+      }
+    }
+  }
+
+#if defined(MOZ_SANDBOX) && defined(XP_WIN)
+  if (mAppData->sandboxBrokerServices) {
+    SandboxBroker::Initialize(mAppData->sandboxBrokerServices);
+  } else {
+#  if defined(MOZ_SANDBOX)
+    // If we're sandboxing content and we fail to initialize, then crashing here
+    // seems like the sensible option.
+    if (BrowserTabsRemoteAutostart()) {
+      MOZ_CRASH("Failed to initialize broker services, can't continue.");
+    }
+#  endif
+    // Otherwise just warn for the moment, as most things will work.
+    NS_WARNING(
+        "Failed to initialize broker services, sandboxed processes will "
+        "fail to start.");
+  }
+  if (mAppData->sandboxPermissionsService) {
+    SandboxPermissions::Initialize(mAppData->sandboxPermissionsService,
+                                   nullptr);
+  }
+#endif
+
+#ifdef XP_MACOSX
+  // Set up ability to respond to system (Apple) events. This must occur before
+  // ProcessUpdates to ensure that links clicked in external applications aren't
+  // lost when updates are pending.
+  SetupMacApplicationDelegate();
+
+  if (EnvHasValue("MOZ_LAUNCHED_CHILD")) {
+    // This is needed, on relaunch, to force the OS to use the "Cocoa Dock
+    // API".  Otherwise the call to ReceiveNextEvent() below will make it
+    // use the "Carbon Dock API".  For more info see bmo bug 377166.
+    EnsureUseCocoaDockAPI();
+
+    // When the app relaunches, the original process exits.  This causes
+    // the dock tile to stop bouncing, lose the "running" triangle, and
+    // if the tile does not permanently reside in the Dock, even disappear.
+    // This can be confusing to the user, who is expecting the app to launch.
+    // Calling ReceiveNextEvent without requesting any event is enough to
+    // cause a dock tile for the child process to appear.
+    const EventTypeSpec kFakeEventList[] = {{INT_MAX, INT_MAX}};
+    EventRef event;
+    ::ReceiveNextEvent(GetEventTypeCount(kFakeEventList), kFakeEventList,
+                       kEventDurationNoWait, false, &event);
+  }
+
+  if (CheckArg("foreground")) {
+    // The original process communicates that it was in the foreground by
+    // adding this argument.  This new process, which is taking over for
+    // the old one, should make itself the active application.
+    ProcessSerialNumber psn;
+    if (::GetCurrentProcess(&psn) == noErr) ::SetFrontProcess(&psn);
+  }
+#endif
+
+  SaveToEnv("MOZ_LAUNCHED_CHILD=");
+
+  // On Windows, the -os-restarted command line switch lets us know when we are
+  // restarted via RegisterApplicationRestart. May be used for other OSes later.
+  if (CheckArg("os-restarted", nullptr, CheckArgFlag::RemoveArg) == ARG_FOUND) {
+    gRestartedByOS = true;
+  }
+
+  gRestartArgc = gArgc;
+  gRestartArgv =
+      (char**)malloc(sizeof(char*) * (gArgc + 1 + (override ? 2 : 0)));
+  if (!gRestartArgv) {
+    return 1;
+  }
+
+  int i;
+  for (i = 0; i < gArgc; ++i) {
+    gRestartArgv[i] = gArgv[i];
+  }
+
+  // Add the -override argument back (it is removed automatically be CheckArg)
+  // if there is one
+  if (override) {
+    gRestartArgv[gRestartArgc++] = const_cast<char*>("-override");
+    gRestartArgv[gRestartArgc++] = const_cast<char*>(override);
+  }
+
+  gRestartArgv[gRestartArgc] = nullptr;
+
+  Maybe<bool> safeModeRequested = IsSafeModeRequested(gArgc, gArgv);
+  if (!safeModeRequested) {
+    return 1;
+  }
+
+  gSafeMode = safeModeRequested.value();
+
+#ifdef XP_WIN
+  {
+    // Add CPU microcode version to the crash report as "CPUMicrocodeVersion".
+    // It feels like this code may belong in nsSystemInfo instead.
+    int cpuUpdateRevision = -1;
+    HKEY key;
+    static const WCHAR keyName[] =
+        L"HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0";
+
+    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, keyName, 0, KEY_QUERY_VALUE, &key) ==
+        ERROR_SUCCESS) {
+      DWORD updateRevision[2];
+      DWORD len = sizeof(updateRevision);
+      DWORD vtype;
+
+      // Windows 7 uses "Update Signature", 8 uses "Update Revision".
+      // For AMD CPUs, "CurrentPatchLevel" is sometimes used.
+      // Take the first one we find.
+      LPCWSTR choices[] = {L"Update Signature", L"Update Revision",
+                           L"CurrentPatchLevel"};
+      for (size_t oneChoice = 0; oneChoice < ArrayLength(choices);
+           oneChoice++) {
+        if (RegQueryValueExW(key, choices[oneChoice], 0, &vtype,
+                             reinterpret_cast<LPBYTE>(updateRevision),
+                             &len) == ERROR_SUCCESS) {
+          if (vtype == REG_BINARY && len == sizeof(updateRevision)) {
+            // The first word is unused
+            cpuUpdateRevision = static_cast<int>(updateRevision[1]);
+            break;
+          } else if (vtype == REG_DWORD && len == sizeof(updateRevision[0])) {
+            cpuUpdateRevision = static_cast<int>(updateRevision[0]);
+            break;
+          }
+        }
+      }
+    }
+
+    if (cpuUpdateRevision > 0) {
+      CrashReporter::AnnotateCrashReport(
+          CrashReporter::Annotation::CPUMicrocodeVersion,
+          nsPrintfCString("0x%x", cpuUpdateRevision));
+    }
+  }
+#endif
+
+  CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::SafeMode,
+                                     gSafeMode);
+
+#if defined(MOZ_HAS_REMOTE)
+  // Handle --no-remote and --new-instance command line arguments. Setup
+  // the environment to better accommodate other components and various
+  // restart scenarios.
+  ar = CheckArg("no-remote");
+  if (ar == ARG_FOUND || EnvHasValue("MOZ_NO_REMOTE")) {
+    mDisableRemoteClient = true;
+    mDisableRemoteServer = true;
+    if (!EnvHasValue("MOZ_NO_REMOTE")) {
+      SaveToEnv("MOZ_NO_REMOTE=1");
+    }
+  }
+
+  ar = CheckArg("new-instance");
+  if (ar == ARG_FOUND || EnvHasValue("MOZ_NEW_INSTANCE")) {
+    mDisableRemoteClient = true;
+  }
+#else
+  // These arguments do nothing in platforms with no remoting support but we
+  // should remove them from the command line anyway.
+  CheckArg("no-remote");
+  CheckArg("new-instance");
+#endif
+
+  ar = CheckArg("offline");
+  if (ar || EnvHasValue("XRE_START_OFFLINE")) {
+    mStartOffline = true;
+  }
+
+  // Handle --help, --full-version and --version command line arguments.
+  // They should return quickly, so we deal with them here.
+  if (CheckArg("h") || CheckArg("help") || CheckArg("?")) {
+    DumpHelp();
+    *aExitFlag = true;
+    return 0;
+  }
+
+  if (CheckArg("v") || CheckArg("version")) {
+    DumpVersion();
+    *aExitFlag = true;
+    return 0;
+  }
+
+  if (CheckArg("full-version")) {
+    DumpFullVersion();
+    *aExitFlag = true;
+    return 0;
+  }
+
+  rv = XRE_InitCommandLine(gArgc, gArgv);
+  NS_ENSURE_SUCCESS(rv, 1);
+
+  return 0;
+}
+
+#ifdef XP_WIN
+static bool QueryOneWMIProperty(IWbemServices* aServices,
+                                const wchar_t* aWMIClass,
+                                const wchar_t* aProperty, VARIANT* aResult) {
+  RefPtr<IEnumWbemClassObject> enumerator;
+
+  _bstr_t query(L"SELECT * FROM ");
+  query += _bstr_t(aWMIClass);
+
+  HRESULT hr = aServices->ExecQuery(
+      _bstr_t(L"WQL"), query,
+      WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, nullptr,
+      getter_AddRefs(enumerator));
+
+  if (FAILED(hr) || !enumerator) {
+    return false;
+  }
+
+  RefPtr<IWbemClassObject> classObject;
+  ULONG results;
+
+  hr =
+      enumerator->Next(WBEM_INFINITE, 1, getter_AddRefs(classObject), &results);
+
+  if (FAILED(hr) || results == 0) {
+    return false;
+  }
+
+  hr = classObject->Get(aProperty, 0, aResult, 0, 0);
+
+  return SUCCEEDED(hr);
+}
+
+/**
+ * Uses WMI to read some information that may be useful for diagnosing
+ * crashes. This function is best-effort; failures shouldn't burden the
+ * caller. COM must be initialized before calling.
+ */
+
+static const char kMemoryErrorCorrectionValues[][15] = {
+    "Reserved",        // 0
+    "Other",           // 1
+    "Unknown",         // 2
+    "None",            // 3
+    "Parity",          // 4
+    "Single-bit ECC",  // 5
+    "Multi-bit ECC",   // 6
+    "CRC"              // 7
+};
+
+static void AnnotateWMIData() {
+  RefPtr<IWbemLocator> locator;
+
+  HRESULT hr =
+      CoCreateInstance(CLSID_WbemLocator, nullptr, CLSCTX_INPROC_SERVER,
+                       IID_IWbemLocator, getter_AddRefs(locator));
+
+  if (FAILED(hr)) {
+    return;
+  }
+
+  RefPtr<IWbemServices> services;
+
+  hr =
+      locator->ConnectServer(_bstr_t(L"ROOT\\CIMV2"), nullptr, nullptr, nullptr,
+                             0, nullptr, nullptr, getter_AddRefs(services));
+
+  if (FAILED(hr)) {
+    return;
+  }
+
+  hr = CoSetProxyBlanket(services, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, nullptr,
+                         RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE,
+                         nullptr, EOAC_NONE);
+
+  if (FAILED(hr)) {
+    return;
+  }
+
+  VARIANT value;
+  VariantInit(&value);
+
+  // Annotate information about the system manufacturer.
+  if (QueryOneWMIProperty(services, L"Win32_BIOS", L"Manufacturer", &value) &&
+      V_VT(&value) == VT_BSTR) {
+    CrashReporter::AnnotateCrashReport(
+        CrashReporter::Annotation::BIOS_Manufacturer,
+        NS_ConvertUTF16toUTF8(V_BSTR(&value)));
+  }
+
+  VariantClear(&value);
+
+  // Annotate information about type of memory error correction.
+  if (QueryOneWMIProperty(services, L"Win32_PhysicalMemoryArray",
+                          L"MemoryErrorCorrection", &value) &&
+      V_VT(&value) == VT_I4) {
+    long valueInt = V_I4(&value);
+    nsCString valueString;
+    if (valueInt < 0 ||
+        valueInt >= long(ArrayLength(kMemoryErrorCorrectionValues))) {
+      valueString.AssignLiteral("Unexpected value");
+    } else {
+      valueString.AssignASCII(kMemoryErrorCorrectionValues[valueInt]);
+    }
+    CrashReporter::AnnotateCrashReport(
+        CrashReporter::Annotation::MemoryErrorCorrection, valueString);
+  }
+
+  VariantClear(&value);
+}
+
+static void PR_CALLBACK AnnotateWMIData_ThreadStart(void*) {
+  mscom::MTARegion mta;
+  if (!mta.IsValid()) {
+    return;
+  }
+
+  AnnotateWMIData();
+}
+#endif  // XP_WIN
+
+#if defined(XP_LINUX) && !defined(ANDROID)
+
+static void AnnotateLSBRelease(void*) {
+  nsCString dist, desc, release, codename;
+  if (widget::lsb::GetLSBRelease(dist, desc, release, codename)) {
+    CrashReporter::AppendAppNotesToCrashReport(desc);
+  }
+}
+
+#endif  // defined(XP_LINUX) && !defined(ANDROID)
+
+#ifdef XP_WIN
+static void ReadAheadSystemDll(const wchar_t* dllName) {
+  wchar_t dllPath[MAX_PATH];
+  if (ConstructSystem32Path(dllName, dllPath, MAX_PATH)) {
+    ReadAheadLib(dllPath);
+  }
+}
+
+static void ReadAheadPackagedDll(const wchar_t* dllName,
+                                 const wchar_t* aGREDir) {
+  wchar_t dllPath[MAX_PATH];
+  swprintf(dllPath, MAX_PATH, L"%s\\%s", aGREDir, dllName);
+  ReadAheadLib(dllPath);
+}
+
+static void PR_CALLBACK ReadAheadDlls_ThreadStart(void* arg) {
+  UniquePtr<wchar_t[]> greDir(static_cast<wchar_t*>(arg));
+
+  // In Bug 1628903, we investigated which DLLs we should prefetch in
+  // order to reduce disk I/O and improve startup on Windows machines.
+  // Our ultimate goal is to measure the impact of these improvements on
+  // retention (see Bug 1640087). Before we place this within a pref,
+  // we should ensure this feature only ships to the nightly channel
+  // and monitor results from that subset.
+  if (greDir) {
+    // Prefetch the DLLs shipped with firefox
+    ReadAheadPackagedDll(L"libegl.dll", greDir.get());
+    ReadAheadPackagedDll(L"libGLESv2.dll", greDir.get());
+    ReadAheadPackagedDll(L"nssckbi.dll", greDir.get());
+    ReadAheadPackagedDll(L"freebl3.dll", greDir.get());
+    ReadAheadPackagedDll(L"softokn3.dll", greDir.get());
+
+    // Prefetch the system DLLs
+    ReadAheadSystemDll(L"DWrite.dll");
+    ReadAheadSystemDll(L"D3DCompiler_47.dll");
+  } else {
+    // Load DataExchange.dll and twinapi.appcore.dll for
+    // nsWindow::EnableDragDrop
+    ReadAheadSystemDll(L"DataExchange.dll");
+    ReadAheadSystemDll(L"twinapi.appcore.dll");
+
+    // Load twinapi.dll for WindowsUIUtils::UpdateTabletModeState
+    ReadAheadSystemDll(L"twinapi.dll");
+
+    // Load explorerframe.dll for WinTaskbar::Initialize
+    ReadAheadSystemDll(L"ExplorerFrame.dll");
+
+    // Load WinTypes.dll for nsOSHelperAppService::GetApplicationDescription
+    ReadAheadSystemDll(L"WinTypes.dll");
+  }
+}
+#endif
+
+#if defined(MOZ_WAYLAND)
+bool IsWaylandDisabled() {
+  // MOZ_ENABLE_WAYLAND is our primary Wayland on/off switch.
+  const char* waylandPref = PR_GetEnv("MOZ_ENABLE_WAYLAND");
+  bool enableWayland = (waylandPref && *waylandPref);
+  if (!enableWayland) {
+    const char* backendPref = PR_GetEnv("GDK_BACKEND");
+    enableWayland = (backendPref && strncmp(backendPref, "wayland", 7) == 0);
+    if (enableWayland) {
+      NS_WARNING(
+          "Wayland backend should be enabled by MOZ_ENABLE_WAYLAND=1."
+          "GDK_BACKEND is a Gtk3 debug variable and may cause various issues.");
+    }
+  }
+  if (enableWayland && gtk_check_version(3, 22, 0) != nullptr) {
+    NS_WARNING("Running Wayland backen on Gtk3 < 3.22. Expect issues/glitches");
+  }
+  return !enableWayland;
+}
+#endif
+
+namespace mozilla::startup {
+Result<nsCOMPtr<nsIFile>, nsresult> GetIncompleteStartupFile(nsIFile* aProfLD) {
+  nsCOMPtr<nsIFile> crashFile;
+  MOZ_TRY(aProfLD->Clone(getter_AddRefs(crashFile)));
+  MOZ_TRY(crashFile->Append(FILE_STARTUP_INCOMPLETE));
+  return std::move(crashFile);
+}
+}  // namespace mozilla::startup
+
+// Check whether the last startup attempt resulted in a crash within the
+// last 6 hours.
+// Note that this duplicates the logic in nsAppStartup::TrackStartupCrashBegin,
+// which runs too late for our purposes.
+Result<bool, nsresult> XREMain::CheckLastStartupWasCrash() {
+  constexpr int32_t MAX_TIME_SINCE_STARTUP = 6 * 60 * 60 * 1000;
+
+  nsCOMPtr<nsIFile> crashFile;
+  MOZ_TRY_VAR(crashFile, GetIncompleteStartupFile(mProfLD));
+
+  // Attempt to create the incomplete startup canary file. If the file already
+  // exists, this fails, and we know the last startup was a success. If it
+  // doesn't already exist, it is created, and will be removed at the end of
+  // the startup crash detection window.
+  AutoFDClose fd;
+  Unused << crashFile->OpenNSPRFileDesc(PR_WRONLY | PR_CREATE_FILE | PR_EXCL,
+                                        0666, &fd.rwget());
+  if (fd) {
+    return false;
+  }
+
+  PRTime lastModifiedTime;
+  MOZ_TRY(crashFile->GetLastModifiedTime(&lastModifiedTime));
+
+  // If the file exists, and was created within the appropriate time window,
+  // the last startup was recent and resulted in a crash.
+  PRTime now = PR_Now() / PR_USEC_PER_MSEC;
+  return now - lastModifiedTime <= MAX_TIME_SINCE_STARTUP;
+}
+
+/*
+ * XRE_mainStartup - Initializes the profile and various other services.
+ * Main() will exit early if either return value != 0 or if aExitFlag is
+ * true.
+ */
+int XREMain::XRE_mainStartup(bool* aExitFlag) {
+  nsresult rv;
+
+  if (!aExitFlag) return 1;
+  *aExitFlag = false;
+
+  // Enable Telemetry IO Reporting on DEBUG, nightly and local builds,
+  // but disable it on FUZZING builds.
+#ifndef FUZZING
+#  ifdef DEBUG
+  mozilla::Telemetry::InitIOReporting(gAppData->xreDirectory);
+#  else
+  {
+    const char* releaseChannel = MOZ_STRINGIFY(MOZ_UPDATE_CHANNEL);
+    if (strcmp(releaseChannel, "nightly") == 0 ||
+        strcmp(releaseChannel, "default") == 0) {
+      mozilla::Telemetry::InitIOReporting(gAppData->xreDirectory);
+    }
+  }
+#  endif /* DEBUG */
+#endif /* FUZZING */
+
+#if defined(XP_WIN)
+  // Enable the HeapEnableTerminationOnCorruption exploit mitigation. We ignore
+  // the return code because it always returns success, although it has no
+  // effect on Windows older than XP SP3.
+  HeapSetInformation(NULL, HeapEnableTerminationOnCorruption, NULL, 0);
+#endif /* XP_WIN */
+
+#if defined(MOZ_WIDGET_GTK)
+  // Stash DESKTOP_STARTUP_ID in malloc'ed memory because gtk_init will clear
+  // it.
+#  define HAVE_DESKTOP_STARTUP_ID
+  const char* desktopStartupIDEnv = PR_GetEnv("DESKTOP_STARTUP_ID");
+  if (desktopStartupIDEnv) {
+    mDesktopStartupID.Assign(desktopStartupIDEnv);
+  }
+#endif
+
+#if defined(MOZ_WIDGET_GTK)
+  // setup for private colormap.  Ideally we'd like to do this
+  // in nsAppShell::Create, but we need to get in before gtk
+  // has been initialized to make sure everything is running
+  // consistently.
+
+  // Set program name to the one defined in application.ini.
+  {
+    nsAutoCString program(gAppData->name);
+    ToLowerCase(program);
+    g_set_prgname(program.get());
+  }
+
+  // Initialize GTK here for splash.
+
+#  if defined(MOZ_WIDGET_GTK) && defined(MOZ_X11)
+  // Disable XInput2 multidevice support due to focus bugginess.
+  // See bugs 1182700, 1170342.
+  // gdk_disable_multidevice() affects Gdk X11 backend only,
+  // the multidevice support is always enabled on Wayland backend.
+  const char* useXI2 = PR_GetEnv("MOZ_USE_XINPUT2");
+  if (!useXI2 || (*useXI2 == '0')) gdk_disable_multidevice();
+#  endif
+
+  // Open the display ourselves instead of using gtk_init, so that we can
+  // close it without fear that one day gtk might clean up the display it
+  // opens.
+  if (!gtk_parse_args(&gArgc, &gArgv)) return 1;
+#endif /* MOZ_WIDGET_GTK */
+
+#ifdef FUZZING
+  if (PR_GetEnv("FUZZER")) {
+    *aExitFlag = true;
+    return mozilla::fuzzerRunner->Run(&gArgc, &gArgv);
+  }
+#endif
+
+  if (PR_GetEnv("MOZ_RUN_GTEST")) {
+    int result;
+#ifdef XP_WIN
+    UseParentConsole();
+#endif
+    // RunGTest will only be set if we're in xul-unit
+    if (mozilla::RunGTest) {
+      gIsGtest = true;
+      result = mozilla::RunGTest(&gArgc, gArgv);
+      gIsGtest = false;
+    } else {
+      result = 1;
+      printf("TEST-UNEXPECTED-FAIL | gtest | Not compiled with enable-tests\n");
+    }
+    *aExitFlag = true;
+    return result;
+  }
+
+#ifdef MOZ_HAS_REMOTE
+  if (gfxPlatform::IsHeadless()) {
+    mDisableRemoteClient = true;
+    mDisableRemoteServer = true;
+  }
+#endif
+
+#ifdef MOZ_X11
+  // Init X11 in thread-safe mode. Must be called prior to the first call to
+  // XOpenDisplay (called inside gdk_display_open). This is a requirement for
+  // off main tread compositing.
+  if (!gfxPlatform::IsHeadless()) {
+    XInitThreads();
+  }
+#endif
+#if defined(MOZ_WIDGET_GTK)
+  if (!gfxPlatform::IsHeadless()) {
+    const char* display_name = nullptr;
+    bool saveDisplayArg = false;
+
+    // display_name is owned by gdk.
+    display_name = gdk_get_display_arg_name();
+    // if --display argument is given make sure it's
+    // also passed to ContentChild::Init() by MOZ_GDK_DISPLAY.
+    if (display_name) {
+      SaveWordToEnv("MOZ_GDK_DISPLAY", nsDependentCString(display_name));
+      saveDisplayArg = true;
+    }
+
+    bool disableWayland = true;
+#  if defined(MOZ_WAYLAND)
+    disableWayland = IsWaylandDisabled();
+#  endif
+    // On Wayland disabled builds read X11 DISPLAY env exclusively
+    // and don't care about different displays.
+    if (disableWayland && !display_name) {
+      display_name = PR_GetEnv("DISPLAY");
+      if (!display_name) {
+        PR_fprintf(PR_STDERR,
+                   "Error: no DISPLAY environment variable specified\n");
+        return 1;
+      }
+    }
+
+    if (display_name) {
+      mGdkDisplay = gdk_display_open(display_name);
+      if (!mGdkDisplay) {
+        PR_fprintf(PR_STDERR, "Error: cannot open display: %s\n", display_name);
+        return 1;
+      }
+      gdk_display_manager_set_default_display(gdk_display_manager_get(),
+                                              mGdkDisplay);
+      if (saveDisplayArg) {
+#  ifdef MOZ_X11
+        if (GDK_IS_X11_DISPLAY(mGdkDisplay)) {
+          SaveWordToEnv("DISPLAY", nsDependentCString(display_name));
+        }
+#  endif
+#  ifdef MOZ_WAYLAND
+        else if (!GDK_IS_X11_DISPLAY(mGdkDisplay)) {
+          SaveWordToEnv("WAYLAND_DISPLAY", nsDependentCString(display_name));
+        }
+#  endif
+      }
+    }
+#  ifdef MOZ_WIDGET_GTK
+    else {
+      mGdkDisplay =
+          gdk_display_manager_open_display(gdk_display_manager_get(), nullptr);
+    }
+#  endif
+  }
+#endif
+#if defined(MOZ_HAS_REMOTE)
+  // handle --remote now that xpcom is fired up
+  mRemoteService = new nsRemoteService(gAppData->remotingName);
+  if (mRemoteService && !mDisableRemoteServer) {
+    mRemoteService->LockStartup();
+  }
+#endif
+#if defined(MOZ_WIDGET_GTK)
+  g_set_application_name(mAppData->name);
+
+#endif /* defined(MOZ_WIDGET_GTK) */
+#ifdef MOZ_X11
+  // Do this after initializing GDK, or GDK will install its own handler.
+  XRE_InstallX11ErrorHandler();
+#endif
+
+  // Call the code to install our handler
+#ifdef MOZ_JPROF
+  setupProfilingStuff();
+#endif
+
+  rv = NS_CreateNativeAppSupport(getter_AddRefs(mNativeApp));
+  if (NS_FAILED(rv)) return 1;
+
+  bool canRun = false;
+  rv = mNativeApp->Start(&canRun);
+  if (NS_FAILED(rv) || !canRun) {
+    return 1;
+  }
+
+#if defined(HAVE_DESKTOP_STARTUP_ID) && defined(MOZ_WIDGET_GTK)
+  // DESKTOP_STARTUP_ID is cleared now,
+  // we recover it in case we need a restart.
+  if (!mDesktopStartupID.IsEmpty()) {
+    nsAutoCString desktopStartupEnv;
+    desktopStartupEnv.AssignLiteral("DESKTOP_STARTUP_ID=");
+    desktopStartupEnv.Append(mDesktopStartupID);
+    // Leak it with extreme prejudice!
+    PR_SetEnv(ToNewCString(desktopStartupEnv));
+  }
+#endif
+
+  // Support exiting early for testing startup sequence. Bug 1360493
+  if (CheckArg("test-launch-without-hang")) {
+    *aExitFlag = true;
+    return 0;
+  }
+
+  rv = NS_NewToolkitProfileService(getter_AddRefs(mProfileSvc));
+  if (rv == NS_ERROR_FILE_ACCESS_DENIED) {
+    PR_fprintf(PR_STDERR,
+               "Error: Access was denied while trying to open files in "
+               "your profile directory.\n");
+  }
+  if (NS_FAILED(rv)) {
+    // We failed to choose or create profile - notify user and quit
+    ProfileMissingDialog(mNativeApp);
+    return 1;
+  }
+
+  bool wasDefaultSelection;
+  nsCOMPtr<nsIToolkitProfile> profile;
+  rv = SelectProfile(mProfileSvc, mNativeApp, getter_AddRefs(mProfD),
+                     getter_AddRefs(mProfLD), getter_AddRefs(profile),
+                     &wasDefaultSelection);
+  if (rv == NS_ERROR_LAUNCHED_CHILD_PROCESS || rv == NS_ERROR_ABORT) {
+    *aExitFlag = true;
+    return 0;
+  }
+
+  if (NS_FAILED(rv)) {
+    // We failed to choose or create profile - notify user and quit
+    ProfileMissingDialog(mNativeApp);
+    return 1;
+  }
+
+#if defined(MOZ_HAS_REMOTE)
+  if (mRemoteService) {
+    // We want a unique profile name to identify the remote instance.
+    nsCString profileName;
+    if (profile) {
+      rv = profile->GetName(profileName);
+    }
+    if (!profile || NS_FAILED(rv) || profileName.IsEmpty()) {
+      // Couldn't get a name from the profile. Use the directory name?
+      nsString leafName;
+      rv = mProfD->GetLeafName(leafName);
+      if (NS_SUCCEEDED(rv)) {
+        CopyUTF16toUTF8(leafName, profileName);
+      }
+    }
+
+    mRemoteService->SetProfile(profileName);
+
+    if (!mDisableRemoteClient) {
+      // Try to remote the entire command line. If this fails, start up
+      // normally.
+      const char* desktopStartupIDPtr =
+          mDesktopStartupID.IsEmpty() ? nullptr : mDesktopStartupID.get();
+
+      RemoteResult rr = mRemoteService->StartClient(desktopStartupIDPtr);
+      if (rr == REMOTE_FOUND) {
+        *aExitFlag = true;
+        mRemoteService->UnlockStartup();
+        return 0;
+      }
+      if (rr == REMOTE_ARG_BAD) {
+        mRemoteService->UnlockStartup();
+        return 1;
+      }
+    }
+  }
+#endif
+
+#if defined(MOZ_UPDATER) && !defined(MOZ_WIDGET_ANDROID)
+  // Check for and process any available updates
+  nsCOMPtr<nsIFile> updRoot;
+  bool persistent;
+  rv = mDirProvider.GetFile(XRE_UPDATE_ROOT_DIR, &persistent,
+                            getter_AddRefs(updRoot));
+  // XRE_UPDATE_ROOT_DIR may fail. Fallback to appDir if failed
+  if (NS_FAILED(rv)) {
+    updRoot = mDirProvider.GetAppDir();
+  }
+
+  // If the MOZ_TEST_PROCESS_UPDATES environment variable already exists, then
+  // we are being called from the callback application.
+  if (EnvHasValue("MOZ_TEST_PROCESS_UPDATES")) {
+    // If the caller has asked us to log our arguments, do so.  This is used
+    // to make sure that the maintenance service successfully launches the
+    // callback application.
+    const char* logFile = nullptr;
+    if (ARG_FOUND == CheckArg("dump-args", &logFile)) {
+      FILE* logFP = fopen(logFile, "wb");
+      if (logFP) {
+        for (int i = 1; i < gRestartArgc; ++i) {
+          fprintf(logFP, "%s\n", gRestartArgv[i]);
+        }
+        fclose(logFP);
+      }
+    }
+    *aExitFlag = true;
+    return 0;
+  }
+
+  // Support for processing an update and exiting. The MOZ_TEST_PROCESS_UPDATES
+  // environment variable will be part of the updater's environment and the
+  // application that is relaunched by the updater. When the application is
+  // relaunched by the updater it will be removed below and the application
+  // will exit.
+  if (CheckArg("test-process-updates")) {
+    SaveToEnv("MOZ_TEST_PROCESS_UPDATES=1");
+  }
+  nsCOMPtr<nsIFile> exeFile, exeDir;
+  rv = mDirProvider.GetFile(XRE_EXECUTABLE_FILE, &persistent,
+                            getter_AddRefs(exeFile));
+  NS_ENSURE_SUCCESS(rv, 1);
+  rv = exeFile->GetParent(getter_AddRefs(exeDir));
+  NS_ENSURE_SUCCESS(rv, 1);
+  ProcessUpdates(mDirProvider.GetGREDir(), exeDir, updRoot, gRestartArgc,
+                 gRestartArgv, mAppData->version);
+  if (EnvHasValue("MOZ_TEST_PROCESS_UPDATES")) {
+    SaveToEnv("MOZ_TEST_PROCESS_UPDATES=");
+    *aExitFlag = true;
+    return 0;
+  }
+#endif
+
+  // We now know there is no existing instance using the selected profile. If
+  // the profile wasn't selected by specific command line arguments and the
+  // user has chosen to show the profile manager on startup then do that.
+  if (wasDefaultSelection) {
+    bool useSelectedProfile;
+    rv = mProfileSvc->GetStartWithLastProfile(&useSelectedProfile);
+    NS_ENSURE_SUCCESS(rv, 1);
+
+    if (!useSelectedProfile) {
+      rv = ShowProfileManager(mProfileSvc, mNativeApp);
+      if (rv == NS_ERROR_LAUNCHED_CHILD_PROCESS || rv == NS_ERROR_ABORT) {
+        *aExitFlag = true;
+        return 0;
+      }
+      if (NS_FAILED(rv)) {
+        return 1;
+      }
+    }
+  }
+
+  // We always want to lock the profile even if we're actually going to reset
+  // it later.
+  rv = LockProfile(mNativeApp, mProfD, mProfLD, profile,
+                   getter_AddRefs(mProfileLock));
+  if (rv == NS_ERROR_LAUNCHED_CHILD_PROCESS || rv == NS_ERROR_ABORT) {
+    *aExitFlag = true;
+    return 0;
+  } else if (NS_FAILED(rv)) {
+    return 1;
+  }
+
+  if (gDoProfileReset) {
+    // Unlock the source profile.
+    mProfileLock->Unlock();
+
+    // If we're resetting a profile, create a new one and use it to startup.
+    gResetOldProfile = profile;
+    rv = mProfileSvc->CreateResetProfile(getter_AddRefs(profile));
+    if (NS_SUCCEEDED(rv)) {
+      rv = profile->GetRootDir(getter_AddRefs(mProfD));
+      NS_ENSURE_SUCCESS(rv, 1);
+      SaveFileToEnv("XRE_PROFILE_PATH", mProfD);
+
+      rv = profile->GetLocalDir(getter_AddRefs(mProfLD));
+      NS_ENSURE_SUCCESS(rv, 1);
+      SaveFileToEnv("XRE_PROFILE_LOCAL_PATH", mProfLD);
+
+      // Lock the new profile
+      rv = LockProfile(mNativeApp, mProfD, mProfLD, profile,
+                       getter_AddRefs(mProfileLock));
+      if (rv == NS_ERROR_LAUNCHED_CHILD_PROCESS || rv == NS_ERROR_ABORT) {
+        *aExitFlag = true;
+        return 0;
+      } else if (NS_FAILED(rv)) {
+        return 1;
+      }
+    } else {
+      NS_WARNING("Profile reset failed.");
+      return 1;
+    }
+  }
+
+  gProfileLock = mProfileLock;
+
+  nsAutoCString version;
+  BuildVersion(version);
+
+#ifdef TARGET_OS_ABI
+  constexpr auto osABI = nsLiteralCString{TARGET_OS_ABI};
+#else
+  // No TARGET_XPCOM_ABI, but at least the OS is known
+  constexpr auto osABI = nsLiteralCString{OS_TARGET "_UNKNOWN"};
+#endif
+
+  // Check for version compatibility with the last version of the app this
+  // profile was started with.  The format of the version stamp is defined
+  // by the BuildVersion function.
+  // Also check to see if something has happened to invalidate our
+  // fastload caches, like an app upgrade.
+
+  // If we see .purgecaches, that means someone did a make.
+  // Re-register components to catch potential changes.
+  nsCOMPtr<nsIFile> flagFile;
+  if (mAppData->directory) {
+    Unused << mAppData->directory->Clone(getter_AddRefs(flagFile));
+  }
+  if (flagFile) {
+    flagFile->AppendNative(FILE_INVALIDATE_CACHES);
+  }
+
+  bool cachesOK;
+  bool isDowngrade;
+  nsCString lastVersion;
+  bool versionOK = CheckCompatibility(
+      mProfD, version, osABI, mDirProvider.GetGREDir(), mAppData->directory,
+      flagFile, &cachesOK, &isDowngrade, lastVersion);
+
+  MOZ_RELEASE_ASSERT(!cachesOK || lastVersion.Equals(version),
+                     "Caches cannot be good if the version has changed.");
+
+#ifdef MOZ_BLOCK_PROFILE_DOWNGRADE
+  // The argument check must come first so the argument is always removed from
+  // the command line regardless of whether this is a downgrade or not.
+  if (!CheckArg("allow-downgrade") && isDowngrade &&
+      !EnvHasValue("MOZ_ALLOW_DOWNGRADE")) {
+    rv = CheckDowngrade(mProfD, mNativeApp, mProfileSvc, lastVersion);
+    if (rv == NS_ERROR_LAUNCHED_CHILD_PROCESS || rv == NS_ERROR_ABORT) {
+      *aExitFlag = true;
+      return 0;
+    }
+  }
+#endif
+
+  rv = mDirProvider.SetProfile(mProfD, mProfLD);
+  NS_ENSURE_SUCCESS(rv, 1);
+
+  //////////////////////// NOW WE HAVE A PROFILE ////////////////////////
+
+  mozilla::Telemetry::SetProfileDir(mProfD);
+
+  if (mAppData->flags & NS_XRE_ENABLE_CRASH_REPORTER) {
+    MakeOrSetMinidumpPath(mProfD);
+  }
+
+  CrashReporter::SetProfileDirectory(mProfD);
+
+#ifdef MOZ_ASAN_REPORTER
+  // In ASan reporter builds, we need to set ASan's log_path as early as
+  // possible, so it dumps its errors into files there instead of using
+  // the default stderr location. Since this is crucial for ASan reporter
+  // to work at all (and we don't want people to use a non-functional
+  // ASan reporter build), all failures while setting log_path are fatal.
+  setASanReporterPath(mProfD);
+
+  // Export to env for child processes
+  SaveFileToEnv("ASAN_REPORTER_PATH", mProfD);
+#endif
+
+  bool lastStartupWasCrash = CheckLastStartupWasCrash().unwrapOr(false);
+
+  if (CheckArg("purgecaches") || PR_GetEnv("MOZ_PURGE_CACHES") ||
+      lastStartupWasCrash || gSafeMode) {
+    cachesOK = false;
+  }
+
+  // Every time a profile is loaded by a build with a different version,
+  // it updates the compatibility.ini file saying what version last wrote
+  // the fastload caches.  On subsequent launches if the version matches,
+  // there is no need for re-registration.  If the user loads the same
+  // profile in different builds the component registry must be
+  // re-generated to prevent mysterious component loading failures.
+  //
+  bool startupCacheValid = true;
+
+  if (!cachesOK || !versionOK) {
+    QuotaManager::InvalidateQuotaCache();
+
+    startupCacheValid = RemoveComponentRegistries(mProfD, mProfLD, false);
+
+    // Rewrite compatibility.ini to match the current build. The next run
+    // should attempt to invalidate the caches if either this run is safe mode
+    // or the attempt to invalidate the caches this time failed.
+    WriteVersion(mProfD, version, osABI, mDirProvider.GetGREDir(),
+                 mAppData->directory, gSafeMode || !startupCacheValid);
+  }
+
+  if (!startupCacheValid) StartupCache::IgnoreDiskCache();
+
+  if (flagFile) {
+    flagFile->Remove(true);
+  }
+
+  return 0;
+}
+
+#if defined(MOZ_SANDBOX)
+void AddSandboxAnnotations() {
+  // Include the sandbox content level, regardless of platform
+  int level = GetEffectiveContentSandboxLevel();
+
+  nsAutoCString levelString;
+  levelString.AppendInt(level);
+
+  CrashReporter::AnnotateCrashReport(
+      CrashReporter::Annotation::ContentSandboxLevel, levelString);
+
+  // Include whether or not this instance is capable of content sandboxing
+  bool sandboxCapable = false;
+
+#  if defined(XP_WIN)
+  // All supported Windows versions support some level of content sandboxing
+  sandboxCapable = true;
+#  elif defined(XP_MACOSX)
+  // All supported OS X versions are capable
+  sandboxCapable = true;
+#  elif defined(XP_LINUX)
+  sandboxCapable = SandboxInfo::Get().CanSandboxContent();
+#  elif defined(__OpenBSD__)
+  sandboxCapable = true;
+  StartOpenBSDSandbox(GeckoProcessType_Default);
+#  endif
+
+  CrashReporter::AnnotateCrashReport(
+      CrashReporter::Annotation::ContentSandboxCapable, sandboxCapable);
+}
+#endif /* MOZ_SANDBOX */
+
+/*
+ * XRE_mainRun - Command line startup, profile migration, and
+ * the calling of appStartup->Run().
+ */
+nsresult XREMain::XRE_mainRun() {
+  nsresult rv = NS_OK;
+  NS_ASSERTION(mScopedXPCOM, "Scoped xpcom not initialized.");
+
+#if defined(XP_WIN)
+  RefPtr<mozilla::DllServices> dllServices(mozilla::DllServices::Get());
+  dllServices->StartUntrustedModulesProcessor();
+  auto dllServicesDisable =
+      MakeScopeExit([&dllServices]() { dllServices->DisableFull(); });
+
+#  if defined(MOZ_GECKO_PROFILER)
+  mozilla::mscom::InitProfilerMarkers();
+#  endif  // defined(MOZ_GECKO_PROFILER)
+#endif  // defined(XP_WIN)
+
+  rv = mScopedXPCOM->SetWindowCreator(mNativeApp);
+  NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+  // tell the crash reporter to also send the release channel
+  nsCOMPtr<nsIPrefService> prefs =
+      do_GetService("@mozilla.org/preferences-service;1", &rv);
+  if (NS_SUCCEEDED(rv)) {
+    nsCOMPtr<nsIPrefBranch> defaultPrefBranch;
+    rv = prefs->GetDefaultBranch(nullptr, getter_AddRefs(defaultPrefBranch));
+
+    if (NS_SUCCEEDED(rv)) {
+      nsAutoCString sval;
+      rv = defaultPrefBranch->GetCharPref("app.update.channel", sval);
+      if (NS_SUCCEEDED(rv)) {
+        CrashReporter::AnnotateCrashReport(
+            CrashReporter::Annotation::ReleaseChannel, sval);
+      }
+    }
+  }
+  // Needs to be set after xpcom initialization.
+  CrashReporter::AnnotateCrashReport(
+      CrashReporter::Annotation::FramePoisonBase,
+      nsPrintfCString("%.16" PRIu64, uint64_t(gMozillaPoisonBase)));
+  CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::FramePoisonSize,
+                                     uint32_t(gMozillaPoisonSize));
+
+  bool includeContextHeap =
+      Preferences::GetBool("toolkit.crashreporter.include_context_heap", false);
+  CrashReporter::SetIncludeContextHeap(includeContextHeap);
+
+#ifdef XP_WIN
+  PR_CreateThread(PR_USER_THREAD, AnnotateWMIData_ThreadStart, 0,
+                  PR_PRIORITY_LOW, PR_GLOBAL_THREAD, PR_UNJOINABLE_THREAD, 0);
+#endif
+
+#if defined(XP_LINUX) && !defined(ANDROID)
+  PR_CreateThread(PR_USER_THREAD, AnnotateLSBRelease, 0, PR_PRIORITY_LOW,
+                  PR_GLOBAL_THREAD, PR_UNJOINABLE_THREAD, 0);
+#endif
+
+  if (mStartOffline) {
+    nsCOMPtr<nsIIOService> io(
+        do_GetService("@mozilla.org/network/io-service;1"));
+    NS_ENSURE_TRUE(io, NS_ERROR_FAILURE);
+    io->SetManageOfflineStatus(false);
+    io->SetOffline(true);
+  }
+
+#ifdef XP_WIN
+  mozilla::DllPrefetchExperimentRegistryInfo prefetchRegInfo;
+  mozilla::AlteredDllPrefetchMode dllPrefetchMode =
+      prefetchRegInfo.GetAlteredDllPrefetchMode();
+
+  if (!PR_GetEnv("XRE_NO_DLL_READAHEAD") &&
+      dllPrefetchMode != mozilla::AlteredDllPrefetchMode::NoPrefetch) {
+    nsCOMPtr<nsIFile> greDir = mDirProvider.GetGREDir();
+    nsAutoString path;
+    rv = greDir->GetPath(path);
+    if (NS_SUCCEEDED(rv)) {
+      PRThread* readAheadThread;
+      wchar_t* pathRaw;
+
+      // We use the presence of a path argument inside the thread to determine
+      // which list of Dlls to use. The old list does not need access to the
+      // GRE dir, so the path argument is set to a null pointer.
+      if (dllPrefetchMode ==
+          mozilla::AlteredDllPrefetchMode::OptimizedPrefetch) {
+        pathRaw = new wchar_t[MAX_PATH];
+        wcscpy_s(pathRaw, MAX_PATH, path.get());
+      } else {
+        pathRaw = nullptr;
+      }
+      readAheadThread = PR_CreateThread(
+          PR_USER_THREAD, ReadAheadDlls_ThreadStart, (void*)pathRaw,
+          PR_PRIORITY_NORMAL, PR_GLOBAL_THREAD, PR_UNJOINABLE_THREAD, 0);
+      if (readAheadThread == NULL) {
+        delete[] pathRaw;
+      }
+    }
+  }
+#endif
+
+  if (gDoMigration) {
+    nsCOMPtr<nsIFile> file;
+    mDirProvider.GetAppDir()->Clone(getter_AddRefs(file));
+    file->AppendNative("override.ini"_ns);
+    nsINIParser parser;
+    nsresult rv = parser.Init(file);
+    // if override.ini doesn't exist, also check for distribution.ini
+    if (NS_FAILED(rv)) {
+      bool persistent;
+      mDirProvider.GetFile(XRE_APP_DISTRIBUTION_DIR, &persistent,
+                           getter_AddRefs(file));
+      file->AppendNative("distribution.ini"_ns);
+      rv = parser.Init(file);
+    }
+    if (NS_SUCCEEDED(rv)) {
+      nsAutoCString buf;
+      rv = parser.GetString("XRE", "EnableProfileMigrator", buf);
+      if (NS_SUCCEEDED(rv)) {
+        if (buf[0] == '0' || buf[0] == 'f' || buf[0] == 'F') {
+          gDoMigration = false;
+        }
+      }
+    }
+  }
+
+  // We'd like to initialize the JSContext *after* reading the user prefs.
+  // Unfortunately that's not possible if we have to do profile migration
+  // because that requires us to execute JS before reading user prefs.
+  // Restarting the browser after profile migration would fix this. See
+  // bug 1592523.
+  bool initializedJSContext = false;
+
+  {
+    // Profile Migration
+    if (mAppData->flags & NS_XRE_ENABLE_PROFILE_MIGRATOR && gDoMigration) {
+      gDoMigration = false;
+
+      xpc::InitializeJSContext();
+      initializedJSContext = true;
+
+      nsCOMPtr<nsIProfileMigrator> pm(
+          do_CreateInstance(NS_PROFILEMIGRATOR_CONTRACTID));
+      if (pm) {
+        nsAutoCString aKey;
+        nsAutoCString aName;
+        if (gDoProfileReset) {
+          // Automatically migrate from the current application if we just
+          // reset the profile.
+          aKey = MOZ_APP_NAME;
+          gResetOldProfile->GetName(aName);
+        }
+        pm->Migrate(&mDirProvider, aKey, aName);
+      }
+    }
+
+    if (gDoProfileReset) {
+      if (!initializedJSContext) {
+        xpc::InitializeJSContext();
+        initializedJSContext = true;
+      }
+
+      nsresult backupCreated =
+          ProfileResetCleanup(mProfileSvc, gResetOldProfile);
+      if (NS_FAILED(backupCreated)) {
+        NS_WARNING("Could not cleanup the profile that was reset");
+      }
+    }
+  }
+
+#ifndef XP_WIN
+  nsCOMPtr<nsIFile> profileDir;
+  nsAutoCString path;
+  rv = mDirProvider.GetProfileStartupDir(getter_AddRefs(profileDir));
+  if (NS_SUCCEEDED(rv) && NS_SUCCEEDED(profileDir->GetNativePath(path)) &&
+      !IsUtf8(path)) {
+    PR_fprintf(
+        PR_STDERR,
+        "Error: The profile path is not valid UTF-8. Unable to continue.\n");
+    return NS_ERROR_FAILURE;
+  }
+#endif
+
+  // Initialize user preferences before notifying startup observers so they're
+  // ready in time for early consumers, such as the component loader.
+  mDirProvider.InitializeUserPrefs();
+
+  // Now that all (user) prefs have been loaded we can initialize the main
+  // thread's JSContext.
+  if (!initializedJSContext) {
+    xpc::InitializeJSContext();
+  }
+
+  // Finally, now that JS has been initialized, we can finish pref loading. This
+  // needs to happen after JS and XPConnect initialization because AutoConfig
+  // files require JS execution. Note that this means AutoConfig files can't
+  // override JS engine start-up prefs.
+  mDirProvider.FinishInitializingUserPrefs();
+
+  nsAppStartupNotifier::NotifyObservers(APPSTARTUP_CATEGORY);
+
+  nsCOMPtr<nsIAppStartup> appStartup(components::AppStartup::Service());
+  NS_ENSURE_TRUE(appStartup, NS_ERROR_FAILURE);
+
+  mDirProvider.DoStartup();
+
+#ifdef MOZ_THUNDERBIRD
+  if (Preferences::GetBool("security.prompt_for_master_password_on_startup",
+                           false)) {
+    // Prompt for the master password prior to opening application windows,
+    // to avoid the race that triggers multiple prompts (see bug 177175).
+    // We use this code until we have a better solution, possibly as
+    // described in bug 177175 comment 384.
+    nsCOMPtr<nsIPK11TokenDB> db =
+        do_GetService("@mozilla.org/security/pk11tokendb;1");
+    nsCOMPtr<nsIPK11Token> token;
+    if (NS_SUCCEEDED(db->GetInternalKeyToken(getter_AddRefs(token)))) {
+      Unused << token->Login(false);
+    }
+  }
+#endif
+
+  // As FilePreferences need the profile directory, we must initialize right
+  // here.
+  mozilla::FilePreferences::InitDirectoriesWhitelist();
+  mozilla::FilePreferences::InitPrefs();
+
+  OverrideDefaultLocaleIfNeeded();
+
+  nsCString userAgentLocale;
+  LocaleService::GetInstance()->GetAppLocaleAsBCP47(userAgentLocale);
+  CrashReporter::AnnotateCrashReport(
+      CrashReporter::Annotation::useragent_locale, userAgentLocale);
+
+  appStartup->GetShuttingDown(&mShuttingDown);
+
+  nsCOMPtr<nsICommandLineRunner> cmdLine;
+
+  nsCOMPtr<nsIFile> workingDir;
+  rv = NS_GetSpecialDirectory(NS_OS_CURRENT_WORKING_DIR,
+                              getter_AddRefs(workingDir));
+  if (NS_FAILED(rv)) {
+    // No working dir? This can happen if it gets deleted before we start.
+    workingDir = nullptr;
+  }
+
+  if (!mShuttingDown) {
+    cmdLine = new nsCommandLine();
+
+    rv = cmdLine->Init(gArgc, gArgv, workingDir,
+                       nsICommandLine::STATE_INITIAL_LAUNCH);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+
+    /* Special-case services that need early access to the command
+        line. */
+    nsCOMPtr<nsIObserverService> obsService =
+        mozilla::services::GetObserverService();
+    if (obsService) {
+      obsService->NotifyObservers(cmdLine, "command-line-startup", nullptr);
+    }
+  }
+
+#ifdef XP_WIN
+  // Hack to sync up the various environment storages. XUL_APP_FILE is special
+  // in that it comes from a different CRT (firefox.exe's static-linked copy).
+  // Ugly details in http://bugzil.la/1175039#c27
+  char appFile[MAX_PATH];
+  if (GetEnvironmentVariableA("XUL_APP_FILE", appFile, sizeof(appFile))) {
+    SmprintfPointer saved = mozilla::Smprintf("XUL_APP_FILE=%s", appFile);
+    // We intentionally leak the string here since it is required by PR_SetEnv.
+    PR_SetEnv(saved.release());
+  }
+#endif
+
+  mozilla::AppShutdown::SaveEnvVarsForPotentialRestart();
+
+  // clear out any environment variables which may have been set
+  // during the relaunch process now that we know we won't be relaunching.
+  SaveToEnv("XRE_PROFILE_PATH=");
+  SaveToEnv("XRE_PROFILE_LOCAL_PATH=");
+  SaveToEnv("XRE_START_OFFLINE=");
+  SaveToEnv("XUL_APP_FILE=");
+  SaveToEnv("XRE_BINARY_PATH=");
+  SaveToEnv("XRE_RESTARTED_BY_PROFILE_MANAGER=");
+
+  if (!mShuttingDown) {
+#ifdef XP_MACOSX
+    bool lazyHiddenWindow = false;
+#else
+    bool lazyHiddenWindow =
+        Preferences::GetBool("toolkit.lazyHiddenWindow", false);
+#endif
+
+    if (!lazyHiddenWindow) {
+      rv = appStartup->CreateHiddenWindow();
+      NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+    }
+
+#ifdef XP_WIN
+    Preferences::RegisterCallbackAndCall(RegisterApplicationRestartChanged,
+                                         PREF_WIN_REGISTER_APPLICATION_RESTART);
+    SetupAlteredPrefetchPref();
+    SetupSkeletonUIPrefs();
+#  if defined(MOZ_LAUNCHER_PROCESS)
+    SetupLauncherProcessPref();
+#  endif  // defined(MOZ_LAUNCHER_PROCESS)
+#  if defined(MOZ_DEFAULT_BROWSER_AGENT)
+    Preferences::RegisterCallbackAndCall(&OnDefaultAgentTelemetryPrefChanged,
+                                         kPrefHealthReportUploadEnabled);
+    Preferences::RegisterCallbackAndCall(&OnDefaultAgentTelemetryPrefChanged,
+                                         kPrefDefaultAgentEnabled);
+
+    Preferences::RegisterCallbackAndCall(
+        &OnDefaultAgentRemoteSettingsPrefChanged, kPrefServicesSettingsServer);
+    Preferences::RegisterCallbackAndCall(
+        &OnDefaultAgentRemoteSettingsPrefChanged,
+        kPrefSecurityContentSignatureRootHash);
+#  endif  // defined(MOZ_DEFAULT_BROWSER_AGENT)
+#endif
+
+#if defined(HAVE_DESKTOP_STARTUP_ID) && defined(MOZ_WIDGET_GTK)
+    // Clear the environment variable so it won't be inherited by
+    // child processes and confuse things.
+    g_unsetenv("DESKTOP_STARTUP_ID");
+#endif
+
+#ifdef XP_MACOSX
+    // we re-initialize the command-line service and do appleevents munging
+    // after we are sure that we're not restarting
+    cmdLine = new nsCommandLine();
+
+    char** tempArgv = static_cast<char**>(malloc(gArgc * sizeof(char*)));
+    for (int i = 0; i < gArgc; i++) {
+      tempArgv[i] = strdup(gArgv[i]);
+    }
+    CommandLineServiceMac::SetupMacCommandLine(gArgc, tempArgv, false);
+    rv = cmdLine->Init(gArgc, tempArgv, workingDir,
+                       nsICommandLine::STATE_INITIAL_LAUNCH);
+    free(tempArgv);
+    NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
+#endif
+
+    nsCOMPtr<nsIObserverService> obsService =
+        mozilla::services::GetObserverService();
+    if (obsService)
+      obsService->NotifyObservers(nullptr, "final-ui-startup", nullptr);
+
+    (void)appStartup->DoneStartingUp();
+
+    CrashReporter::AnnotateCrashReport(CrashReporter::Annotation::StartupCrash,
+                                       false);
+
+    appStartup->GetShuttingDown(&mShuttingDown);
+  }
+
+  if (!mShuttingDown) {
+    rv = cmdLine->Run();
+    NS_ENSURE_SUCCESS_LOG(rv, NS_ERROR_FAILURE);
+
+    appStartup->GetShuttingDown(&mShuttingDown);
+  }
+
+  if (!mShuttingDown) {
+#if defined(MOZ_HAS_REMOTE)
+    // if we have X remote support, start listening for requests on the
+    // proxy window.
+    if (mRemoteService && !mDisableRemoteServer) {
+      mRemoteService->StartupServer();
+      mRemoteService->UnlockStartup();
+    }
+#endif /* MOZ_WIDGET_GTK */
+
+    mNativeApp->Enable();
+  }
+
+#ifdef MOZ_INSTRUMENT_EVENT_LOOP
+  if (PR_GetEnv("MOZ_INSTRUMENT_EVENT_LOOP")) {
+    bool logToConsole = true;
+    mozilla::InitEventTracing(logToConsole);
+  }
+#endif /* MOZ_INSTRUMENT_EVENT_LOOP */
+
+  // Send Telemetry about Gecko version and buildid
+  Telemetry::ScalarSet(Telemetry::ScalarID::GECKO_VERSION,
+                       NS_ConvertASCIItoUTF16(gAppData->version));
+  Telemetry::ScalarSet(Telemetry::ScalarID::GECKO_BUILD_ID,
+                       NS_ConvertASCIItoUTF16(gAppData->buildID));
+
+#if defined(MOZ_SANDBOX) && defined(XP_LINUX)
+  // If we're on Linux, we now have information about the OS capabilities
+  // available to us.
+  SandboxInfo sandboxInfo = SandboxInfo::Get();
+  Telemetry::Accumulate(Telemetry::SANDBOX_HAS_SECCOMP_BPF,
+                        sandboxInfo.Test(SandboxInfo::kHasSeccompBPF));
+  Telemetry::Accumulate(Telemetry::SANDBOX_HAS_SECCOMP_TSYNC,
+                        sandboxInfo.Test(SandboxInfo::kHasSeccompTSync));
+  Telemetry::Accumulate(
+      Telemetry::SANDBOX_HAS_USER_NAMESPACES_PRIVILEGED,
+      sandboxInfo.Test(SandboxInfo::kHasPrivilegedUserNamespaces));
+  Telemetry::Accumulate(Telemetry::SANDBOX_HAS_USER_NAMESPACES,
+                        sandboxInfo.Test(SandboxInfo::kHasUserNamespaces));
+  Telemetry::Accumulate(Telemetry::SANDBOX_CONTENT_ENABLED,
+                        sandboxInfo.Test(SandboxInfo::kEnabledForContent));
+  Telemetry::Accumulate(Telemetry::SANDBOX_MEDIA_ENABLED,
+                        sandboxInfo.Test(SandboxInfo::kEnabledForMedia));
+  nsAutoCString flagsString;
+  flagsString.AppendInt(sandboxInfo.AsInteger());
+
+  CrashReporter::AnnotateCrashReport(
+      CrashReporter::Annotation::ContentSandboxCapabilities, flagsString);
+#endif /* MOZ_SANDBOX && XP_LINUX */
+
+#if defined(XP_WIN)
+  LauncherResult<bool> isAdminWithoutUac = IsAdminWithoutUac();
+  if (isAdminWithoutUac.isOk()) {
+    Telemetry::ScalarSet(
+        Telemetry::ScalarID::OS_ENVIRONMENT_IS_ADMIN_WITHOUT_UAC,
+        isAdminWithoutUac.unwrap());
+  }
+#endif /* XP_WIN */
+
+#if defined(MOZ_SANDBOX)
+  AddSandboxAnnotations();
+#endif /* MOZ_SANDBOX */
+
+  mProfileSvc->CompleteStartup();
+
+  {
+    rv = appStartup->Run();
+    if (NS_FAILED(rv)) {
+      NS_ERROR("failed to run appstartup");
+      gLogConsoleErrors = true;
+    }
+  }
+
+  return rv;
+}
+
+#if defined(MOZ_WIDGET_ANDROID)
+static already_AddRefed<nsIFile> GreOmniPath() {
+  nsresult rv;
+
+  const char* path = nullptr;
+  ArgResult ar = CheckArg("greomni", &path);
+  if (ar == ARG_BAD) {
+    PR_fprintf(PR_STDERR,
+               "Error: argument --greomni requires a path argument\n");
+    return nullptr;
+  }
+
+  if (!path) return nullptr;
+
+  nsCOMPtr<nsIFile> greOmni;
+  rv = XRE_GetFileFromPath(path, getter_AddRefs(greOmni));
+  if (NS_FAILED(rv)) {
+    PR_fprintf(PR_STDERR, "Error: argument --greomni requires a valid path\n");
+    return nullptr;
+  }
+
+  return greOmni.forget();
+}
+#endif
+
+/*
+ * XRE_main - A class based main entry point used by most platforms.
+ *            Note that on OSX, aAppData->xreDirectory will point to
+ *            .app/Contents/Resources.
+ */
+int XREMain::XRE_main(int argc, char* argv[], const BootstrapConfig& aConfig) {
+  gArgc = argc;
+  gArgv = argv;
+
+  ScopedLogging log;
+
+  mozilla::LogModule::Init(gArgc, gArgv);
+
+#ifndef XP_LINUX
+  NS_SetCurrentThreadName("MainThread");
+#endif
+
+  AUTO_BASE_PROFILER_LABEL("XREMain::XRE_main (around Gecko Profiler)", OTHER);
+  AUTO_PROFILER_INIT;
+  AUTO_PROFILER_LABEL("XREMain::XRE_main", OTHER);
+
+#ifdef MOZ_CODE_COVERAGE
+  CodeCoverageHandler::Init();
+#endif
+
+  nsresult rv = NS_OK;
+
+  if (aConfig.appData) {
+    mAppData = MakeUnique<XREAppData>(*aConfig.appData);
+  } else {
+    MOZ_RELEASE_ASSERT(aConfig.appDataPath);
+    nsCOMPtr<nsIFile> appini;
+    rv = XRE_GetFileFromPath(aConfig.appDataPath, getter_AddRefs(appini));
+    if (NS_FAILED(rv)) {
+      Output(true, "Error: unrecognized path: %s\n", aConfig.appDataPath);
+      return 1;
+    }
+
+    mAppData = MakeUnique<XREAppData>();
+    rv = XRE_ParseAppData(appini, *mAppData);
+    if (NS_FAILED(rv)) {
+      Output(true, "Couldn't read application.ini");
+      return 1;
+    }
+
+    appini->GetParent(getter_AddRefs(mAppData->directory));
+  }
+
+  if (!mAppData->remotingName) {
+    mAppData->remotingName = mAppData->name;
+  }
+  // used throughout this file
+  gAppData = mAppData.get();
+
+  nsCOMPtr<nsIFile> binFile;
+  rv = XRE_GetBinaryPath(getter_AddRefs(binFile));
+  NS_ENSURE_SUCCESS(rv, 1);
+
+  rv = binFile->GetPath(gAbsoluteArgv0Path);
+  NS_ENSURE_SUCCESS(rv, 1);
+
+  if (!mAppData->xreDirectory) {
+    nsCOMPtr<nsIFile> greDir;
+
+#if defined(MOZ_WIDGET_ANDROID)
+    greDir = GreOmniPath();
+    if (!greDir) {
+      return 2;
+    }
+#else
+    rv = binFile->GetParent(getter_AddRefs(greDir));
+    if (NS_FAILED(rv)) return 2;
+#endif
+
+#ifdef XP_MACOSX
+    nsCOMPtr<nsIFile> parent;
+    greDir->GetParent(getter_AddRefs(parent));
+    greDir = parent.forget();
+    greDir->AppendNative("Resources"_ns);
+#endif
+
+    mAppData->xreDirectory = greDir;
+  }
+
+#if defined(MOZ_WIDGET_ANDROID)
+  nsCOMPtr<nsIFile> dataDir;
+  rv = binFile->GetParent(getter_AddRefs(dataDir));
+  if (NS_FAILED(rv)) return 2;
+
+  mAppData->directory = dataDir;
+#else
+  if (aConfig.appData && aConfig.appDataPath) {
+    mAppData->xreDirectory->Clone(getter_AddRefs(mAppData->directory));
+    mAppData->directory->AppendNative(nsDependentCString(aConfig.appDataPath));
+  }
+#endif
+
+  if (!mAppData->directory) {
+    mAppData->directory = mAppData->xreDirectory;
+  }
+
+#if defined(XP_WIN) && defined(MOZ_SANDBOX)
+  mAppData->sandboxBrokerServices = aConfig.sandboxBrokerServices;
+  mAppData->sandboxPermissionsService = aConfig.sandboxPermissionsService;
+#endif
+
+  mozilla::IOInterposerInit ioInterposerGuard;
+
+#if defined(XP_WIN)
+  // Initializing COM below may load modules via SetWindowHookEx, some of
+  // which may modify the executable's IAT for ntdll.dll.  If that happens,
+  // this browser process fails to launch sandbox processes because we cannot
+  // copy a modified IAT into a remote process (See SandboxBroker::LaunchApp).
+  // To prevent that, we cache the intact IAT before COM initialization.
+  // If EAF+ is enabled, CacheNtDllThunk() causes a crash, but EAF+ will
+  // also prevent an injected module from parsing the PE headers and modifying
+  // the IAT.  Therefore, we can skip CacheNtDllThunk().
+  if (!mozilla::IsEafPlusEnabled()) {
+    mozilla::ipc::GeckoChildProcessHost::CacheNtDllThunk();
+  }
+
+  // Some COM settings are global to the process and must be set before any non-
+  // trivial COM is run in the application. Since these settings may affect
+  // stability, we should instantiate COM ASAP so that we can ensure that these
+  // global settings are configured before anything can interfere.
+  mozilla::mscom::ProcessRuntime msCOMRuntime;
+#endif
+
+  // init
+  bool exit = false;
+  int result = XRE_mainInit(&exit);
+  if (result != 0 || exit) return result;
+
+  // If we exit gracefully, remove the startup crash canary file.
+  auto cleanup = MakeScopeExit([&]() -> nsresult {
+    if (mProfLD) {
+      nsCOMPtr<nsIFile> crashFile;
+      MOZ_TRY_VAR(crashFile, GetIncompleteStartupFile(mProfLD));
+      crashFile->Remove(false);
+    }
+    return NS_OK;
+  });
+
+  // startup
+  result = XRE_mainStartup(&exit);
+  if (result != 0 || exit) return result;
+
+  // Start the real application. We use |aInitJSContext = false| because
+  // XRE_mainRun wants to initialize the JSContext after reading user prefs.
+
+  mScopedXPCOM = MakeUnique<ScopedXPCOMStartup>();
+  if (!mScopedXPCOM) return 1;
+
+  rv = mScopedXPCOM->Initialize(/* aInitJSContext = */ false);
+  NS_ENSURE_SUCCESS(rv, 1);
+
+  // run!
+  rv = XRE_mainRun();
+
+#ifdef MOZ_INSTRUMENT_EVENT_LOOP
+  mozilla::ShutdownEventTracing();
+#endif
+
+  gAbsoluteArgv0Path.Truncate();
+
+#if defined(MOZ_HAS_REMOTE)
+  // Shut down the remote service. We must do this before calling LaunchChild
+  // if we're restarting because otherwise the new instance will attempt to
+  // remote to this instance.
+  if (mRemoteService && !mDisableRemoteServer) {
+    mRemoteService->ShutdownServer();
+  }
+#endif /* MOZ_WIDGET_GTK */
+
+  mScopedXPCOM = nullptr;
+
+#if defined(XP_WIN)
+  mozilla::widget::StopAudioSession();
+#endif
+
+  // unlock the profile after ScopedXPCOMStartup object (xpcom)
+  // has gone out of scope.  see bug #386739 for more details
+  mProfileLock->Unlock();
+  gProfileLock = nullptr;
+
+  gLastAppVersion.Truncate();
+  gLastAppBuildID.Truncate();
+
+  mozilla::AppShutdown::MaybeDoRestart();
+
+#ifdef MOZ_WIDGET_GTK
+  // gdk_display_close also calls gdk_display_manager_set_default_display
+  // appropriately when necessary.
+  if (!gfxPlatform::IsHeadless()) {
+#  ifdef MOZ_WAYLAND
+    WaylandDisplayRelease();
+#  endif
+  }
+#endif
+
+  if (mAppData->flags & NS_XRE_ENABLE_CRASH_REPORTER)
+    CrashReporter::UnsetExceptionHandler();
+
+  XRE_DeinitCommandLine();
+
+  if (NS_FAILED(rv)) {
+    return 1;
+  }
+  return mozilla::AppShutdown::GetExitCode();
+}
+
+void XRE_StopLateWriteChecks(void) { mozilla::StopLateWriteChecks(); }
+
+int XRE_main(int argc, char* argv[], const BootstrapConfig& aConfig) {
+  XREMain main;
+
+  int result = main.XRE_main(argc, argv, aConfig);
+  mozilla::RecordShutdownEndTimeStamp();
+  return result;
+}
+
+nsresult XRE_InitCommandLine(int aArgc, char* aArgv[]) {
+  nsresult rv = NS_OK;
+
+#if defined(OS_WIN)
+  CommandLine::Init(aArgc, aArgv);
+#else
+
+  // these leak on error, but that's OK: we'll just exit()
+  char** canonArgs = new char*[aArgc];
+
+  // get the canonical version of the binary's path
+  nsCOMPtr<nsIFile> binFile;
+  rv = XRE_GetBinaryPath(getter_AddRefs(binFile));
+  if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
+
+  nsAutoCString canonBinPath;
+  rv = binFile->GetNativePath(canonBinPath);
+  if (NS_FAILED(rv)) return NS_ERROR_FAILURE;
+
+  canonArgs[0] = strdup(canonBinPath.get());
+
+  for (int i = 1; i < aArgc; ++i) {
+    if (aArgv[i]) {
+      canonArgs[i] = strdup(aArgv[i]);
+    }
+  }
+
+  NS_ASSERTION(!CommandLine::IsInitialized(), "Bad news!");
+  CommandLine::Init(aArgc, canonArgs);
+
+  for (int i = 0; i < aArgc; ++i) free(canonArgs[i]);
+  delete[] canonArgs;
+#endif
+
+#if defined(MOZ_WIDGET_ANDROID)
+  nsCOMPtr<nsIFile> greOmni = gAppData ? gAppData->xreDirectory : GreOmniPath();
+  if (!greOmni) {
+    return NS_ERROR_FAILURE;
+  }
+  mozilla::Omnijar::Init(greOmni, greOmni);
+#endif
+
+  return rv;
+}
+
+nsresult XRE_DeinitCommandLine() {
+  nsresult rv = NS_OK;
+
+  CommandLine::Terminate();
+
+  return rv;
+}
+
+GeckoProcessType XRE_GetProcessType() {
+  return mozilla::startup::sChildProcessType;
+}
+
+const char* XRE_GetProcessTypeString() {
+  return XRE_GeckoProcessTypeToString(XRE_GetProcessType());
+}
+
+bool XRE_IsE10sParentProcess() {
+#ifdef MOZ_WIDGET_ANDROID
+  return XRE_IsParentProcess() && BrowserTabsRemoteAutostart() &&
+         mozilla::jni::IsAvailable();
+#else
+  return XRE_IsParentProcess() && BrowserTabsRemoteAutostart();
+#endif
+}
+
+#define GECKO_PROCESS_TYPE(enum_name, string_name, xre_name, bin_type) \
+  bool XRE_Is##xre_name##Process() {                                   \
+    return XRE_GetProcessType() == GeckoProcessType_##enum_name;       \
+  }
+#include "mozilla/GeckoProcessTypes.h"
+#undef GECKO_PROCESS_TYPE
+
+bool XRE_UseNativeEventProcessing() {
+#if defined(XP_MACOSX) || defined(XP_WIN)
+  if (XRE_IsRDDProcess() || XRE_IsSocketProcess()) {
+    return false;
+  }
+#endif
+  if (XRE_IsContentProcess()) {
+    return StaticPrefs::dom_ipc_useNativeEventProcessing_content();
+  }
+
+  return true;
+}
+
+namespace mozilla {
+
+uint32_t GetMaxWebProcessCount() {
+  // multiOptOut is in int to allow us to run multiple experiments without
+  // introducing multiple prefs a la the autostart.N prefs.
+  if (Preferences::GetInt("dom.ipc.multiOptOut", 0) >=
+      nsIXULRuntime::E10S_MULTI_EXPERIMENT) {
+    return 1;
+  }
+
+  const char* optInPref = "dom.ipc.processCount";
+  uint32_t optInPrefValue = Preferences::GetInt(optInPref, 1);
+  return std::max(1u, optInPrefValue);
+}
+
+const char* PlatformBuildID() { return gToolkitBuildID; }
+
+}  // namespace mozilla
+
+void SetupErrorHandling(const char* progname) {
+#ifdef XP_WIN
+  /* On Windows XPSP3 and Windows Vista if DEP is configured off-by-default
+     we still want DEP protection: enable it explicitly and programmatically.
+
+     This function is not available on WinXPSP2 so we dynamically load it.
+  */
+
+  HMODULE kernel32 = GetModuleHandleW(L"kernel32.dll");
+  SetProcessDEPPolicyFunc _SetProcessDEPPolicy =
+      (SetProcessDEPPolicyFunc)GetProcAddress(kernel32, "SetProcessDEPPolicy");
+  if (_SetProcessDEPPolicy) _SetProcessDEPPolicy(PROCESS_DEP_ENABLE);
+#endif
+
+#ifdef XP_WIN
+  // Suppress the "DLL Foo could not be found" dialog, such that if dependent
+  // libraries (such as GDI+) are not preset, we gracefully fail to load those
+  // XPCOM components, instead of being ungraceful.
+  UINT realMode = SetErrorMode(0);
+  realMode |= SEM_FAILCRITICALERRORS;
+  // If XRE_NO_WINDOWS_CRASH_DIALOG is set, suppress displaying the "This
+  // application has crashed" dialog box.  This is mainly useful for
+  // automated testing environments, e.g. tinderbox, where there's no need
+  // for a dozen of the dialog boxes to litter the console
+  if (getenv("XRE_NO_WINDOWS_CRASH_DIALOG"))
+    realMode |= SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX;
+
+  SetErrorMode(realMode);
+
+#endif
+
+  InstallSignalHandlers(progname);
+
+  // Unbuffer stdout, needed for tinderbox tests.
+  setbuf(stdout, 0);
+}
+
+// Note: This function should not be needed anymore. See Bug 818634 for details.
+void OverrideDefaultLocaleIfNeeded() {
+  // Read pref to decide whether to override default locale with US English.
+  if (mozilla::Preferences::GetBool("javascript.use_us_english_locale",
+                                    false)) {
+    // Set the application-wide C-locale. Needed to resist fingerprinting
+    // of Date.toLocaleFormat(). We use the locale to "C.UTF-8" if possible,
+    // to avoid interfering with non-ASCII keyboard input on some Linux
+    // desktops. Otherwise fall back to the "C" locale, which is available on
+    // all platforms.
+    setlocale(LC_ALL, "C.UTF-8") || setlocale(LC_ALL, "C");
+  }
+}
+
+static bool gRunSelfAsContentProc = false;
+
+void XRE_EnableSameExecutableForContentProc() {
+  if (!PR_GetEnv("MOZ_SEPARATE_CHILD_PROCESS")) {
+    gRunSelfAsContentProc = true;
+  }
+}
+
+mozilla::BinPathType XRE_GetChildProcBinPathType(
+    GeckoProcessType aProcessType) {
+  MOZ_ASSERT(aProcessType != GeckoProcessType_Default);
+
+  if (!gRunSelfAsContentProc) {
+    return BinPathType::PluginContainer;
+  }
+
+  switch (aProcessType) {
+#define GECKO_PROCESS_TYPE(enum_name, string_name, xre_name, bin_type) \
+  case GeckoProcessType_##enum_name:                                   \
+    return BinPathType::bin_type;
+#include "mozilla/GeckoProcessTypes.h"
+#undef GECKO_PROCESS_TYPE
+    default:
+      return BinPathType::PluginContainer;
+  }
+}
+
+// Because rust doesn't handle weak symbols, this function wraps the weak
+// malloc_handle_oom for it.
+extern "C" void GeckoHandleOOM(size_t size) { mozalloc_handle_oom(size); }
+
+// From toolkit/library/rust/shared/lib.rs
+extern "C" void install_rust_panic_hook();
+extern "C" void install_rust_oom_hook();
+
+struct InstallRustHooks {
+  InstallRustHooks() {
+    install_rust_panic_hook();
+    install_rust_oom_hook();
+  }
+};
+
+InstallRustHooks sInstallRustHooks;
+
+#ifdef MOZ_ASAN_REPORTER
+void setASanReporterPath(nsIFile* aDir) {
+  nsCOMPtr<nsIFile> dir;
+  aDir->Clone(getter_AddRefs(dir));
+
+  dir->Append(u"asan"_ns);
+  nsresult rv = dir->Create(nsIFile::DIRECTORY_TYPE, 0700);
+  if (NS_WARN_IF(NS_FAILED(rv) && rv != NS_ERROR_FILE_ALREADY_EXISTS)) {
+    MOZ_CRASH("[ASan Reporter] Unable to create crash directory.");
+  }
+
+  dir->Append(u"ff_asan_log"_ns);
+
+#  ifdef XP_WIN
+  nsAutoString nspathW;
+  rv = dir->GetPath(nspathW);
+  NS_ConvertUTF16toUTF8 nspath(nspathW);
+#  else
+  nsAutoCString nspath;
+  rv = dir->GetNativePath(nspath);
+#  endif
+  if (NS_FAILED(rv)) {
+    MOZ_CRASH("[ASan Reporter] Unable to get native path for crash directory.");
+  }
+
+  __sanitizer_set_report_path(nspath.get());
+}
+#endif
diff --git a/toolkit/xre/nsGDKErrorHandler.cpp b/toolkit/xre/nsGDKErrorHandler.cpp
index 421abdf12f..0d0088409f 100644
--- a/toolkit/xre/nsGDKErrorHandler.cpp
+++ b/toolkit/xre/nsGDKErrorHandler.cpp
@@ -6,14 +6,18 @@
 #include "nsGDKErrorHandler.h"
 
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
+#ifdef MOZ_X11
+#  include <gdk/gdkx.h>
+#endif
 #include <errno.h>
 #include <stdlib.h>
 #include <string.h>
 
 #include "nsDebug.h"
 #include "nsString.h"
-#include "nsX11ErrorHandler.h"
+#ifdef MOZ_X11
+#  include "nsX11ErrorHandler.h"
+#endif
 
 #include "prenv.h"
 
@@ -26,6 +30,7 @@
  */
 static void GdkErrorHandler(const gchar* log_domain, GLogLevelFlags log_level,
                             const gchar* message, gpointer user_data) {
+#ifdef MOZ_X11
   if (strstr(message, "X Window System error")) {
     XErrorEvent event;
     nsDependentCString buffer(message);
@@ -92,7 +97,9 @@ static void GdkErrorHandler(const gchar* log_domain, GLogLevelFlags log_level,
     event.resourceid = 0;
 
     X11Error(event.display, &event);
-  } else {
+  } else
+#endif
+  {
     g_log_default_handler(log_domain, log_level, message, user_data);
     MOZ_CRASH_UNSAFE(message);
   }
@@ -103,7 +110,9 @@ void InstallGdkErrorHandler() {
                     (GLogLevelFlags)(G_LOG_LEVEL_ERROR | G_LOG_FLAG_FATAL |
                                      G_LOG_FLAG_RECURSION),
                     GdkErrorHandler, nullptr);
+#ifdef MOZ_X11
   if (PR_GetEnv("MOZ_X_SYNC")) {
     XSynchronize(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()), X11True);
   }
+#endif
 }
diff --git a/widget/CompositorWidget.h b/widget/CompositorWidget.h
index 6417926a83..75634800a5 100644
--- a/widget/CompositorWidget.h
+++ b/widget/CompositorWidget.h
@@ -63,7 +63,7 @@ class CompositorWidgetDelegate {
 };
 
 // Platforms that support out-of-process widgets.
-#if defined(XP_WIN) || defined(MOZ_X11)
+#if defined(XP_WIN) || defined(MOZ_X11) || defined(MOZ_WAYLAND)
 // CompositorWidgetParent should implement CompositorWidget and
 // PCompositorWidgetParent.
 class CompositorWidgetParent;
diff --git a/widget/GfxInfoX11.cpp b/widget/GfxInfoX11.cpp
index b60fbb28ed..00d0b03e90 100644
--- a/widget/GfxInfoX11.cpp
+++ b/widget/GfxInfoX11.cpp
@@ -23,8 +23,8 @@
 
 #include "GfxInfoX11.h"
 
-#include <gdk/gdkx.h>
 #ifdef MOZ_WAYLAND
+#  include <gdk/gdkwayland.h>
 #  include "mozilla/widget/nsWaylandDisplay.h"
 #  include "mozilla/widget/DMABufLibWrapper.h"
 #endif
@@ -458,7 +458,7 @@ void GfxInfo::GetData() {
   mAdapterDescription.Assign(glRenderer);
 #ifdef MOZ_WAYLAND
   mIsWayland = gdk_display_get_default() &&
-               !GDK_IS_X11_DISPLAY(gdk_display_get_default());
+               GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default());
   if (mIsWayland) {
     mIsWaylandDRM = GetDMABufDevice()->IsDMABufVAAPIEnabled() ||
                     GetDMABufDevice()->IsDMABufWebGLEnabled() ||
diff --git a/widget/ScreenManager.cpp b/widget/ScreenManager.cpp
index 90324ebca4..fff576fb8c 100644
--- a/widget/ScreenManager.cpp
+++ b/widget/ScreenManager.cpp
@@ -13,7 +13,6 @@
 #include "mozilla/StaticPtr.h"
 #ifdef MOZ_WAYLAND
 #  include <gdk/gdk.h>
-#  include <gdk/gdkx.h>
 #  include <gdk/gdkwayland.h>
 #endif /* MOZ_WAYLAND */
 
@@ -110,7 +109,7 @@ ScreenManager::ScreenForRect(int32_t aX, int32_t aY, int32_t aWidth,
                              int32_t aHeight, nsIScreen** aOutScreen) {
 #if defined(MOZ_WAYLAND) && defined(MOZ_LOGGING)
   static bool inWayland = gdk_display_get_default() &&
-                          !GDK_IS_X11_DISPLAY(gdk_display_get_default());
+                          GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default());
   if (inWayland) {
     MOZ_LOG(sScreenLog, LogLevel::Warning,
             ("Getting screen in wayland, primary display will be returned."));
diff --git a/widget/gtk/DMABufLibWrapper.cpp b/widget/gtk/DMABufLibWrapper.cpp
index 73dc2d7d7a..542d048f6f 100644
--- a/widget/gtk/DMABufLibWrapper.cpp
+++ b/widget/gtk/DMABufLibWrapper.cpp
@@ -5,6 +5,7 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
+#include "base/message_loop.h"  // for MessageLoop
 #include "nsWaylandDisplay.h"
 #include "DMABufLibWrapper.h"
 #include "mozilla/StaticPrefs_widget.h"
@@ -12,7 +13,7 @@
 #include "mozilla/gfx/gfxVars.h"
 
 #include <gdk/gdk.h>
-#include <gdk/gdkx.h>
+#include <gdk/gdkwayland.h>
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -165,7 +166,7 @@ nsDMABufDevice::nsDMABufDevice()
       mGbmDevice(nullptr),
       mGbmFd(-1) {
   if (gdk_display_get_default() &&
-      !GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+      GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
     wl_display* display = WaylandDisplayGetWLDisplay();
     mRegistry = (void*)wl_display_get_registry(display);
     wl_registry_add_listener((wl_registry*)mRegistry, &registry_listener, this);
diff --git a/widget/gtk/MozContainer.cpp b/widget/gtk/MozContainer.cpp
index 334592eae1..e76a8ead15 100644
--- a/widget/gtk/MozContainer.cpp
+++ b/widget/gtk/MozContainer.cpp
@@ -9,7 +9,6 @@
 
 #include <glib.h>
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
 #include <stdio.h>
 #ifdef MOZ_WAYLAND
 #  include "gfxPlatformGtk.h"
diff --git a/widget/gtk/MozContainerWayland.cpp b/widget/gtk/MozContainerWayland.cpp
index 068d7b01bc..f67c19b712 100644
--- a/widget/gtk/MozContainerWayland.cpp
+++ b/widget/gtk/MozContainerWayland.cpp
@@ -9,7 +9,6 @@
 
 #include <glib.h>
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
 #include "nsWaylandDisplay.h"
 #include "gfxPlatformGtk.h"
 #include <wayland-egl.h>
diff --git a/widget/gtk/ScreenHelperGTK.cpp b/widget/gtk/ScreenHelperGTK.cpp
index 67410b25a1..5a8f6faa0d 100644
--- a/widget/gtk/ScreenHelperGTK.cpp
+++ b/widget/gtk/ScreenHelperGTK.cpp
@@ -151,7 +151,7 @@ static already_AddRefed<Screen> MakeScreen(GdkScreen* aScreen,
   DesktopToLayoutDeviceScale contentsScale(1.0);
 #ifdef MOZ_WAYLAND
   GdkDisplay* gdkDisplay = gdk_display_get_default();
-  if (!GDK_IS_X11_DISPLAY(gdkDisplay)) {
+  if (GDK_IS_WAYLAND_DISPLAY(gdkDisplay)) {
     contentsScale.scale = gdkScaleFactor;
   }
 #endif
diff --git a/widget/gtk/WindowSurfaceProvider.cpp b/widget/gtk/WindowSurfaceProvider.cpp
index b1310edc72..85cc8561dc 100644
--- a/widget/gtk/WindowSurfaceProvider.cpp
+++ b/widget/gtk/WindowSurfaceProvider.cpp
@@ -10,9 +10,11 @@
 #include "mozilla/gfx/Logging.h"
 #include "mozilla/layers/LayersTypes.h"
 #include "nsWindow.h"
-#include "WindowSurfaceX11Image.h"
-#include "WindowSurfaceX11SHM.h"
-#include "WindowSurfaceXRender.h"
+#ifdef MOZ_X11
+#  include "WindowSurfaceX11Image.h"
+#  include "WindowSurfaceX11SHM.h"
+#  include "WindowSurfaceXRender.h"
+#endif
 #ifdef MOZ_WAYLAND
 #  include "WindowSurfaceWayland.h"
 #endif
@@ -25,10 +27,12 @@ using namespace mozilla::layers;
 
 WindowSurfaceProvider::WindowSurfaceProvider()
     : mIsX11Display(false),
+#ifdef MOZ_X11
       mXDisplay(nullptr),
       mXWindow(0),
       mXVisual(nullptr),
       mXDepth(0),
+#endif
       mWindowSurface(nullptr)
 #ifdef MOZ_WAYLAND
       ,
@@ -38,6 +42,7 @@ WindowSurfaceProvider::WindowSurfaceProvider()
       mIsShaped(false) {
 }
 
+#ifdef MOZ_X11
 void WindowSurfaceProvider::Initialize(Display* aDisplay, Window aWindow,
                                        Visual* aVisual, int aDepth,
                                        bool aIsShaped) {
@@ -54,6 +59,7 @@ void WindowSurfaceProvider::Initialize(Display* aDisplay, Window aWindow,
   mIsShaped = aIsShaped;
   mIsX11Display = true;
 }
+#endif
 
 #ifdef MOZ_WAYLAND
 void WindowSurfaceProvider::Initialize(nsWindow* aWidget) {
@@ -72,6 +78,7 @@ UniquePtr<WindowSurface> WindowSurfaceProvider::CreateWindowSurface() {
   }
 #endif
 
+#ifdef MOZ_X11
   // We should be initialized
   MOZ_ASSERT(mXDisplay);
 
@@ -85,17 +92,18 @@ UniquePtr<WindowSurface> WindowSurfaceProvider::CreateWindowSurface() {
                                             mXDepth);
   }
 
-#ifdef MOZ_HAVE_SHMIMAGE
+#  ifdef MOZ_HAVE_SHMIMAGE
   if (!mIsShaped && nsShmImage::UseShm()) {
     LOGDRAW(("Drawing to Window 0x%lx will use MIT-SHM\n", mXWindow));
     return MakeUnique<WindowSurfaceX11SHM>(mXDisplay, mXWindow, mXVisual,
                                            mXDepth);
   }
-#endif  // MOZ_HAVE_SHMIMAGE
+#  endif  // MOZ_HAVE_SHMIMAGE
 
   LOGDRAW(("Drawing to Window 0x%lx will use XPutImage\n", mXWindow));
   return MakeUnique<WindowSurfaceX11Image>(mXDisplay, mXWindow, mXVisual,
                                            mXDepth, mIsShaped);
+#endif
 }
 
 already_AddRefed<gfx::DrawTarget>
@@ -112,6 +120,7 @@ WindowSurfaceProvider::StartRemoteDrawingInRegion(
   RefPtr<DrawTarget> dt = nullptr;
   if (!(dt = mWindowSurface->Lock(aInvalidRegion)) && mIsX11Display &&
       !mWindowSurface->IsFallback()) {
+#ifdef MOZ_X11
     // We can't use WindowSurfaceX11Image fallback on Wayland but
     // Lock() call on WindowSurfaceWayland should never fail.
     gfxWarningOnce()
@@ -119,6 +128,7 @@ WindowSurfaceProvider::StartRemoteDrawingInRegion(
     mWindowSurface = MakeUnique<WindowSurfaceX11Image>(
         mXDisplay, mXWindow, mXVisual, mXDepth, mIsShaped);
     dt = mWindowSurface->Lock(aInvalidRegion);
+#endif
   }
   return dt.forget();
 }
diff --git a/widget/gtk/WindowSurfaceProvider.h b/widget/gtk/WindowSurfaceProvider.h
index cbd36fa10b..5181af3534 100644
--- a/widget/gtk/WindowSurfaceProvider.h
+++ b/widget/gtk/WindowSurfaceProvider.h
@@ -17,8 +17,10 @@
 #ifdef MOZ_WAYLAND
 #  include <gdk/gdkwayland.h>
 #endif
-#include <X11/Xlib.h>  // for Window, Display, Visual, etc.
-#include "X11UndefineNone.h"
+#ifdef MOZ_X11
+#  include <X11/Xlib.h>  // for Window, Display, Visual, etc.
+#  include "X11UndefineNone.h"
+#endif
 
 class nsWindow;
 
@@ -40,8 +42,10 @@ class WindowSurfaceProvider final {
    * own the Display, Window, etc, and they must continue to exist
    * while WindowSurfaceProvider is used.
    */
+#ifdef MOZ_X11
   void Initialize(Display* aDisplay, Window aWindow, Visual* aVisual,
                   int aDepth, bool aIsShaped);
+#endif
 
 #ifdef MOZ_WAYLAND
   void Initialize(nsWindow* aWidget);
@@ -64,10 +68,12 @@ class WindowSurfaceProvider final {
 
   // Can we access X?
   bool mIsX11Display;
+#ifdef MOZ_X11
   Display* mXDisplay;
   Window mXWindow;
   Visual* mXVisual;
   int mXDepth;
+#endif
   UniquePtr<WindowSurface> mWindowSurface;
 #ifdef MOZ_WAYLAND
   nsWindow* mWidget;
diff --git a/widget/gtk/components.conf b/widget/gtk/components.conf
index a65c8e02b0..0ea1386ccf 100644
--- a/widget/gtk/components.conf
+++ b/widget/gtk/components.conf
@@ -84,7 +84,7 @@ Classes = [
     },
 ]
 
-if defined('MOZ_X11'):
+if defined('MOZ_X11') or defined('MOZ_WAYLAND'):
     Classes += [
         {
             'js_name': 'clipboard',
diff --git a/widget/gtk/moz.build b/widget/gtk/moz.build
index cddd45e49f..41843be30a 100644
--- a/widget/gtk/moz.build
+++ b/widget/gtk/moz.build
@@ -63,7 +63,7 @@ SOURCES += [
     "WaylandVsyncSource.cpp",  # conflicts with X11 headers
 ]
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     UNIFIED_SOURCES += [
         "CompositorWidgetChild.cpp",
         "CompositorWidgetParent.cpp",
@@ -86,20 +86,24 @@ if CONFIG["NS_PRINTING"]:
         "nsPrintSettingsServiceGTK.cpp",
     ]
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     UNIFIED_SOURCES += [
         "nsClipboard.cpp",
         "nsClipboardX11.cpp",
         "nsDragService.cpp",
         "WindowSurfaceProvider.cpp",
-        "WindowSurfaceX11.cpp",
-        "WindowSurfaceX11Image.cpp",
-        "WindowSurfaceXRender.cpp",
     ]
     EXPORTS.mozilla.widget += [
         "WindowSurfaceProvider.h",
     ]
 
+if CONFIG["MOZ_X11"]:
+    UNIFIED_SOURCES += [
+        "WindowSurfaceX11.cpp",
+        "WindowSurfaceX11Image.cpp",
+        "WindowSurfaceXRender.cpp",
+    ]
+
 if CONFIG["MOZ_WAYLAND"]:
     UNIFIED_SOURCES += [
         "DMABufLibWrapper.cpp",
diff --git a/widget/gtk/mozgtk/moz.build b/widget/gtk/mozgtk/moz.build
index 8288583745..9e75c14a16 100644
--- a/widget/gtk/mozgtk/moz.build
+++ b/widget/gtk/mozgtk/moz.build
@@ -4,4 +4,7 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-DIRS += ["stub", "gtk2", "gtk3"]
+DIRS += ["stub", "gtk3"]
+
+if CONFIG["MOZ_X11"]:
+    DIRS += ["gtk2"]
diff --git a/widget/gtk/mozgtk/mozgtk.c b/widget/gtk/mozgtk/mozgtk.c
index 8cc4da33f6..d750148323 100644
--- a/widget/gtk/mozgtk/mozgtk.c
+++ b/widget/gtk/mozgtk/mozgtk.c
@@ -663,9 +663,10 @@ STUB(gtk_object_get_type)
 #endif
 
 #ifndef GTK3_SYMBOLS
+#  ifdef MOZ_X11
 // Only define the following workaround when using GTK3, which we detect
 // by checking if GTK3 stubs are not provided.
-#  include <X11/Xlib.h>
+#    include <X11/Xlib.h>
 // Bug 1271100
 // We need to trick system Cairo into not using the XShm extension due to
 // a race condition in it that results in frequent BadAccess errors. Cairo
@@ -674,4 +675,5 @@ STUB(gtk_object_get_type)
 // mozgtk loads before libXext/libcairo and so this stub will take priority.
 // Our tree usage goes through xcb and remains unaffected by this.
 MOZ_EXPORT Bool XShmQueryExtension(Display* aDisplay) { return False; }
+#  endif
 #endif
diff --git a/widget/gtk/mozgtk/mozgtk.c.orig b/widget/gtk/mozgtk/mozgtk.c.orig
new file mode 100644
index 0000000000..8cc4da33f6
--- /dev/null
+++ b/widget/gtk/mozgtk/mozgtk.c.orig
@@ -0,0 +1,677 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Types.h"
+#include "mozilla/Assertions.h"
+
+#define STUB(symbol) \
+  MOZ_EXPORT void symbol(void) { MOZ_CRASH(); }
+
+#ifdef COMMON_SYMBOLS
+STUB(gdk_atom_intern)
+STUB(gdk_atom_name)
+STUB(gdk_beep)
+STUB(gdk_cairo_create)
+STUB(gdk_color_free)
+STUB(gdk_color_parse)
+STUB(gdk_cursor_new_for_display)
+STUB(gdk_cursor_new_from_name)
+STUB(gdk_cursor_new_from_pixbuf)
+STUB(gdk_display_close)
+STUB(gdk_display_get_default)
+STUB(gdk_display_get_default_screen)
+STUB(gdk_display_get_pointer)
+STUB(gdk_display_get_window_at_pointer)
+STUB(gdk_display_manager_get)
+STUB(gdk_display_manager_set_default_display)
+STUB(gdk_display_open)
+STUB(gdk_display_sync)
+STUB(gdk_display_warp_pointer)
+STUB(gdk_drag_context_get_actions)
+STUB(gdk_drag_context_get_dest_window)
+STUB(gdk_drag_context_get_source_window)
+STUB(gdk_drag_context_list_targets)
+STUB(gdk_drag_status)
+STUB(gdk_error_trap_pop)
+STUB(gdk_error_trap_push)
+STUB(gdk_event_copy)
+STUB(gdk_event_free)
+STUB(gdk_event_get_axis)
+STUB(gdk_event_get_time)
+STUB(gdk_event_handler_set)
+STUB(gdk_event_peek)
+STUB(gdk_event_put)
+STUB(gdk_flush)
+STUB(gdk_get_default_root_window)
+STUB(gdk_get_display)
+STUB(gdk_get_display_arg_name)
+STUB(gdk_get_program_class)
+STUB(gdk_keymap_get_default)
+STUB(gdk_keymap_get_direction)
+STUB(gdk_keymap_get_entries_for_keyval)
+STUB(gdk_keymap_get_for_display)
+STUB(gdk_keymap_have_bidi_layouts)
+STUB(gdk_keymap_translate_keyboard_state)
+STUB(gdk_keyval_name)
+STUB(gdk_keyval_to_unicode)
+STUB(gdk_pango_context_get)
+STUB(gdk_pointer_grab)
+STUB(gdk_pointer_ungrab)
+STUB(gdk_property_change)
+STUB(gdk_property_get)
+STUB(gdk_property_delete)
+STUB(gdk_screen_get_default)
+STUB(gdk_screen_get_display)
+STUB(gdk_screen_get_font_options)
+STUB(gdk_screen_get_height)
+STUB(gdk_screen_get_height_mm)
+STUB(gdk_screen_get_n_monitors)
+STUB(gdk_screen_get_monitor_at_window)
+STUB(gdk_screen_get_monitor_geometry)
+STUB(gdk_screen_get_monitor_height_mm)
+STUB(gdk_screen_get_number)
+STUB(gdk_screen_get_resolution)
+STUB(gdk_screen_get_rgba_visual)
+STUB(gdk_screen_get_root_window)
+STUB(gdk_screen_get_system_visual)
+STUB(gdk_screen_get_width)
+STUB(gdk_screen_height)
+STUB(gdk_screen_is_composited)
+STUB(gdk_screen_width)
+STUB(gdk_selection_owner_get)
+STUB(gdk_set_program_class)
+STUB(gdk_unicode_to_keyval)
+STUB(gdk_visual_get_depth)
+STUB(gdk_visual_get_system)
+STUB(gdk_window_add_filter)
+STUB(gdk_window_begin_move_drag)
+STUB(gdk_window_begin_resize_drag)
+STUB(gdk_window_destroy)
+STUB(gdk_window_focus)
+STUB(gdk_window_get_children)
+STUB(gdk_window_get_display)
+STUB(gdk_window_get_events)
+STUB(gdk_window_get_geometry)
+STUB(gdk_window_get_height)
+STUB(gdk_window_get_origin)
+STUB(gdk_window_get_parent)
+STUB(gdk_window_get_position)
+STUB(gdk_window_get_root_origin)
+STUB(gdk_window_get_screen)
+STUB(gtk_window_get_size)
+STUB(gdk_window_get_state)
+STUB(gdk_window_get_toplevel)
+STUB(gdk_window_get_update_area)
+STUB(gdk_window_get_user_data)
+STUB(gdk_window_get_visual)
+STUB(gdk_window_get_width)
+STUB(gdk_window_get_window_type)
+STUB(gdk_window_hide)
+STUB(gdk_window_input_shape_combine_region)
+STUB(gdk_window_invalidate_rect)
+STUB(gdk_window_invalidate_region)
+STUB(gdk_window_is_destroyed)
+STUB(gdk_window_is_visible)
+STUB(gdk_window_lower)
+STUB(gdk_window_move)
+STUB(gdk_window_move_resize)
+STUB(gdk_window_new)
+STUB(gdk_window_peek_children)
+STUB(gdk_window_process_updates)
+STUB(gdk_window_raise)
+STUB(gdk_window_remove_filter)
+STUB(gdk_window_reparent)
+STUB(gdk_window_resize)
+STUB(gdk_window_set_cursor)
+STUB(gdk_window_set_debug_updates)
+STUB(gdk_window_set_decorations)
+STUB(gdk_window_set_events)
+STUB(gdk_window_set_role)
+STUB(gdk_window_set_urgency_hint)
+STUB(gdk_window_set_user_data)
+STUB(gdk_window_shape_combine_region)
+STUB(gdk_window_show)
+STUB(gdk_window_show_unraised)
+STUB(gdk_x11_atom_to_xatom)
+STUB(gdk_x11_display_get_user_time)
+STUB(gdk_x11_display_get_xdisplay)
+STUB(gdk_x11_get_default_root_xwindow)
+STUB(gdk_x11_get_default_xdisplay)
+STUB(gdk_x11_get_server_time)
+STUB(gdk_x11_get_xatom_by_name)
+STUB(gdk_x11_get_xatom_by_name_for_display)
+STUB(gdk_x11_lookup_xdisplay)
+STUB(gdk_x11_screen_get_xscreen)
+STUB(gdk_x11_screen_get_screen_number)
+STUB(gdk_x11_screen_lookup_visual)
+STUB(gdk_x11_screen_supports_net_wm_hint)
+STUB(gdk_x11_visual_get_xvisual)
+STUB(gdk_x11_window_foreign_new_for_display)
+STUB(gdk_x11_window_lookup_for_display)
+STUB(gdk_x11_window_set_user_time)
+STUB(gdk_x11_xatom_to_atom)
+STUB(gdk_x11_set_sm_client_id)
+STUB(gtk_accel_label_new)
+STUB(gtk_alignment_get_type)
+STUB(gtk_alignment_new)
+STUB(gtk_alignment_set_padding)
+STUB(gtk_arrow_get_type)
+STUB(gtk_arrow_new)
+STUB(gtk_bindings_activate)
+STUB(gtk_bin_get_child)
+STUB(gtk_bin_get_type)
+STUB(gtk_border_free)
+STUB(gtk_box_get_type)
+STUB(gtk_box_pack_start)
+STUB(gtk_button_new)
+STUB(gtk_button_new_with_label)
+STUB(gtk_check_button_new_with_label)
+STUB(gtk_check_button_new_with_mnemonic)
+STUB(gtk_check_menu_item_new)
+STUB(gtk_check_version)
+STUB(gtk_clipboard_clear)
+STUB(gtk_clipboard_get)
+STUB(gtk_clipboard_request_contents)
+STUB(gtk_clipboard_request_text)
+STUB(gtk_clipboard_set_can_store)
+STUB(gtk_clipboard_set_with_data)
+STUB(gtk_clipboard_store)
+STUB(gtk_color_selection_dialog_get_color_selection)
+STUB(gtk_color_selection_dialog_get_type)
+STUB(gtk_color_selection_dialog_new)
+STUB(gtk_color_selection_get_current_color)
+STUB(gtk_color_selection_get_type)
+STUB(gtk_color_selection_set_current_color)
+STUB(gtk_combo_box_get_active)
+STUB(gtk_combo_box_get_type)
+STUB(gtk_combo_box_new)
+STUB(gtk_combo_box_new_with_entry)
+STUB(gtk_combo_box_set_active)
+STUB(gtk_combo_box_text_get_type)
+STUB(gtk_combo_box_text_new)
+STUB(gtk_container_add)
+STUB(gtk_container_forall)
+STUB(gtk_container_get_border_width)
+STUB(gtk_container_get_type)
+STUB(gtk_container_set_border_width)
+STUB(gtk_container_set_resize_mode)
+STUB(gtk_dialog_get_content_area)
+STUB(gtk_dialog_get_type)
+STUB(gtk_dialog_new_with_buttons)
+STUB(gtk_dialog_run)
+STUB(gtk_dialog_set_alternative_button_order)
+STUB(gtk_dialog_set_default_response)
+STUB(gtk_drag_begin)
+STUB(gtk_drag_dest_set)
+STUB(gtk_drag_finish)
+STUB(gtk_drag_get_data)
+STUB(gtk_drag_get_source_widget)
+STUB(gtk_drag_set_icon_pixbuf)
+STUB(gtk_drag_set_icon_widget)
+STUB(gtk_editable_get_type)
+STUB(gtk_editable_select_region)
+STUB(gtk_entry_get_text)
+STUB(gtk_entry_get_type)
+STUB(gtk_entry_new)
+STUB(gtk_entry_set_activates_default)
+STUB(gtk_entry_set_text)
+STUB(gtk_enumerate_printers)
+STUB(gtk_expander_new)
+STUB(gtk_file_chooser_add_filter)
+STUB(gtk_file_chooser_dialog_new)
+STUB(gtk_file_chooser_get_filenames)
+STUB(gtk_file_chooser_get_filter)
+STUB(gtk_file_chooser_get_preview_filename)
+STUB(gtk_file_chooser_get_type)
+STUB(gtk_file_chooser_get_uri)
+STUB(gtk_file_chooser_list_filters)
+STUB(gtk_file_chooser_set_current_folder)
+STUB(gtk_file_chooser_set_current_name)
+STUB(gtk_file_chooser_set_do_overwrite_confirmation)
+STUB(gtk_file_chooser_set_filename)
+STUB(gtk_file_chooser_set_filter)
+STUB(gtk_file_chooser_set_local_only)
+STUB(gtk_file_chooser_set_preview_widget)
+STUB(gtk_file_chooser_set_preview_widget_active)
+STUB(gtk_file_chooser_set_select_multiple)
+STUB(gtk_file_chooser_widget_get_type)
+STUB(gtk_file_filter_add_pattern)
+STUB(gtk_file_filter_new)
+STUB(gtk_file_filter_set_name)
+STUB(gtk_fixed_new)
+STUB(gtk_frame_new)
+STUB(gtk_get_current_event_time)
+STUB(gtk_grab_add)
+STUB(gtk_grab_remove)
+STUB(gtk_handle_box_new)
+STUB(gtk_hbox_new)
+STUB(gtk_icon_info_free)
+STUB(gtk_icon_info_load_icon)
+STUB(gtk_icon_set_add_source)
+STUB(gtk_icon_set_new)
+STUB(gtk_icon_set_render_icon)
+STUB(gtk_icon_set_unref)
+STUB(gtk_icon_size_lookup)
+STUB(gtk_icon_source_free)
+STUB(gtk_icon_source_new)
+STUB(gtk_icon_source_set_icon_name)
+STUB(gtk_icon_theme_add_builtin_icon)
+STUB(gtk_icon_theme_get_default)
+STUB(gtk_icon_theme_get_icon_sizes)
+STUB(gtk_icon_theme_lookup_by_gicon)
+STUB(gtk_icon_theme_lookup_icon)
+STUB(gtk_image_get_icon_name)
+STUB(gtk_image_get_type)
+STUB(gtk_image_new)
+STUB(gtk_image_new_from_icon_name)
+STUB(gtk_image_new_from_stock)
+STUB(gtk_image_set_from_pixbuf)
+STUB(gtk_im_context_filter_keypress)
+STUB(gtk_im_context_focus_in)
+STUB(gtk_im_context_focus_out)
+STUB(gtk_im_context_get_preedit_string)
+STUB(gtk_im_context_reset)
+STUB(gtk_im_context_set_client_window)
+STUB(gtk_im_context_set_cursor_location)
+STUB(gtk_im_context_set_surrounding)
+STUB(gtk_im_context_simple_new)
+STUB(gtk_im_multicontext_get_context_id)
+STUB(gtk_im_multicontext_get_type)
+STUB(gtk_im_multicontext_new)
+STUB(gtk_info_bar_get_type)
+STUB(gtk_info_bar_get_content_area)
+STUB(gtk_info_bar_new)
+STUB(gtk_init)
+STUB(gtk_invisible_new)
+STUB(gtk_key_snooper_install)
+STUB(gtk_key_snooper_remove)
+STUB(gtk_label_get_type)
+STUB(gtk_label_new)
+STUB(gtk_label_set_markup)
+STUB(gtk_link_button_new)
+STUB(gtk_main_do_event)
+STUB(gtk_main_iteration)
+STUB(gtk_menu_attach_to_widget)
+STUB(gtk_menu_bar_new)
+STUB(gtk_menu_get_type)
+STUB(gtk_menu_item_get_type)
+STUB(gtk_menu_item_new)
+STUB(gtk_menu_item_set_submenu)
+STUB(gtk_menu_new)
+STUB(gtk_menu_shell_append)
+STUB(gtk_menu_shell_get_type)
+STUB(gtk_misc_get_alignment)
+STUB(gtk_misc_get_padding)
+STUB(gtk_misc_get_type)
+STUB(gtk_misc_set_alignment)
+STUB(gtk_misc_set_padding)
+STUB(gtk_notebook_new)
+STUB(gtk_page_setup_copy)
+STUB(gtk_page_setup_get_bottom_margin)
+STUB(gtk_page_setup_get_left_margin)
+STUB(gtk_page_setup_get_orientation)
+STUB(gtk_page_setup_get_paper_size)
+STUB(gtk_page_setup_get_right_margin)
+STUB(gtk_page_setup_get_top_margin)
+STUB(gtk_page_setup_new)
+STUB(gtk_page_setup_set_bottom_margin)
+STUB(gtk_page_setup_set_left_margin)
+STUB(gtk_page_setup_set_orientation)
+STUB(gtk_page_setup_set_paper_size)
+STUB(gtk_page_setup_set_paper_size_and_default_margins)
+STUB(gtk_page_setup_set_right_margin)
+STUB(gtk_page_setup_set_top_margin)
+STUB(gtk_page_setup_to_key_file)
+STUB(gtk_paper_size_free)
+STUB(gtk_paper_size_get_display_name)
+STUB(gtk_paper_size_get_height)
+STUB(gtk_paper_size_get_name)
+STUB(gtk_paper_size_get_width)
+STUB(gtk_paper_size_is_custom)
+STUB(gtk_paper_size_is_equal)
+STUB(gtk_paper_size_new)
+STUB(gtk_paper_size_new_custom)
+STUB(gtk_paper_size_set_size)
+STUB(gtk_parse_args)
+STUB(gtk_plug_get_socket_window)
+STUB(gtk_plug_get_type)
+STUB(gtk_printer_accepts_pdf)
+STUB(gtk_printer_get_name)
+STUB(gtk_printer_get_type)
+STUB(gtk_printer_is_default)
+STUB(gtk_print_job_new)
+STUB(gtk_print_job_send)
+STUB(gtk_print_job_set_source_file)
+STUB(gtk_print_run_page_setup_dialog)
+STUB(gtk_print_settings_copy)
+STUB(gtk_print_settings_foreach)
+STUB(gtk_print_settings_get)
+STUB(gtk_print_settings_get_duplex)
+STUB(gtk_print_settings_get_n_copies)
+STUB(gtk_print_settings_get_page_ranges)
+STUB(gtk_print_settings_get_paper_size)
+STUB(gtk_print_settings_get_printer)
+STUB(gtk_print_settings_get_print_pages)
+STUB(gtk_print_settings_get_resolution)
+STUB(gtk_print_settings_get_reverse)
+STUB(gtk_print_settings_get_scale)
+STUB(gtk_print_settings_get_use_color)
+STUB(gtk_print_settings_has_key)
+STUB(gtk_print_settings_new)
+STUB(gtk_print_settings_set)
+STUB(gtk_print_settings_set_duplex)
+STUB(gtk_print_settings_set_n_copies)
+STUB(gtk_print_settings_set_orientation)
+STUB(gtk_print_settings_set_page_ranges)
+STUB(gtk_print_settings_set_paper_size)
+STUB(gtk_print_settings_set_printer)
+STUB(gtk_print_settings_set_print_pages)
+STUB(gtk_print_settings_set_resolution)
+STUB(gtk_print_settings_set_reverse)
+STUB(gtk_print_settings_set_scale)
+STUB(gtk_print_settings_set_use_color)
+STUB(gtk_print_unix_dialog_add_custom_tab)
+STUB(gtk_print_unix_dialog_get_page_setup)
+STUB(gtk_print_unix_dialog_get_selected_printer)
+STUB(gtk_print_unix_dialog_get_settings)
+STUB(gtk_print_unix_dialog_get_type)
+STUB(gtk_print_unix_dialog_new)
+STUB(gtk_print_unix_dialog_set_manual_capabilities)
+STUB(gtk_print_unix_dialog_set_page_setup)
+STUB(gtk_print_unix_dialog_set_settings)
+STUB(gtk_progress_bar_new)
+STUB(gtk_propagate_event)
+STUB(gtk_radio_button_get_type)
+STUB(gtk_radio_button_new_with_label)
+STUB(gtk_radio_button_new_with_mnemonic)
+STUB(gtk_radio_button_new_with_mnemonic_from_widget)
+STUB(gtk_range_get_min_slider_size)
+STUB(gtk_range_get_type)
+STUB(gtk_recent_manager_add_item)
+STUB(gtk_recent_manager_get_default)
+STUB(gtk_scrollbar_get_type)
+STUB(gtk_scrolled_window_new)
+STUB(gtk_selection_data_copy)
+STUB(gtk_selection_data_free)
+STUB(gtk_selection_data_get_data)
+STUB(gtk_selection_data_get_length)
+STUB(gtk_selection_data_get_selection)
+STUB(gtk_selection_data_get_target)
+STUB(gtk_selection_data_get_targets)
+STUB(gtk_selection_data_set)
+STUB(gtk_selection_data_set_pixbuf)
+STUB(gtk_selection_data_set_text)
+STUB(gtk_selection_data_targets_include_text)
+STUB(gtk_separator_get_type)
+STUB(gtk_separator_menu_item_new)
+STUB(gtk_separator_tool_item_new)
+STUB(gtk_settings_get_default)
+STUB(gtk_settings_get_for_screen)
+STUB(gtk_show_uri)
+STUB(gtk_socket_add_id)
+STUB(gtk_socket_get_id)
+STUB(gtk_socket_get_type)
+STUB(gtk_socket_get_plug_window)
+STUB(gtk_socket_new)
+STUB(gtk_spin_button_new)
+STUB(gtk_statusbar_new)
+STUB(gtk_style_lookup_icon_set)
+STUB(gtk_table_attach)
+STUB(gtk_table_get_type)
+STUB(gtk_table_new)
+STUB(gtk_target_list_add)
+STUB(gtk_target_list_add_image_targets)
+STUB(gtk_target_list_add_text_targets)
+STUB(gtk_target_list_new)
+STUB(gtk_target_list_unref)
+STUB(gtk_targets_include_image)
+STUB(gtk_targets_include_text)
+STUB(gtk_target_table_free)
+STUB(gtk_target_table_new_from_list)
+STUB(gtk_text_view_new)
+STUB(gtk_toggle_button_get_active)
+STUB(gtk_toggle_button_get_type)
+STUB(gtk_toggle_button_new)
+STUB(gtk_toggle_button_set_active)
+STUB(gtk_toggle_button_set_inconsistent)
+STUB(gtk_toolbar_new)
+STUB(gtk_tooltip_get_type)
+STUB(gtk_tree_view_append_column)
+STUB(gtk_tree_view_column_new)
+STUB(gtk_tree_view_column_set_title)
+STUB(gtk_tree_view_get_type)
+STUB(gtk_tree_view_new)
+STUB(gtk_vbox_new)
+STUB(gtk_widget_add_events)
+STUB(gtk_widget_class_find_style_property)
+STUB(gtk_widget_destroy)
+STUB(gtk_widget_destroyed)
+STUB(gtk_widget_ensure_style)
+STUB(gtk_widget_event)
+STUB(gtk_widget_get_accessible)
+STUB(gtk_widget_get_allocation)
+STUB(gtk_widget_get_default_direction)
+STUB(gtk_widget_get_display)
+STUB(gtk_widget_get_events)
+STUB(gtk_widget_get_has_window)
+STUB(gtk_widget_get_mapped)
+STUB(gtk_widget_get_parent)
+STUB(gtk_widget_get_parent_window)
+STUB(gtk_widget_get_realized)
+STUB(gtk_widget_get_screen)
+STUB(gtk_widget_get_settings)
+STUB(gtk_widget_get_style)
+STUB(gtk_widget_get_toplevel)
+STUB(gtk_widget_get_type)
+STUB(gtk_widget_get_visible)
+STUB(gtk_widget_get_visual)
+STUB(gtk_widget_get_window)
+STUB(gtk_widget_grab_focus)
+STUB(gtk_widget_has_focus)
+STUB(gtk_widget_has_grab)
+STUB(gtk_widget_hide)
+STUB(gtk_widget_is_focus)
+STUB(gtk_widget_is_toplevel)
+STUB(gtk_widget_map)
+STUB(gtk_widget_modify_bg)
+STUB(gtk_widget_realize)
+STUB(gtk_widget_reparent)
+STUB(gtk_widget_set_allocation)
+STUB(gtk_widget_set_app_paintable)
+STUB(gtk_window_set_auto_startup_notification)
+STUB(gtk_window_set_keep_above)
+STUB(gtk_window_set_opacity)
+STUB(gtk_window_set_screen)
+STUB(gtk_widget_set_can_focus)
+STUB(gtk_widget_set_direction)
+STUB(gtk_widget_set_double_buffered)
+STUB(gtk_widget_set_has_window)
+STUB(gtk_widget_set_mapped)
+STUB(gtk_widget_set_name)
+STUB(gtk_widget_set_parent)
+STUB(gtk_widget_set_parent_window)
+STUB(gtk_widget_set_realized)
+STUB(gtk_widget_set_redraw_on_allocate)
+STUB(gtk_widget_set_sensitive)
+STUB(gtk_widget_set_window)
+STUB(gtk_widget_show)
+STUB(gtk_widget_show_all)
+STUB(gtk_widget_size_allocate)
+STUB(gtk_widget_style_get)
+STUB(gtk_widget_unparent)
+STUB(gtk_widget_unrealize)
+STUB(gtk_window_deiconify)
+STUB(gtk_window_fullscreen)
+STUB(gtk_window_get_group)
+STUB(gtk_window_get_modal)
+STUB(gtk_window_get_transient_for)
+STUB(gtk_window_get_type)
+STUB(gtk_window_get_type_hint)
+STUB(gtk_window_get_window_type)
+STUB(gtk_window_group_add_window)
+STUB(gtk_window_group_get_current_grab)
+STUB(gtk_window_group_new)
+STUB(gtk_window_iconify)
+STUB(gtk_window_is_active)
+STUB(gtk_window_maximize)
+STUB(gtk_window_move)
+STUB(gtk_window_new)
+STUB(gtk_window_present_with_time)
+STUB(gtk_window_resize)
+STUB(gtk_window_set_accept_focus)
+STUB(gtk_window_set_decorated)
+STUB(gtk_window_set_deletable)
+STUB(gtk_window_set_destroy_with_parent)
+STUB(gtk_window_set_focus_on_map)
+STUB(gtk_window_set_geometry_hints)
+STUB(gtk_window_set_icon_name)
+STUB(gtk_window_set_modal)
+STUB(gtk_window_set_skip_taskbar_hint)
+STUB(gtk_window_set_startup_id)
+STUB(gtk_window_set_title)
+STUB(gtk_window_set_transient_for)
+STUB(gtk_window_set_type_hint)
+STUB(gtk_window_set_wmclass)
+STUB(gtk_window_unfullscreen)
+STUB(gtk_window_unmaximize)
+#endif
+
+#ifdef GTK3_SYMBOLS
+STUB(gtk_css_provider_load_from_data)
+STUB(gtk_css_provider_new)
+STUB(gdk_device_get_source)
+STUB(gdk_device_manager_get_client_pointer)
+STUB(gdk_disable_multidevice)
+STUB(gdk_device_manager_list_devices)
+STUB(gdk_display_get_device_manager)
+STUB(gdk_display_manager_open_display)
+STUB(gdk_error_trap_pop_ignored)
+STUB(gdk_event_get_source_device)
+STUB(gdk_screen_get_monitor_workarea)
+STUB(gdk_window_get_type)
+STUB(gdk_window_set_opaque_region)
+STUB(gdk_x11_window_get_xid)
+STUB(gdk_x11_display_get_type)
+STUB(gdk_wayland_display_get_type)
+STUB(gdk_wayland_display_get_wl_compositor)
+STUB(gdk_wayland_display_get_wl_display)
+STUB(gdk_wayland_window_get_wl_surface)
+STUB(gtk_box_new)
+STUB(gtk_cairo_should_draw_window)
+STUB(gtk_cairo_transform_to_window)
+STUB(gtk_combo_box_text_append)
+STUB(gtk_drag_set_icon_surface)
+STUB(gtk_get_major_version)
+STUB(gtk_get_micro_version)
+STUB(gtk_get_minor_version)
+STUB(gtk_icon_info_load_symbolic_for_context)
+STUB(gtk_menu_button_new)
+STUB(gtk_offscreen_window_new)
+STUB(gtk_paned_new)
+STUB(gtk_radio_menu_item_new)
+STUB(gtk_render_activity)
+STUB(gtk_render_arrow)
+STUB(gtk_render_background)
+STUB(gtk_render_check)
+STUB(gtk_render_expander)
+STUB(gtk_render_extension)
+STUB(gtk_render_focus)
+STUB(gtk_render_frame)
+STUB(gtk_render_frame_gap)
+STUB(gtk_render_handle)
+STUB(gtk_render_icon)
+STUB(gtk_render_line)
+STUB(gtk_render_option)
+STUB(gtk_render_slider)
+STUB(gtk_scale_new)
+STUB(gtk_scrollbar_new)
+STUB(gtk_style_context_add_class)
+STUB(gtk_style_context_add_provider)
+STUB(gtk_style_context_add_region)
+STUB(gtk_style_context_get)
+STUB(gtk_style_context_get_background_color)
+STUB(gtk_style_context_get_border)
+STUB(gtk_style_context_get_border_color)
+STUB(gtk_style_context_get_color)
+STUB(gtk_style_context_get_direction)
+STUB(gtk_style_context_get_margin)
+STUB(gtk_style_context_get_padding)
+STUB(gtk_style_context_get_path)
+STUB(gtk_style_context_get_property)
+STUB(gtk_style_context_get_state)
+STUB(gtk_style_context_get_style)
+STUB(gtk_style_context_has_class)
+STUB(gtk_style_context_invalidate)
+STUB(gtk_style_context_list_classes)
+STUB(gtk_style_context_new)
+STUB(gtk_style_context_remove_class)
+STUB(gtk_style_context_remove_region)
+STUB(gtk_style_context_restore)
+STUB(gtk_style_context_save)
+STUB(gtk_style_context_set_direction)
+STUB(gtk_style_context_set_path)
+STUB(gtk_style_context_set_parent)
+STUB(gtk_style_context_set_state)
+STUB(gtk_style_properties_lookup_property)
+STUB(gtk_style_provider_get_type)
+STUB(gtk_tree_view_column_get_button)
+STUB(gtk_widget_get_preferred_size)
+STUB(gtk_widget_get_preferred_width)
+STUB(gtk_widget_get_preferred_height)
+STUB(gtk_widget_get_state_flags)
+STUB(gtk_widget_get_style_context)
+STUB(gtk_widget_path_append_type)
+STUB(gtk_widget_path_copy)
+STUB(gtk_widget_path_free)
+STUB(gtk_widget_path_iter_add_class)
+STUB(gtk_widget_path_get_object_type)
+STUB(gtk_widget_path_length)
+STUB(gtk_widget_path_new)
+STUB(gtk_widget_path_unref)
+STUB(gtk_widget_set_valign)
+STUB(gtk_widget_set_visual)
+STUB(gtk_window_set_titlebar)
+STUB(gtk_app_chooser_dialog_new_for_content_type)
+STUB(gtk_app_chooser_get_type)
+STUB(gtk_app_chooser_get_app_info)
+STUB(gtk_app_chooser_dialog_get_type)
+STUB(gtk_app_chooser_dialog_set_heading)
+STUB(gtk_color_chooser_dialog_new)
+STUB(gtk_color_chooser_dialog_get_type)
+STUB(gtk_color_chooser_get_type)
+STUB(gtk_color_chooser_set_rgba)
+STUB(gtk_color_chooser_get_rgba)
+STUB(gtk_color_chooser_set_use_alpha)
+#endif
+
+#ifdef GTK2_SYMBOLS
+STUB(gdk_drawable_get_screen)
+STUB(gdk_rgb_get_colormap)
+STUB(gdk_rgb_get_visual)
+STUB(gdk_window_lookup)
+STUB(gdk_window_set_back_pixmap)
+STUB(gdk_x11_colormap_foreign_new)
+STUB(gdk_x11_colormap_get_xcolormap)
+STUB(gdk_x11_drawable_get_xdisplay)
+STUB(gdk_x11_drawable_get_xid)
+STUB(gdk_x11_window_get_drawable_impl)
+STUB(gdkx_visual_get)
+STUB(gtk_object_get_type)
+#endif
+
+#ifndef GTK3_SYMBOLS
+// Only define the following workaround when using GTK3, which we detect
+// by checking if GTK3 stubs are not provided.
+#  include <X11/Xlib.h>
+// Bug 1271100
+// We need to trick system Cairo into not using the XShm extension due to
+// a race condition in it that results in frequent BadAccess errors. Cairo
+// relies upon XShmQueryExtension to initially detect if XShm is available.
+// So we define our own stub that always indicates XShm not being present.
+// mozgtk loads before libXext/libcairo and so this stub will take priority.
+// Our tree usage goes through xcb and remains unaffected by this.
+MOZ_EXPORT Bool XShmQueryExtension(Display* aDisplay) { return False; }
+#endif
diff --git a/widget/gtk/nsClipboard.cpp b/widget/gtk/nsClipboard.cpp
index 42807845fb..e3a6b03976 100644
--- a/widget/gtk/nsClipboard.cpp
+++ b/widget/gtk/nsClipboard.cpp
@@ -93,7 +93,9 @@ NS_IMPL_ISUPPORTS(nsClipboard, nsIClipboard, nsIObserver)
 
 nsresult nsClipboard::Init(void) {
   if (gfxPlatformGtk::GetPlatform()->IsX11Display()) {
+#if defined(MOZ_X11)
     mContext = MakeUnique<nsRetrievalContextX11>();
+#endif
 #if defined(MOZ_WAYLAND)
   } else {
     mContext = MakeUnique<nsRetrievalContextWayland>();
diff --git a/widget/gtk/nsClipboardX11.cpp b/widget/gtk/nsClipboardX11.cpp
index 0439c2e68c..48e748b37e 100644
--- a/widget/gtk/nsClipboardX11.cpp
+++ b/widget/gtk/nsClipboardX11.cpp
@@ -22,14 +22,16 @@
 #include <gtk/gtk.h>
 
 // For manipulation of the X event queue
-#include <X11/Xlib.h>
-#include <poll.h>
-#include <gdk/gdkx.h>
-#include <sys/time.h>
-#include <sys/types.h>
-#include <errno.h>
-#include <unistd.h>
-#include "X11UndefineNone.h"
+#ifdef MOZ_X11
+#  include <X11/Xlib.h>
+#  include <poll.h>
+#  include <gdk/gdkx.h>
+#  include <sys/time.h>
+#  include <sys/types.h>
+#  include <errno.h>
+#  include <unistd.h>
+#  include "X11UndefineNone.h"
+#endif
 
 using namespace mozilla;
 
@@ -45,6 +47,7 @@ nsRetrievalContextX11::nsRetrievalContextX11()
       mClipboardDataLength(0),
       mTargetMIMEType(gdk_atom_intern("TARGETS", FALSE)) {}
 
+#ifdef MOZ_X11
 static void DispatchSelectionNotifyEvent(GtkWidget* widget, XEvent* xevent) {
   GdkEvent event = {};
   event.selection.type = GDK_SELECTION_NOTIFY;
@@ -97,12 +100,14 @@ static Bool checkEventProc(Display* display, XEvent* event, XPointer arg) {
 
   return X11False;
 }
+#endif
 
 bool nsRetrievalContextX11::WaitForX11Content() {
   if (mState == COMPLETED) {  // the request completed synchronously
     return true;
   }
 
+#ifdef MOZ_X11
   GdkDisplay* gdkDisplay = gdk_display_get_default();
   // gdk_display_get_default() returns null on headless
   if (gdkDisplay && GDK_IS_X11_DISPLAY(gdkDisplay)) {
@@ -145,6 +150,7 @@ bool nsRetrievalContextX11::WaitForX11Content() {
     } while ((poll_result == 1 && (pfd.revents & (POLLHUP | POLLERR)) == 0) ||
              (poll_result == -1 && errno == EINTR));
   }
+#endif
 #ifdef DEBUG_CLIPBOARD
   printf("exceeded clipboard timeout\n");
 #endif
diff --git a/widget/gtk/nsDragService.cpp b/widget/gtk/nsDragService.cpp
index 2a6101dcc0..36be75770b 100644
--- a/widget/gtk/nsDragService.cpp
+++ b/widget/gtk/nsDragService.cpp
@@ -23,7 +23,6 @@
 #include "prthread.h"
 #include <dlfcn.h>
 #include <gtk/gtk.h>
-#include <gdk/gdkx.h>
 #include "nsCRT.h"
 #include "mozilla/BasicEvents.h"
 #include "mozilla/Services.h"
@@ -32,7 +31,9 @@
 #include "mozilla/ScopeExit.h"
 #include "GRefPtr.h"
 
-#include "gfxXlibSurface.h"
+#ifdef MOZ_X11
+#  include "gfxXlibSurface.h"
+#endif
 #include "gfxContext.h"
 #include "nsImageToPixbuf.h"
 #include "nsPresContext.h"
diff --git a/widget/gtk/nsGtkKeyUtils.cpp b/widget/gtk/nsGtkKeyUtils.cpp
index c3bd7fca9e..34400560ad 100644
--- a/widget/gtk/nsGtkKeyUtils.cpp
+++ b/widget/gtk/nsGtkKeyUtils.cpp
@@ -12,14 +12,16 @@
 #include <gdk/gdkkeysyms.h>
 #include <algorithm>
 #include <gdk/gdk.h>
-#include <gdk/gdkx.h>
 #include <dlfcn.h>
 #include <gdk/gdkkeysyms-compat.h>
-#include <X11/XKBlib.h>
-#include "X11UndefineNone.h"
+#ifdef MOZ_X11
+#  include <gdk/gdkx.h>
+#  include <X11/XKBlib.h>
+#  include "X11UndefineNone.h"
+#endif
 #include "IMContextWrapper.h"
 #include "WidgetUtils.h"
-#include "keysym2ucs.h"
+#include "x11/keysym2ucs.h"
 #include "nsContentUtils.h"
 #include "nsGtkUtils.h"
 #include "nsIBidiKeyboard.h"
@@ -50,7 +52,9 @@ LazyLogModule gKeymapWrapperLog("KeymapWrapperWidgets");
 
 KeymapWrapper* KeymapWrapper::sInstance = nullptr;
 guint KeymapWrapper::sLastRepeatableHardwareKeyCode = 0;
+#ifdef MOZ_X11
 Time KeymapWrapper::sLastRepeatableKeyTime = 0;
+#endif
 KeymapWrapper::RepeatState KeymapWrapper::sRepeatState =
     KeymapWrapper::NOT_PRESSED;
 
@@ -348,9 +352,11 @@ KeymapWrapper::KeymapWrapper()
 
   g_object_ref(mGdkKeymap);
 
+#ifdef MOZ_X11
   if (gfxPlatformGtk::GetPlatform()->IsX11Display()) {
     InitXKBExtension();
   }
+#endif
 
   Init();
 }
@@ -368,7 +374,9 @@ void KeymapWrapper::Init() {
   memset(mModifierMasks, 0, sizeof(mModifierMasks));
 
   if (gfxPlatformGtk::GetPlatform()->IsX11Display()) {
+#ifdef MOZ_X11
     InitBySystemSettingsX11();
+#endif
   }
 #ifdef MOZ_WAYLAND
   else {
@@ -376,7 +384,9 @@ void KeymapWrapper::Init() {
   }
 #endif
 
+#ifdef MOZ_X11
   gdk_window_add_filter(nullptr, FilterEvents, this);
+#endif
 
   MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
           ("%p Init, CapsLock=0x%X, NumLock=0x%X, "
@@ -389,6 +399,7 @@ void KeymapWrapper::Init() {
            GetModifierMask(SUPER), GetModifierMask(HYPER)));
 }
 
+#ifdef MOZ_X11
 void KeymapWrapper::InitXKBExtension() {
   PodZero(&mKeyboardState);
 
@@ -621,6 +632,7 @@ void KeymapWrapper::InitBySystemSettingsX11() {
   XFreeModifiermap(xmodmap);
   XFree(xkeymap);
 }
+#endif
 
 #ifdef MOZ_WAYLAND
 void KeymapWrapper::SetModifierMask(xkb_keymap* aKeymap,
@@ -778,6 +790,7 @@ void KeymapWrapper::InitBySystemSettingsWayland() {
 #endif
 
 KeymapWrapper::~KeymapWrapper() {
+#ifdef MOZ_X11
   gdk_window_remove_filter(nullptr, FilterEvents, this);
   if (mOnKeysChangedSignalHandle) {
     g_signal_handler_disconnect(mGdkKeymap, mOnKeysChangedSignalHandle);
@@ -785,10 +798,12 @@ KeymapWrapper::~KeymapWrapper() {
   if (mOnDirectionChangedSignalHandle) {
     g_signal_handler_disconnect(mGdkKeymap, mOnDirectionChangedSignalHandle);
   }
+#endif
   g_object_unref(mGdkKeymap);
   MOZ_LOG(gKeymapWrapperLog, LogLevel::Info, ("%p Destructor", this));
 }
 
+#ifdef MOZ_X11
 /* static */
 GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
                                             GdkEvent* aGdkEvent,
@@ -902,6 +917,7 @@ GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
 
   return GDK_FILTER_CONTINUE;
 }
+#endif
 
 static void ResetBidiKeyboard() {
   // Reset the bidi keyboard settings for the new GdkKeymap
@@ -1728,6 +1744,7 @@ void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
   // key release events, the result isn't what we want.
   guint modifierState = aGdkKeyEvent->state;
   GdkDisplay* gdkDisplay = gdk_display_get_default();
+#ifdef MOZ_X11
   if (aGdkKeyEvent->is_modifier && GDK_IS_X11_DISPLAY(gdkDisplay)) {
     Display* display = gdk_x11_display_get_xdisplay(gdkDisplay);
     if (XEventsQueued(display, QueuedAfterReading)) {
@@ -1744,6 +1761,7 @@ void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
       }
     }
   }
+#endif
   InitInputEvent(aKeyEvent, modifierState);
 
   switch (aGdkKeyEvent->keyval) {
@@ -1991,11 +2009,15 @@ bool KeymapWrapper::IsLatinGroup(guint8 aGroup) {
 }
 
 bool KeymapWrapper::IsAutoRepeatableKey(guint aHardwareKeyCode) {
+#ifdef MOZ_X11
   uint8_t indexOfArray = aHardwareKeyCode / 8;
   MOZ_ASSERT(indexOfArray < ArrayLength(mKeyboardState.auto_repeats),
              "invalid index");
   char bitMask = 1 << (aHardwareKeyCode % 8);
   return (mKeyboardState.auto_repeats[indexOfArray] & bitMask) != 0;
+#else
+  return false;
+#endif
 }
 
 /* static */
diff --git a/widget/gtk/nsGtkKeyUtils.cpp.orig b/widget/gtk/nsGtkKeyUtils.cpp.orig
new file mode 100644
index 0000000000..c3bd7fca9e
--- /dev/null
+++ b/widget/gtk/nsGtkKeyUtils.cpp.orig
@@ -0,0 +1,2379 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "mozilla/Logging.h"
+
+#include "nsGtkKeyUtils.h"
+
+#include <gdk/gdkkeysyms.h>
+#include <algorithm>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <dlfcn.h>
+#include <gdk/gdkkeysyms-compat.h>
+#include <X11/XKBlib.h>
+#include "X11UndefineNone.h"
+#include "IMContextWrapper.h"
+#include "WidgetUtils.h"
+#include "keysym2ucs.h"
+#include "nsContentUtils.h"
+#include "nsGtkUtils.h"
+#include "nsIBidiKeyboard.h"
+#include "nsPrintfCString.h"
+#include "nsServiceManagerUtils.h"
+#include "nsWindow.h"
+#include "gfxPlatformGtk.h"
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/MouseEvents.h"
+#include "mozilla/TextEventDispatcher.h"
+#include "mozilla/TextEvents.h"
+
+#ifdef MOZ_WAYLAND
+#  include <sys/mman.h>
+#  include "nsWaylandDisplay.h"
+#endif
+
+namespace mozilla {
+namespace widget {
+
+LazyLogModule gKeymapWrapperLog("KeymapWrapperWidgets");
+
+#define IS_ASCII_ALPHABETICAL(key) \
+  ((('a' <= key) && (key <= 'z')) || (('A' <= key) && (key <= 'Z')))
+
+#define MOZ_MODIFIER_KEYS "MozKeymapWrapper"
+
+KeymapWrapper* KeymapWrapper::sInstance = nullptr;
+guint KeymapWrapper::sLastRepeatableHardwareKeyCode = 0;
+Time KeymapWrapper::sLastRepeatableKeyTime = 0;
+KeymapWrapper::RepeatState KeymapWrapper::sRepeatState =
+    KeymapWrapper::NOT_PRESSED;
+
+static const char* GetBoolName(bool aBool) { return aBool ? "TRUE" : "FALSE"; }
+
+static const char* GetStatusName(nsEventStatus aStatus) {
+  switch (aStatus) {
+    case nsEventStatus_eConsumeDoDefault:
+      return "nsEventStatus_eConsumeDoDefault";
+    case nsEventStatus_eConsumeNoDefault:
+      return "nsEventStatus_eConsumeNoDefault";
+    case nsEventStatus_eIgnore:
+      return "nsEventStatus_eIgnore";
+    case nsEventStatus_eSentinel:
+      return "nsEventStatus_eSentinel";
+    default:
+      return "Illegal value";
+  }
+}
+
+static const nsCString GetKeyLocationName(uint32_t aLocation) {
+  switch (aLocation) {
+    case eKeyLocationLeft:
+      return "KEY_LOCATION_LEFT"_ns;
+    case eKeyLocationRight:
+      return "KEY_LOCATION_RIGHT"_ns;
+    case eKeyLocationStandard:
+      return "KEY_LOCATION_STANDARD"_ns;
+    case eKeyLocationNumpad:
+      return "KEY_LOCATION_NUMPAD"_ns;
+    default:
+      return nsPrintfCString("Unknown (0x%04X)", aLocation);
+  }
+}
+
+static const nsCString GetCharacterCodeName(char16_t aChar) {
+  switch (aChar) {
+    case 0x0000:
+      return "NULL (0x0000)"_ns;
+    case 0x0008:
+      return "BACKSPACE (0x0008)"_ns;
+    case 0x0009:
+      return "CHARACTER TABULATION (0x0009)"_ns;
+    case 0x000A:
+      return "LINE FEED (0x000A)"_ns;
+    case 0x000B:
+      return "LINE TABULATION (0x000B)"_ns;
+    case 0x000C:
+      return "FORM FEED (0x000C)"_ns;
+    case 0x000D:
+      return "CARRIAGE RETURN (0x000D)"_ns;
+    case 0x0018:
+      return "CANCEL (0x0018)"_ns;
+    case 0x001B:
+      return "ESCAPE (0x001B)"_ns;
+    case 0x0020:
+      return "SPACE (0x0020)"_ns;
+    case 0x007F:
+      return "DELETE (0x007F)"_ns;
+    case 0x00A0:
+      return "NO-BREAK SPACE (0x00A0)"_ns;
+    case 0x00AD:
+      return "SOFT HYPHEN (0x00AD)"_ns;
+    case 0x2000:
+      return "EN QUAD (0x2000)"_ns;
+    case 0x2001:
+      return "EM QUAD (0x2001)"_ns;
+    case 0x2002:
+      return "EN SPACE (0x2002)"_ns;
+    case 0x2003:
+      return "EM SPACE (0x2003)"_ns;
+    case 0x2004:
+      return "THREE-PER-EM SPACE (0x2004)"_ns;
+    case 0x2005:
+      return "FOUR-PER-EM SPACE (0x2005)"_ns;
+    case 0x2006:
+      return "SIX-PER-EM SPACE (0x2006)"_ns;
+    case 0x2007:
+      return "FIGURE SPACE (0x2007)"_ns;
+    case 0x2008:
+      return "PUNCTUATION SPACE (0x2008)"_ns;
+    case 0x2009:
+      return "THIN SPACE (0x2009)"_ns;
+    case 0x200A:
+      return "HAIR SPACE (0x200A)"_ns;
+    case 0x200B:
+      return "ZERO WIDTH SPACE (0x200B)"_ns;
+    case 0x200C:
+      return "ZERO WIDTH NON-JOINER (0x200C)"_ns;
+    case 0x200D:
+      return "ZERO WIDTH JOINER (0x200D)"_ns;
+    case 0x200E:
+      return "LEFT-TO-RIGHT MARK (0x200E)"_ns;
+    case 0x200F:
+      return "RIGHT-TO-LEFT MARK (0x200F)"_ns;
+    case 0x2029:
+      return "PARAGRAPH SEPARATOR (0x2029)"_ns;
+    case 0x202A:
+      return "LEFT-TO-RIGHT EMBEDDING (0x202A)"_ns;
+    case 0x202B:
+      return "RIGHT-TO-LEFT EMBEDDING (0x202B)"_ns;
+    case 0x202D:
+      return "LEFT-TO-RIGHT OVERRIDE (0x202D)"_ns;
+    case 0x202E:
+      return "RIGHT-TO-LEFT OVERRIDE (0x202E)"_ns;
+    case 0x202F:
+      return "NARROW NO-BREAK SPACE (0x202F)"_ns;
+    case 0x205F:
+      return "MEDIUM MATHEMATICAL SPACE (0x205F)"_ns;
+    case 0x2060:
+      return "WORD JOINER (0x2060)"_ns;
+    case 0x2066:
+      return "LEFT-TO-RIGHT ISOLATE (0x2066)"_ns;
+    case 0x2067:
+      return "RIGHT-TO-LEFT ISOLATE (0x2067)"_ns;
+    case 0x3000:
+      return "IDEOGRAPHIC SPACE (0x3000)"_ns;
+    case 0xFEFF:
+      return "ZERO WIDTH NO-BREAK SPACE (0xFEFF)"_ns;
+    default: {
+      if (aChar < ' ' || (aChar >= 0x80 && aChar < 0xA0)) {
+        return nsPrintfCString("control (0x%04X)", aChar);
+      }
+      if (NS_IS_HIGH_SURROGATE(aChar)) {
+        return nsPrintfCString("high surrogate (0x%04X)", aChar);
+      }
+      if (NS_IS_LOW_SURROGATE(aChar)) {
+        return nsPrintfCString("low surrogate (0x%04X)", aChar);
+      }
+      return nsPrintfCString("'%s' (0x%04X)",
+                             NS_ConvertUTF16toUTF8(nsAutoString(aChar)).get(),
+                             aChar);
+    }
+  }
+}
+
+static const nsCString GetCharacterCodeNames(const char16_t* aChars,
+                                             uint32_t aLength) {
+  if (!aLength) {
+    return "\"\""_ns;
+  }
+  nsCString result;
+  for (uint32_t i = 0; i < aLength; ++i) {
+    if (!result.IsEmpty()) {
+      result.AppendLiteral(", ");
+    } else {
+      result.AssignLiteral("\"");
+    }
+    result.Append(GetCharacterCodeName(aChars[i]));
+  }
+  result.AppendLiteral("\"");
+  return result;
+}
+
+static const nsCString GetCharacterCodeNames(const nsAString& aString) {
+  return GetCharacterCodeNames(aString.BeginReading(), aString.Length());
+}
+
+/* static */ const char* KeymapWrapper::GetModifierName(Modifier aModifier) {
+  switch (aModifier) {
+    case CAPS_LOCK:
+      return "CapsLock";
+    case NUM_LOCK:
+      return "NumLock";
+    case SCROLL_LOCK:
+      return "ScrollLock";
+    case SHIFT:
+      return "Shift";
+    case CTRL:
+      return "Ctrl";
+    case ALT:
+      return "Alt";
+    case SUPER:
+      return "Super";
+    case HYPER:
+      return "Hyper";
+    case META:
+      return "Meta";
+    case LEVEL3:
+      return "Level3";
+    case LEVEL5:
+      return "Level5";
+    case NOT_MODIFIER:
+      return "NotModifier";
+    default:
+      return "InvalidValue";
+  }
+}
+
+/* static */ KeymapWrapper::Modifier KeymapWrapper::GetModifierForGDKKeyval(
+    guint aGdkKeyval) {
+  switch (aGdkKeyval) {
+    case GDK_Caps_Lock:
+      return CAPS_LOCK;
+    case GDK_Num_Lock:
+      return NUM_LOCK;
+    case GDK_Scroll_Lock:
+      return SCROLL_LOCK;
+    case GDK_Shift_Lock:
+    case GDK_Shift_L:
+    case GDK_Shift_R:
+      return SHIFT;
+    case GDK_Control_L:
+    case GDK_Control_R:
+      return CTRL;
+    case GDK_Alt_L:
+    case GDK_Alt_R:
+      return ALT;
+    case GDK_Super_L:
+    case GDK_Super_R:
+      return SUPER;
+    case GDK_Hyper_L:
+    case GDK_Hyper_R:
+      return HYPER;
+    case GDK_Meta_L:
+    case GDK_Meta_R:
+      return META;
+    case GDK_ISO_Level3_Shift:
+    case GDK_Mode_switch:
+      return LEVEL3;
+    case GDK_ISO_Level5_Shift:
+      return LEVEL5;
+    default:
+      return NOT_MODIFIER;
+  }
+}
+
+guint KeymapWrapper::GetModifierMask(Modifier aModifier) const {
+  switch (aModifier) {
+    case CAPS_LOCK:
+      return GDK_LOCK_MASK;
+    case NUM_LOCK:
+      return mModifierMasks[INDEX_NUM_LOCK];
+    case SCROLL_LOCK:
+      return mModifierMasks[INDEX_SCROLL_LOCK];
+    case SHIFT:
+      return GDK_SHIFT_MASK;
+    case CTRL:
+      return GDK_CONTROL_MASK;
+    case ALT:
+      return mModifierMasks[INDEX_ALT];
+    case SUPER:
+      return mModifierMasks[INDEX_SUPER];
+    case HYPER:
+      return mModifierMasks[INDEX_HYPER];
+    case META:
+      return mModifierMasks[INDEX_META];
+    case LEVEL3:
+      return mModifierMasks[INDEX_LEVEL3];
+    case LEVEL5:
+      return mModifierMasks[INDEX_LEVEL5];
+    default:
+      return 0;
+  }
+}
+
+KeymapWrapper::ModifierKey* KeymapWrapper::GetModifierKey(
+    guint aHardwareKeycode) {
+  for (uint32_t i = 0; i < mModifierKeys.Length(); i++) {
+    ModifierKey& key = mModifierKeys[i];
+    if (key.mHardwareKeycode == aHardwareKeycode) {
+      return &key;
+    }
+  }
+  return nullptr;
+}
+
+/* static */
+KeymapWrapper* KeymapWrapper::GetInstance() {
+  if (sInstance) {
+    sInstance->Init();
+    return sInstance;
+  }
+
+  sInstance = new KeymapWrapper();
+  return sInstance;
+}
+
+/* static */
+void KeymapWrapper::Shutdown() {
+  if (sInstance) {
+    delete sInstance;
+    sInstance = nullptr;
+  }
+}
+
+KeymapWrapper::KeymapWrapper()
+    : mInitialized(false),
+      mGdkKeymap(gdk_keymap_get_default()),
+      mXKBBaseEventCode(0),
+      mOnKeysChangedSignalHandle(0),
+      mOnDirectionChangedSignalHandle(0) {
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("%p Constructor, mGdkKeymap=%p", this, mGdkKeymap));
+
+  g_object_ref(mGdkKeymap);
+
+  if (gfxPlatformGtk::GetPlatform()->IsX11Display()) {
+    InitXKBExtension();
+  }
+
+  Init();
+}
+
+void KeymapWrapper::Init() {
+  if (mInitialized) {
+    return;
+  }
+  mInitialized = true;
+
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("%p Init, mGdkKeymap=%p", this, mGdkKeymap));
+
+  mModifierKeys.Clear();
+  memset(mModifierMasks, 0, sizeof(mModifierMasks));
+
+  if (gfxPlatformGtk::GetPlatform()->IsX11Display()) {
+    InitBySystemSettingsX11();
+  }
+#ifdef MOZ_WAYLAND
+  else {
+    InitBySystemSettingsWayland();
+  }
+#endif
+
+  gdk_window_add_filter(nullptr, FilterEvents, this);
+
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("%p Init, CapsLock=0x%X, NumLock=0x%X, "
+           "ScrollLock=0x%X, Level3=0x%X, Level5=0x%X, "
+           "Shift=0x%X, Ctrl=0x%X, Alt=0x%X, Meta=0x%X, Super=0x%X, Hyper=0x%X",
+           this, GetModifierMask(CAPS_LOCK), GetModifierMask(NUM_LOCK),
+           GetModifierMask(SCROLL_LOCK), GetModifierMask(LEVEL3),
+           GetModifierMask(LEVEL5), GetModifierMask(SHIFT),
+           GetModifierMask(CTRL), GetModifierMask(ALT), GetModifierMask(META),
+           GetModifierMask(SUPER), GetModifierMask(HYPER)));
+}
+
+void KeymapWrapper::InitXKBExtension() {
+  PodZero(&mKeyboardState);
+
+  int xkbMajorVer = XkbMajorVersion;
+  int xkbMinorVer = XkbMinorVersion;
+  if (!XkbLibraryVersion(&xkbMajorVer, &xkbMinorVer)) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p InitXKBExtension failed due to failure of "
+             "XkbLibraryVersion()",
+             this));
+    return;
+  }
+
+  Display* display = gdk_x11_display_get_xdisplay(gdk_display_get_default());
+
+  // XkbLibraryVersion() set xkbMajorVer and xkbMinorVer to that of the
+  // library, which may be newer than what is required of the server in
+  // XkbQueryExtension(), so these variables should be reset to
+  // XkbMajorVersion and XkbMinorVersion before the XkbQueryExtension call.
+  xkbMajorVer = XkbMajorVersion;
+  xkbMinorVer = XkbMinorVersion;
+  int opcode, baseErrorCode;
+  if (!XkbQueryExtension(display, &opcode, &mXKBBaseEventCode, &baseErrorCode,
+                         &xkbMajorVer, &xkbMinorVer)) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p InitXKBExtension failed due to failure of "
+             "XkbQueryExtension(), display=0x%p",
+             this, display));
+    return;
+  }
+
+  if (!XkbSelectEventDetails(display, XkbUseCoreKbd, XkbStateNotify,
+                             XkbModifierStateMask, XkbModifierStateMask)) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p InitXKBExtension failed due to failure of "
+             "XkbSelectEventDetails() for XModifierStateMask, display=0x%p",
+             this, display));
+    return;
+  }
+
+  if (!XkbSelectEventDetails(display, XkbUseCoreKbd, XkbControlsNotify,
+                             XkbPerKeyRepeatMask, XkbPerKeyRepeatMask)) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p InitXKBExtension failed due to failure of "
+             "XkbSelectEventDetails() for XkbControlsNotify, display=0x%p",
+             this, display));
+    return;
+  }
+
+  if (!XGetKeyboardControl(display, &mKeyboardState)) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p InitXKBExtension failed due to failure of "
+             "XGetKeyboardControl(), display=0x%p",
+             this, display));
+    return;
+  }
+
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("%p InitXKBExtension, Succeeded", this));
+}
+
+void KeymapWrapper::InitBySystemSettingsX11() {
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("%p InitBySystemSettingsX11, mGdkKeymap=%p", this, mGdkKeymap));
+
+  if (!mOnKeysChangedSignalHandle) {
+    mOnKeysChangedSignalHandle = g_signal_connect(
+        mGdkKeymap, "keys-changed", (GCallback)OnKeysChanged, this);
+  }
+  if (!mOnDirectionChangedSignalHandle) {
+    mOnDirectionChangedSignalHandle = g_signal_connect(
+        mGdkKeymap, "direction-changed", (GCallback)OnDirectionChanged, this);
+  }
+
+  Display* display = gdk_x11_display_get_xdisplay(gdk_display_get_default());
+
+  int min_keycode = 0;
+  int max_keycode = 0;
+  XDisplayKeycodes(display, &min_keycode, &max_keycode);
+
+  int keysyms_per_keycode = 0;
+  KeySym* xkeymap =
+      XGetKeyboardMapping(display, min_keycode, max_keycode - min_keycode + 1,
+                          &keysyms_per_keycode);
+  if (!xkeymap) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p InitBySystemSettings, "
+             "Failed due to null xkeymap",
+             this));
+    return;
+  }
+
+  XModifierKeymap* xmodmap = XGetModifierMapping(display);
+  if (!xmodmap) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p InitBySystemSettings, "
+             "Failed due to null xmodmap",
+             this));
+    XFree(xkeymap);
+    return;
+  }
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("%p InitBySystemSettings, min_keycode=%d, "
+           "max_keycode=%d, keysyms_per_keycode=%d, max_keypermod=%d",
+           this, min_keycode, max_keycode, keysyms_per_keycode,
+           xmodmap->max_keypermod));
+
+  // The modifiermap member of the XModifierKeymap structure contains 8 sets
+  // of max_keypermod KeyCodes, one for each modifier in the order Shift,
+  // Lock, Control, Mod1, Mod2, Mod3, Mod4, and Mod5.
+  // Only nonzero KeyCodes have meaning in each set, and zero KeyCodes are
+  // ignored.
+
+  // Note that two or more modifiers may use one modifier flag.  E.g.,
+  // on Ubuntu 10.10, Alt and Meta share the Mod1 in default settings.
+  // And also Super and Hyper share the Mod4. In such cases, we need to
+  // decide which modifier flag means one of DOM modifiers.
+
+  // mod[0] is Modifier introduced by Mod1.
+  Modifier mod[5];
+  int32_t foundLevel[5];
+  for (uint32_t i = 0; i < ArrayLength(mod); i++) {
+    mod[i] = NOT_MODIFIER;
+    foundLevel[i] = INT32_MAX;
+  }
+  const uint32_t map_size = 8 * xmodmap->max_keypermod;
+  for (uint32_t i = 0; i < map_size; i++) {
+    KeyCode keycode = xmodmap->modifiermap[i];
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p InitBySystemSettings, "
+             "  i=%d, keycode=0x%08X",
+             this, i, keycode));
+    if (!keycode || keycode < min_keycode || keycode > max_keycode) {
+      continue;
+    }
+
+    ModifierKey* modifierKey = GetModifierKey(keycode);
+    if (!modifierKey) {
+      modifierKey = mModifierKeys.AppendElement(ModifierKey(keycode));
+    }
+
+    const KeySym* syms =
+        xkeymap + (keycode - min_keycode) * keysyms_per_keycode;
+    const uint32_t bit = i / xmodmap->max_keypermod;
+    modifierKey->mMask |= 1 << bit;
+
+    // We need to know the meaning of Mod1, Mod2, Mod3, Mod4 and Mod5.
+    // Let's skip if current map is for others.
+    if (bit < 3) {
+      continue;
+    }
+
+    const int32_t modIndex = bit - 3;
+    for (int32_t j = 0; j < keysyms_per_keycode; j++) {
+      Modifier modifier = GetModifierForGDKKeyval(syms[j]);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("%p InitBySystemSettings, "
+               "    Mod%d, j=%d, syms[j]=%s(0x%lX), modifier=%s",
+               this, modIndex + 1, j, gdk_keyval_name(syms[j]), syms[j],
+               GetModifierName(modifier)));
+
+      switch (modifier) {
+        case NOT_MODIFIER:
+          // Don't overwrite the stored information with
+          // NOT_MODIFIER.
+          break;
+        case CAPS_LOCK:
+        case SHIFT:
+        case CTRL:
+          // Ignore the modifiers defined in GDK spec. They shouldn't
+          // be mapped to Mod1-5 because they must not work on native
+          // GTK applications.
+          break;
+        default:
+          // If new modifier is found in higher level than stored
+          // value, we don't need to overwrite it.
+          if (j > foundLevel[modIndex]) {
+            break;
+          }
+          // If new modifier is more important than stored value,
+          // we should overwrite it with new modifier.
+          if (j == foundLevel[modIndex]) {
+            mod[modIndex] = std::min(modifier, mod[modIndex]);
+            break;
+          }
+          foundLevel[modIndex] = j;
+          mod[modIndex] = modifier;
+          break;
+      }
+    }
+  }
+
+  for (uint32_t i = 0; i < COUNT_OF_MODIFIER_INDEX; i++) {
+    Modifier modifier;
+    switch (i) {
+      case INDEX_NUM_LOCK:
+        modifier = NUM_LOCK;
+        break;
+      case INDEX_SCROLL_LOCK:
+        modifier = SCROLL_LOCK;
+        break;
+      case INDEX_ALT:
+        modifier = ALT;
+        break;
+      case INDEX_META:
+        modifier = META;
+        break;
+      case INDEX_SUPER:
+        modifier = SUPER;
+        break;
+      case INDEX_HYPER:
+        modifier = HYPER;
+        break;
+      case INDEX_LEVEL3:
+        modifier = LEVEL3;
+        break;
+      case INDEX_LEVEL5:
+        modifier = LEVEL5;
+        break;
+      default:
+        MOZ_CRASH("All indexes must be handled here");
+    }
+    for (uint32_t j = 0; j < ArrayLength(mod); j++) {
+      if (modifier == mod[j]) {
+        mModifierMasks[i] |= 1 << (j + 3);
+      }
+    }
+  }
+
+  XFreeModifiermap(xmodmap);
+  XFree(xkeymap);
+}
+
+#ifdef MOZ_WAYLAND
+void KeymapWrapper::SetModifierMask(xkb_keymap* aKeymap,
+                                    ModifierIndex aModifierIndex,
+                                    const char* aModifierName) {
+  static auto sXkbKeymapModGetIndex =
+      (xkb_mod_index_t(*)(struct xkb_keymap*, const char*))dlsym(
+          RTLD_DEFAULT, "xkb_keymap_mod_get_index");
+
+  xkb_mod_index_t index = sXkbKeymapModGetIndex(aKeymap, aModifierName);
+  if (index != XKB_MOD_INVALID) {
+    mModifierMasks[aModifierIndex] = (1 << index);
+  }
+}
+
+void KeymapWrapper::SetModifierMasks(xkb_keymap* aKeymap) {
+  KeymapWrapper* keymapWrapper = GetInstance();
+
+  // This mapping is derived from get_xkb_modifiers() at gdkkeys-wayland.c
+  keymapWrapper->SetModifierMask(aKeymap, INDEX_NUM_LOCK, XKB_MOD_NAME_NUM);
+  keymapWrapper->SetModifierMask(aKeymap, INDEX_ALT, XKB_MOD_NAME_ALT);
+  keymapWrapper->SetModifierMask(aKeymap, INDEX_META, "Meta");
+  keymapWrapper->SetModifierMask(aKeymap, INDEX_SUPER, "Super");
+  keymapWrapper->SetModifierMask(aKeymap, INDEX_HYPER, "Hyper");
+
+  keymapWrapper->SetModifierMask(aKeymap, INDEX_SCROLL_LOCK, "ScrollLock");
+  keymapWrapper->SetModifierMask(aKeymap, INDEX_LEVEL3, "Level3");
+  keymapWrapper->SetModifierMask(aKeymap, INDEX_LEVEL5, "Level5");
+
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("%p KeymapWrapper::SetModifierMasks, CapsLock=0x%X, NumLock=0x%X, "
+           "ScrollLock=0x%X, Level3=0x%X, Level5=0x%X, "
+           "Shift=0x%X, Ctrl=0x%X, Alt=0x%X, Meta=0x%X, Super=0x%X, Hyper=0x%X",
+           keymapWrapper, keymapWrapper->GetModifierMask(CAPS_LOCK),
+           keymapWrapper->GetModifierMask(NUM_LOCK),
+           keymapWrapper->GetModifierMask(SCROLL_LOCK),
+           keymapWrapper->GetModifierMask(LEVEL3),
+           keymapWrapper->GetModifierMask(LEVEL5),
+           keymapWrapper->GetModifierMask(SHIFT),
+           keymapWrapper->GetModifierMask(CTRL),
+           keymapWrapper->GetModifierMask(ALT),
+           keymapWrapper->GetModifierMask(META),
+           keymapWrapper->GetModifierMask(SUPER),
+           keymapWrapper->GetModifierMask(HYPER)));
+}
+
+/* This keymap routine is derived from weston-2.0.0/clients/simple-im.c
+ */
+static void keyboard_handle_keymap(void* data, struct wl_keyboard* wl_keyboard,
+                                   uint32_t format, int fd, uint32_t size) {
+  KeymapWrapper::ResetKeyboard();
+
+  if (format != WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1) {
+    close(fd);
+    return;
+  }
+
+  char* mapString = (char*)mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
+  if (mapString == MAP_FAILED) {
+    close(fd);
+    return;
+  }
+
+  static auto sXkbContextNew =
+      (struct xkb_context * (*)(enum xkb_context_flags))
+          dlsym(RTLD_DEFAULT, "xkb_context_new");
+  static auto sXkbKeymapNewFromString =
+      (struct xkb_keymap * (*)(struct xkb_context*, const char*,
+                               enum xkb_keymap_format,
+                               enum xkb_keymap_compile_flags))
+          dlsym(RTLD_DEFAULT, "xkb_keymap_new_from_string");
+
+  struct xkb_context* xkb_context = sXkbContextNew(XKB_CONTEXT_NO_FLAGS);
+  struct xkb_keymap* keymap =
+      sXkbKeymapNewFromString(xkb_context, mapString, XKB_KEYMAP_FORMAT_TEXT_V1,
+                              XKB_KEYMAP_COMPILE_NO_FLAGS);
+
+  munmap(mapString, size);
+  close(fd);
+
+  if (!keymap) {
+    NS_WARNING("keyboard_handle_keymap(): Failed to compile keymap!\n");
+    return;
+  }
+
+  KeymapWrapper::SetModifierMasks(keymap);
+
+  static auto sXkbKeymapUnRef =
+      (void (*)(struct xkb_keymap*))dlsym(RTLD_DEFAULT, "xkb_keymap_unref");
+  sXkbKeymapUnRef(keymap);
+
+  static auto sXkbContextUnref =
+      (void (*)(struct xkb_context*))dlsym(RTLD_DEFAULT, "xkb_context_unref");
+  sXkbContextUnref(xkb_context);
+}
+
+static void keyboard_handle_enter(void* data, struct wl_keyboard* keyboard,
+                                  uint32_t serial, struct wl_surface* surface,
+                                  struct wl_array* keys) {}
+static void keyboard_handle_leave(void* data, struct wl_keyboard* keyboard,
+                                  uint32_t serial, struct wl_surface* surface) {
+}
+static void keyboard_handle_key(void* data, struct wl_keyboard* keyboard,
+                                uint32_t serial, uint32_t time, uint32_t key,
+                                uint32_t state) {}
+static void keyboard_handle_modifiers(void* data, struct wl_keyboard* keyboard,
+                                      uint32_t serial, uint32_t mods_depressed,
+                                      uint32_t mods_latched,
+                                      uint32_t mods_locked, uint32_t group) {}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap, keyboard_handle_enter,     keyboard_handle_leave,
+    keyboard_handle_key,    keyboard_handle_modifiers,
+};
+
+static void seat_handle_capabilities(void* data, struct wl_seat* seat,
+                                     unsigned int caps) {
+  static wl_keyboard* keyboard = nullptr;
+
+  if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !keyboard) {
+    keyboard = wl_seat_get_keyboard(seat);
+    wl_keyboard_add_listener(keyboard, &keyboard_listener, nullptr);
+  } else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && keyboard) {
+    wl_keyboard_destroy(keyboard);
+    keyboard = nullptr;
+  }
+}
+
+static const struct wl_seat_listener seat_listener = {
+    seat_handle_capabilities,
+};
+
+static void gdk_registry_handle_global(void* data, struct wl_registry* registry,
+                                       uint32_t id, const char* interface,
+                                       uint32_t version) {
+  if (strcmp(interface, "wl_seat") == 0) {
+    auto* seat =
+        WaylandRegistryBind<wl_seat>(registry, id, &wl_seat_interface, 1);
+    wl_seat_add_listener(seat, &seat_listener, data);
+  }
+}
+
+static void gdk_registry_handle_global_remove(void* data,
+                                              struct wl_registry* registry,
+                                              uint32_t id) {}
+
+static const struct wl_registry_listener keyboard_registry_listener = {
+    gdk_registry_handle_global, gdk_registry_handle_global_remove};
+
+void KeymapWrapper::InitBySystemSettingsWayland() {
+  wl_display* display = WaylandDisplayGetWLDisplay();
+  wl_registry_add_listener(wl_display_get_registry(display),
+                           &keyboard_registry_listener, this);
+}
+#endif
+
+KeymapWrapper::~KeymapWrapper() {
+  gdk_window_remove_filter(nullptr, FilterEvents, this);
+  if (mOnKeysChangedSignalHandle) {
+    g_signal_handler_disconnect(mGdkKeymap, mOnKeysChangedSignalHandle);
+  }
+  if (mOnDirectionChangedSignalHandle) {
+    g_signal_handler_disconnect(mGdkKeymap, mOnDirectionChangedSignalHandle);
+  }
+  g_object_unref(mGdkKeymap);
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info, ("%p Destructor", this));
+}
+
+/* static */
+GdkFilterReturn KeymapWrapper::FilterEvents(GdkXEvent* aXEvent,
+                                            GdkEvent* aGdkEvent,
+                                            gpointer aData) {
+  XEvent* xEvent = static_cast<XEvent*>(aXEvent);
+  switch (xEvent->type) {
+    case KeyPress: {
+      // If the key doesn't support auto repeat, ignore the event because
+      // even if such key (e.g., Shift) is pressed during auto repeat of
+      // anoter key, it doesn't stop the auto repeat.
+      KeymapWrapper* self = static_cast<KeymapWrapper*>(aData);
+      if (!self->IsAutoRepeatableKey(xEvent->xkey.keycode)) {
+        break;
+      }
+      if (sRepeatState == NOT_PRESSED) {
+        sRepeatState = FIRST_PRESS;
+        MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+                ("FilterEvents(aXEvent={ type=KeyPress, "
+                 "xkey={ keycode=0x%08X, state=0x%08X, time=%lu } }, "
+                 "aGdkEvent={ state=0x%08X }), "
+                 "detected first keypress",
+                 xEvent->xkey.keycode, xEvent->xkey.state, xEvent->xkey.time,
+                 reinterpret_cast<GdkEventKey*>(aGdkEvent)->state));
+      } else if (sLastRepeatableHardwareKeyCode == xEvent->xkey.keycode) {
+        if (sLastRepeatableKeyTime == xEvent->xkey.time &&
+            sLastRepeatableHardwareKeyCode ==
+                IMContextWrapper::
+                    GetWaitingSynthesizedKeyPressHardwareKeyCode()) {
+          // On some environment, IM may generate duplicated KeyPress event
+          // without any special state flags.  In such case, we shouldn't
+          // treat the event as "repeated".
+          MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+                  ("FilterEvents(aXEvent={ type=KeyPress, "
+                   "xkey={ keycode=0x%08X, state=0x%08X, time=%lu } }, "
+                   "aGdkEvent={ state=0x%08X }), "
+                   "igored keypress since it must be synthesized by IME",
+                   xEvent->xkey.keycode, xEvent->xkey.state, xEvent->xkey.time,
+                   reinterpret_cast<GdkEventKey*>(aGdkEvent)->state));
+          break;
+        }
+        sRepeatState = REPEATING;
+        MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+                ("FilterEvents(aXEvent={ type=KeyPress, "
+                 "xkey={ keycode=0x%08X, state=0x%08X, time=%lu } }, "
+                 "aGdkEvent={ state=0x%08X }), "
+                 "detected repeating keypress",
+                 xEvent->xkey.keycode, xEvent->xkey.state, xEvent->xkey.time,
+                 reinterpret_cast<GdkEventKey*>(aGdkEvent)->state));
+      } else {
+        // If a different key is pressed while another key is pressed,
+        // auto repeat system repeats only the last pressed key.
+        // So, setting new keycode and setting repeat state as first key
+        // press should work fine.
+        sRepeatState = FIRST_PRESS;
+        MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+                ("FilterEvents(aXEvent={ type=KeyPress, "
+                 "xkey={ keycode=0x%08X, state=0x%08X, time=%lu } }, "
+                 "aGdkEvent={ state=0x%08X }), "
+                 "detected different keypress",
+                 xEvent->xkey.keycode, xEvent->xkey.state, xEvent->xkey.time,
+                 reinterpret_cast<GdkEventKey*>(aGdkEvent)->state));
+      }
+      sLastRepeatableHardwareKeyCode = xEvent->xkey.keycode;
+      sLastRepeatableKeyTime = xEvent->xkey.time;
+      break;
+    }
+    case KeyRelease: {
+      if (sLastRepeatableHardwareKeyCode != xEvent->xkey.keycode) {
+        // This case means the key release event is caused by
+        // a non-repeatable key such as Shift or a repeatable key that
+        // was pressed before sLastRepeatableHardwareKeyCode was
+        // pressed.
+        break;
+      }
+      sRepeatState = NOT_PRESSED;
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("FilterEvents(aXEvent={ type=KeyRelease, "
+               "xkey={ keycode=0x%08X, state=0x%08X, time=%lu } }, "
+               "aGdkEvent={ state=0x%08X }), "
+               "detected key release",
+               xEvent->xkey.keycode, xEvent->xkey.state, xEvent->xkey.time,
+               reinterpret_cast<GdkEventKey*>(aGdkEvent)->state));
+      break;
+    }
+    case FocusOut: {
+      // At moving focus, we should reset keyboard repeat state.
+      // Strictly, this causes incorrect behavior.  However, this
+      // correctness must be enough for web applications.
+      sRepeatState = NOT_PRESSED;
+      break;
+    }
+    default: {
+      KeymapWrapper* self = static_cast<KeymapWrapper*>(aData);
+      if (xEvent->type != self->mXKBBaseEventCode) {
+        break;
+      }
+      XkbEvent* xkbEvent = (XkbEvent*)xEvent;
+      if (xkbEvent->any.xkb_type != XkbControlsNotify ||
+          !(xkbEvent->ctrls.changed_ctrls & XkbPerKeyRepeatMask)) {
+        break;
+      }
+      if (!XGetKeyboardControl(xkbEvent->any.display, &self->mKeyboardState)) {
+        MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+                ("%p FilterEvents failed due to failure "
+                 "of XGetKeyboardControl(), display=0x%p",
+                 self, xkbEvent->any.display));
+      }
+      break;
+    }
+  }
+
+  return GDK_FILTER_CONTINUE;
+}
+
+static void ResetBidiKeyboard() {
+  // Reset the bidi keyboard settings for the new GdkKeymap
+  nsCOMPtr<nsIBidiKeyboard> bidiKeyboard = nsContentUtils::GetBidiKeyboard();
+  if (bidiKeyboard) {
+    bidiKeyboard->Reset();
+  }
+  WidgetUtils::SendBidiKeyboardInfoToContent();
+}
+
+/* static */
+void KeymapWrapper::ResetKeyboard() {
+  sInstance->mInitialized = false;
+  ResetBidiKeyboard();
+}
+
+/* static */
+void KeymapWrapper::OnKeysChanged(GdkKeymap* aGdkKeymap,
+                                  KeymapWrapper* aKeymapWrapper) {
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("OnKeysChanged, aGdkKeymap=%p, aKeymapWrapper=%p", aGdkKeymap,
+           aKeymapWrapper));
+
+  MOZ_ASSERT(sInstance == aKeymapWrapper,
+             "This instance must be the singleton instance");
+
+  // We cannot reintialize here becasue we don't have GdkWindow which is using
+  // the GdkKeymap.  We'll reinitialize it when next GetInstance() is called.
+  ResetKeyboard();
+}
+
+// static
+void KeymapWrapper::OnDirectionChanged(GdkKeymap* aGdkKeymap,
+                                       KeymapWrapper* aKeymapWrapper) {
+  // XXX
+  // A lot of diretion-changed signal might be fired on switching bidi
+  // keyboard when using both ibus (with arabic layout) and fcitx (with IME).
+  // See https://github.com/fcitx/fcitx/issues/257
+  //
+  // Also, when using ibus, switching to IM might not cause this signal.
+  // See https://github.com/ibus/ibus/issues/1848
+
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("OnDirectionChanged, aGdkKeymap=%p, aKeymapWrapper=%p", aGdkKeymap,
+           aKeymapWrapper));
+
+  ResetBidiKeyboard();
+}
+
+/* static */
+guint KeymapWrapper::GetCurrentModifierState() {
+  GdkModifierType modifiers;
+  gdk_display_get_pointer(gdk_display_get_default(), nullptr, nullptr, nullptr,
+                          &modifiers);
+  return static_cast<guint>(modifiers);
+}
+
+/* static */
+bool KeymapWrapper::AreModifiersCurrentlyActive(Modifiers aModifiers) {
+  guint modifierState = GetCurrentModifierState();
+  return AreModifiersActive(aModifiers, modifierState);
+}
+
+/* static */
+bool KeymapWrapper::AreModifiersActive(Modifiers aModifiers,
+                                       guint aModifierState) {
+  NS_ENSURE_TRUE(aModifiers, false);
+
+  KeymapWrapper* keymapWrapper = GetInstance();
+  for (uint32_t i = 0; i < sizeof(Modifier) * 8 && aModifiers; i++) {
+    Modifier modifier = static_cast<Modifier>(1 << i);
+    if (!(aModifiers & modifier)) {
+      continue;
+    }
+    if (!(aModifierState & keymapWrapper->GetModifierMask(modifier))) {
+      return false;
+    }
+    aModifiers &= ~modifier;
+  }
+  return true;
+}
+
+/* static */
+uint32_t KeymapWrapper::ComputeCurrentKeyModifiers() {
+  return ComputeKeyModifiers(GetCurrentModifierState());
+}
+
+/* static */
+uint32_t KeymapWrapper::ComputeKeyModifiers(guint aModifierState) {
+  KeymapWrapper* keymapWrapper = GetInstance();
+
+  uint32_t keyModifiers = 0;
+  // DOM Meta key should be TRUE only on Mac.  We need to discuss this
+  // issue later.
+  if (keymapWrapper->AreModifiersActive(SHIFT, aModifierState)) {
+    keyModifiers |= MODIFIER_SHIFT;
+  }
+  if (keymapWrapper->AreModifiersActive(CTRL, aModifierState)) {
+    keyModifiers |= MODIFIER_CONTROL;
+  }
+  if (keymapWrapper->AreModifiersActive(ALT, aModifierState)) {
+    keyModifiers |= MODIFIER_ALT;
+  }
+  if (keymapWrapper->AreModifiersActive(META, aModifierState)) {
+    keyModifiers |= MODIFIER_META;
+  }
+  if (keymapWrapper->AreModifiersActive(SUPER, aModifierState) ||
+      keymapWrapper->AreModifiersActive(HYPER, aModifierState)) {
+    keyModifiers |= MODIFIER_OS;
+  }
+  if (keymapWrapper->AreModifiersActive(LEVEL3, aModifierState) ||
+      keymapWrapper->AreModifiersActive(LEVEL5, aModifierState)) {
+    keyModifiers |= MODIFIER_ALTGRAPH;
+  }
+  if (keymapWrapper->AreModifiersActive(CAPS_LOCK, aModifierState)) {
+    keyModifiers |= MODIFIER_CAPSLOCK;
+  }
+  if (keymapWrapper->AreModifiersActive(NUM_LOCK, aModifierState)) {
+    keyModifiers |= MODIFIER_NUMLOCK;
+  }
+  if (keymapWrapper->AreModifiersActive(SCROLL_LOCK, aModifierState)) {
+    keyModifiers |= MODIFIER_SCROLLLOCK;
+  }
+  return keyModifiers;
+}
+
+/* static */
+void KeymapWrapper::InitInputEvent(WidgetInputEvent& aInputEvent,
+                                   guint aModifierState) {
+  KeymapWrapper* keymapWrapper = GetInstance();
+
+  aInputEvent.mModifiers = ComputeKeyModifiers(aModifierState);
+
+  // Don't log this method for non-important events because e.g., eMouseMove is
+  // just noisy and there is no reason to log it.
+  bool doLog = aInputEvent.mMessage != eMouseMove;
+  if (doLog) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Debug,
+            ("%p InitInputEvent, aModifierState=0x%08X, "
+             "aInputEvent={ mMessage=%s, mModifiers=0x%04X (Shift: %s, "
+             "Control: %s, Alt: %s, "
+             "Meta: %s, OS: %s, AltGr: %s, "
+             "CapsLock: %s, NumLock: %s, ScrollLock: %s })",
+             keymapWrapper, aModifierState, ToChar(aInputEvent.mMessage),
+             aInputEvent.mModifiers,
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_SHIFT),
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_CONTROL),
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_ALT),
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_META),
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_OS),
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_ALTGRAPH),
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_CAPSLOCK),
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_NUMLOCK),
+             GetBoolName(aInputEvent.mModifiers & MODIFIER_SCROLLLOCK)));
+  }
+
+  switch (aInputEvent.mClass) {
+    case eMouseEventClass:
+    case eMouseScrollEventClass:
+    case eWheelEventClass:
+    case eDragEventClass:
+    case eSimpleGestureEventClass:
+      break;
+    default:
+      return;
+  }
+
+  WidgetMouseEventBase& mouseEvent = *aInputEvent.AsMouseEventBase();
+  mouseEvent.mButtons = 0;
+  if (aModifierState & GDK_BUTTON1_MASK) {
+    mouseEvent.mButtons |= MouseButtonsFlag::ePrimaryFlag;
+  }
+  if (aModifierState & GDK_BUTTON3_MASK) {
+    mouseEvent.mButtons |= MouseButtonsFlag::eSecondaryFlag;
+  }
+  if (aModifierState & GDK_BUTTON2_MASK) {
+    mouseEvent.mButtons |= MouseButtonsFlag::eMiddleFlag;
+  }
+
+  if (doLog) {
+    MOZ_LOG(
+        gKeymapWrapperLog, LogLevel::Debug,
+        ("%p InitInputEvent, aInputEvent has mButtons, "
+         "aInputEvent.mButtons=0x%04X (Left: %s, Right: %s, Middle: %s, "
+         "4th (BACK): %s, 5th (FORWARD): %s)",
+         keymapWrapper, mouseEvent.mButtons,
+         GetBoolName(mouseEvent.mButtons & MouseButtonsFlag::ePrimaryFlag),
+         GetBoolName(mouseEvent.mButtons & MouseButtonsFlag::eSecondaryFlag),
+         GetBoolName(mouseEvent.mButtons & MouseButtonsFlag::eMiddleFlag),
+         GetBoolName(mouseEvent.mButtons & MouseButtonsFlag::e4thFlag),
+         GetBoolName(mouseEvent.mButtons & MouseButtonsFlag::e5thFlag)));
+  }
+}
+
+/* static */
+uint32_t KeymapWrapper::ComputeDOMKeyCode(const GdkEventKey* aGdkKeyEvent) {
+  // If the keyval indicates it's a modifier key, we should use unshifted
+  // key's modifier keyval.
+  guint keyval = aGdkKeyEvent->keyval;
+  if (GetModifierForGDKKeyval(keyval)) {
+    // But if the keyval without modifiers isn't a modifier key, we
+    // shouldn't use it.  E.g., Japanese keyboard layout's
+    // Shift + Eisu-Toggle key is CapsLock.  This is an actual rare case,
+    // Windows uses different keycode for a physical key for different
+    // shift key state.
+    guint keyvalWithoutModifier = GetGDKKeyvalWithoutModifier(aGdkKeyEvent);
+    if (GetModifierForGDKKeyval(keyvalWithoutModifier)) {
+      keyval = keyvalWithoutModifier;
+    }
+    // Note that the modifier keycode and activating or deactivating
+    // modifier flag may be mismatched, but it's okay.  If a DOM key
+    // event handler is testing a keydown event, it's more likely being
+    // used to test which key is being pressed than to test which
+    // modifier will become active.  So, if we computed DOM keycode
+    // from modifier flag which were changing by the physical key, then
+    // there would be no other way for the user to generate the original
+    // keycode.
+    uint32_t DOMKeyCode = GetDOMKeyCodeFromKeyPairs(keyval);
+    NS_ASSERTION(DOMKeyCode, "All modifier keys must have a DOM keycode");
+    return DOMKeyCode;
+  }
+
+  // If the key isn't printable, let's look at the key pairs.
+  uint32_t charCode = GetCharCodeFor(aGdkKeyEvent);
+  if (!charCode) {
+    // Note that any key may be a function key because of some unusual keyboard
+    // layouts.  I.e., even if the pressed key is a printable key of en-US
+    // keyboard layout, we should expose the function key's keyCode value to
+    // web apps because web apps should handle the keydown/keyup events as
+    // inputted by usual keyboard layout.  For example, Hatchak keyboard
+    // maps Tab key to "Digit3" key and Level3 Shift makes it "Backspace".
+    // In this case, we should expose DOM_VK_BACK_SPACE (8).
+    uint32_t DOMKeyCode = GetDOMKeyCodeFromKeyPairs(keyval);
+    if (DOMKeyCode) {
+      // XXX If DOMKeyCode is a function key's keyCode value, it might be
+      //     better to consume necessary modifiers.  For example, if there is
+      //     no Control Pad section on keyboard like notebook, Delete key is
+      //     available only with Level3 Shift+"Backspace" key if using Hatchak.
+      //     If web apps accept Delete key operation only when no modifiers are
+      //     active, such users cannot use Delete key to do it.  However,
+      //     Chromium doesn't consume such necessary modifiers.  So, our default
+      //     behavior should keep not touching modifiers for compatibility, but
+      //     it might be better to add a pref to consume necessary modifiers.
+      return DOMKeyCode;
+    }
+    // If aGdkKeyEvent cannot be mapped to a DOM keyCode value, we should
+    // refer keyCode value without modifiers because web apps should be
+    // able to identify the key as far as possible.
+    guint keyvalWithoutModifier = GetGDKKeyvalWithoutModifier(aGdkKeyEvent);
+    return GetDOMKeyCodeFromKeyPairs(keyvalWithoutModifier);
+  }
+
+  // printable numpad keys should be resolved here.
+  switch (keyval) {
+    case GDK_KP_Multiply:
+      return NS_VK_MULTIPLY;
+    case GDK_KP_Add:
+      return NS_VK_ADD;
+    case GDK_KP_Separator:
+      return NS_VK_SEPARATOR;
+    case GDK_KP_Subtract:
+      return NS_VK_SUBTRACT;
+    case GDK_KP_Decimal:
+      return NS_VK_DECIMAL;
+    case GDK_KP_Divide:
+      return NS_VK_DIVIDE;
+    case GDK_KP_0:
+      return NS_VK_NUMPAD0;
+    case GDK_KP_1:
+      return NS_VK_NUMPAD1;
+    case GDK_KP_2:
+      return NS_VK_NUMPAD2;
+    case GDK_KP_3:
+      return NS_VK_NUMPAD3;
+    case GDK_KP_4:
+      return NS_VK_NUMPAD4;
+    case GDK_KP_5:
+      return NS_VK_NUMPAD5;
+    case GDK_KP_6:
+      return NS_VK_NUMPAD6;
+    case GDK_KP_7:
+      return NS_VK_NUMPAD7;
+    case GDK_KP_8:
+      return NS_VK_NUMPAD8;
+    case GDK_KP_9:
+      return NS_VK_NUMPAD9;
+  }
+
+  KeymapWrapper* keymapWrapper = GetInstance();
+
+  // Ignore all modifier state except NumLock.
+  guint baseState =
+      (aGdkKeyEvent->state & keymapWrapper->GetModifierMask(NUM_LOCK));
+
+  // Basically, we should use unmodified character for deciding our keyCode.
+  uint32_t unmodifiedChar = keymapWrapper->GetCharCodeFor(
+      aGdkKeyEvent, baseState, aGdkKeyEvent->group);
+  if (IsBasicLatinLetterOrNumeral(unmodifiedChar)) {
+    // If the unmodified character is an ASCII alphabet or an ASCII
+    // numeric, it's the best hint for deciding our keyCode.
+    return WidgetUtils::ComputeKeyCodeFromChar(unmodifiedChar);
+  }
+
+  // If the unmodified character is not an ASCII character, that means we
+  // couldn't find the hint. We should reset it.
+  if (!IsPrintableASCIICharacter(unmodifiedChar)) {
+    unmodifiedChar = 0;
+  }
+
+  // Retry with shifted keycode.
+  guint shiftState = (baseState | keymapWrapper->GetModifierMask(SHIFT));
+  uint32_t shiftedChar = keymapWrapper->GetCharCodeFor(aGdkKeyEvent, shiftState,
+                                                       aGdkKeyEvent->group);
+  if (IsBasicLatinLetterOrNumeral(shiftedChar)) {
+    // A shifted character can be an ASCII alphabet on Hebrew keyboard
+    // layout. And also shifted character can be an ASCII numeric on
+    // AZERTY keyboad layout.  Then, it's a good hint for deciding our
+    // keyCode.
+    return WidgetUtils::ComputeKeyCodeFromChar(shiftedChar);
+  }
+
+  // If the shifted unmodified character isn't an ASCII character, we should
+  // discard it too.
+  if (!IsPrintableASCIICharacter(shiftedChar)) {
+    shiftedChar = 0;
+  }
+
+  // If current keyboard layout isn't ASCII alphabet inputtable layout,
+  // look for ASCII alphabet inputtable keyboard layout.  If the key
+  // inputs an ASCII alphabet or an ASCII numeric, we should use it
+  // for deciding our keyCode.
+  uint32_t unmodCharLatin = 0;
+  uint32_t shiftedCharLatin = 0;
+  if (!keymapWrapper->IsLatinGroup(aGdkKeyEvent->group)) {
+    gint minGroup = keymapWrapper->GetFirstLatinGroup();
+    if (minGroup >= 0) {
+      unmodCharLatin =
+          keymapWrapper->GetCharCodeFor(aGdkKeyEvent, baseState, minGroup);
+      if (IsBasicLatinLetterOrNumeral(unmodCharLatin)) {
+        // If the unmodified character is an ASCII alphabet or
+        // an ASCII numeric, we should use it for the keyCode.
+        return WidgetUtils::ComputeKeyCodeFromChar(unmodCharLatin);
+      }
+      // If the unmodified character in the alternative ASCII capable
+      // keyboard layout isn't an ASCII character, that means we couldn't
+      // find the hint. We should reset it.
+      if (!IsPrintableASCIICharacter(unmodCharLatin)) {
+        unmodCharLatin = 0;
+      }
+      shiftedCharLatin =
+          keymapWrapper->GetCharCodeFor(aGdkKeyEvent, shiftState, minGroup);
+      if (IsBasicLatinLetterOrNumeral(shiftedCharLatin)) {
+        // If the shifted character is an ASCII alphabet or an ASCII
+        // numeric, we should use it for the keyCode.
+        return WidgetUtils::ComputeKeyCodeFromChar(shiftedCharLatin);
+      }
+      // If the shifted unmodified character in the alternative ASCII
+      // capable keyboard layout isn't an ASCII character, we should
+      // discard it too.
+      if (!IsPrintableASCIICharacter(shiftedCharLatin)) {
+        shiftedCharLatin = 0;
+      }
+    }
+  }
+
+  // If the key itself or with Shift state on active keyboard layout produces
+  // an ASCII punctuation character, we should decide keyCode value with it.
+  if (unmodifiedChar || shiftedChar) {
+    return WidgetUtils::ComputeKeyCodeFromChar(unmodifiedChar ? unmodifiedChar
+                                                              : shiftedChar);
+  }
+
+  // If the key itself or with Shift state on alternative ASCII capable
+  // keyboard layout produces an ASCII punctuation character, we should
+  // decide keyCode value with it.  Note that We've returned 0 for long
+  // time if keyCode isn't for an alphabet keys or a numeric key even in
+  // alternative ASCII capable keyboard layout because we decided that we
+  // should avoid setting same keyCode value to 2 or more keys since active
+  // keyboard layout may have a key to input the punctuation with different
+  // key.  However, setting keyCode to 0 makes some web applications which
+  // are aware of neither KeyboardEvent.key nor KeyboardEvent.code not work
+  // with Firefox when user selects non-ASCII capable keyboard layout such
+  // as Russian and Thai.  So, if alternative ASCII capable keyboard layout
+  // has keyCode value for the key, we should use it.  In other words, this
+  // behavior means that non-ASCII capable keyboard layout overrides some
+  // keys' keyCode value only if the key produces ASCII character by itself
+  // or with Shift key.
+  if (unmodCharLatin || shiftedCharLatin) {
+    return WidgetUtils::ComputeKeyCodeFromChar(
+        unmodCharLatin ? unmodCharLatin : shiftedCharLatin);
+  }
+
+  // Otherwise, let's decide keyCode value from the hardware_keycode
+  // value on major keyboard layout.
+  CodeNameIndex code = ComputeDOMCodeNameIndex(aGdkKeyEvent);
+  return WidgetKeyboardEvent::GetFallbackKeyCodeOfPunctuationKey(code);
+}
+
+KeyNameIndex KeymapWrapper::ComputeDOMKeyNameIndex(
+    const GdkEventKey* aGdkKeyEvent) {
+  switch (aGdkKeyEvent->keyval) {
+#define NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX(aNativeKey, aKeyNameIndex) \
+  case aNativeKey:                                                     \
+    return aKeyNameIndex;
+
+#include "NativeKeyToDOMKeyName.h"
+
+#undef NS_NATIVE_KEY_TO_DOM_KEY_NAME_INDEX
+
+    default:
+      break;
+  }
+
+  return KEY_NAME_INDEX_Unidentified;
+}
+
+/* static */
+CodeNameIndex KeymapWrapper::ComputeDOMCodeNameIndex(
+    const GdkEventKey* aGdkKeyEvent) {
+  switch (aGdkKeyEvent->hardware_keycode) {
+#define NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX(aNativeKey, aCodeNameIndex) \
+  case aNativeKey:                                                       \
+    return aCodeNameIndex;
+
+#include "NativeKeyToDOMCodeName.h"
+
+#undef NS_NATIVE_KEY_TO_DOM_CODE_NAME_INDEX
+
+    default:
+      break;
+  }
+
+  return CODE_NAME_INDEX_UNKNOWN;
+}
+
+/* static */
+bool KeymapWrapper::DispatchKeyDownOrKeyUpEvent(nsWindow* aWindow,
+                                                GdkEventKey* aGdkKeyEvent,
+                                                bool aIsProcessedByIME,
+                                                bool* aIsCancelled) {
+  MOZ_ASSERT(aIsCancelled, "aIsCancelled must not be nullptr");
+
+  *aIsCancelled = false;
+
+  if (aGdkKeyEvent->type == GDK_KEY_PRESS && aGdkKeyEvent->keyval == GDK_Tab &&
+      AreModifiersActive(CTRL | ALT, aGdkKeyEvent->state)) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("  DispatchKeyDownOrKeyUpEvent(), didn't dispatch keyboard events "
+             "because it's Ctrl + Alt + Tab"));
+    return false;
+  }
+
+  EventMessage message =
+      aGdkKeyEvent->type == GDK_KEY_PRESS ? eKeyDown : eKeyUp;
+  WidgetKeyboardEvent keyEvent(true, message, aWindow);
+  KeymapWrapper::InitKeyEvent(keyEvent, aGdkKeyEvent, aIsProcessedByIME);
+  return DispatchKeyDownOrKeyUpEvent(aWindow, keyEvent, aIsCancelled);
+}
+
+/* static */
+bool KeymapWrapper::DispatchKeyDownOrKeyUpEvent(
+    nsWindow* aWindow, WidgetKeyboardEvent& aKeyboardEvent,
+    bool* aIsCancelled) {
+  MOZ_ASSERT(aIsCancelled, "aIsCancelled must not be nullptr");
+
+  *aIsCancelled = false;
+
+  RefPtr<TextEventDispatcher> dispatcher = aWindow->GetTextEventDispatcher();
+  nsresult rv = dispatcher->BeginNativeInputTransaction();
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Error,
+            ("  DispatchKeyDownOrKeyUpEvent(), stopped dispatching %s event "
+             "because of failed to initialize TextEventDispatcher",
+             ToChar(aKeyboardEvent.mMessage)));
+    return FALSE;
+  }
+
+  nsEventStatus status = nsEventStatus_eIgnore;
+  bool dispatched = dispatcher->DispatchKeyboardEvent(
+      aKeyboardEvent.mMessage, aKeyboardEvent, status, nullptr);
+  *aIsCancelled = (status == nsEventStatus_eConsumeNoDefault);
+  return dispatched;
+}
+
+/* static */
+bool KeymapWrapper::MaybeDispatchContextMenuEvent(nsWindow* aWindow,
+                                                  const GdkEventKey* aEvent) {
+  KeyNameIndex keyNameIndex = ComputeDOMKeyNameIndex(aEvent);
+
+  // Shift+F10 and ContextMenu should cause eContextMenu event.
+  if (keyNameIndex != KEY_NAME_INDEX_F10 &&
+      keyNameIndex != KEY_NAME_INDEX_ContextMenu) {
+    return false;
+  }
+
+  WidgetMouseEvent contextMenuEvent(true, eContextMenu, aWindow,
+                                    WidgetMouseEvent::eReal,
+                                    WidgetMouseEvent::eContextMenuKey);
+
+  contextMenuEvent.mRefPoint = LayoutDeviceIntPoint(0, 0);
+  contextMenuEvent.AssignEventTime(aWindow->GetWidgetEventTime(aEvent->time));
+  contextMenuEvent.mClickCount = 1;
+  KeymapWrapper::InitInputEvent(contextMenuEvent, aEvent->state);
+
+  if (contextMenuEvent.IsControl() || contextMenuEvent.IsMeta() ||
+      contextMenuEvent.IsAlt()) {
+    return false;
+  }
+
+  // If the key is ContextMenu, then an eContextMenu mouse event is
+  // dispatched regardless of the state of the Shift modifier.  When it is
+  // pressed without the Shift modifier, a web page can prevent the default
+  // context menu action.  When pressed with the Shift modifier, the web page
+  // cannot prevent the default context menu action.
+  // (PresShell::HandleEventInternal() sets mOnlyChromeDispatch to true.)
+
+  // If the key is F10, it needs Shift state because Shift+F10 is well-known
+  // shortcut key on Linux.  However, eContextMenu with Shift state is
+  // special.  It won't fire "contextmenu" event in the web content for
+  // blocking web page to prevent its default.  Therefore, this combination
+  // should work same as ContextMenu key.
+  // XXX Should we allow to block web page to prevent its default with
+  //     Ctrl+Shift+F10 or Alt+Shift+F10 instead?
+  if (keyNameIndex == KEY_NAME_INDEX_F10) {
+    if (!contextMenuEvent.IsShift()) {
+      return false;
+    }
+    contextMenuEvent.mModifiers &= ~MODIFIER_SHIFT;
+  }
+
+  aWindow->DispatchInputEvent(&contextMenuEvent);
+  return true;
+}
+
+/* static*/
+void KeymapWrapper::HandleKeyPressEvent(nsWindow* aWindow,
+                                        GdkEventKey* aGdkKeyEvent) {
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("HandleKeyPressEvent(aWindow=%p, aGdkKeyEvent={ type=%s, "
+           "keyval=%s(0x%X), state=0x%08X, hardware_keycode=0x%08X, "
+           "time=%u, is_modifier=%s })",
+           aWindow,
+           ((aGdkKeyEvent->type == GDK_KEY_PRESS) ? "GDK_KEY_PRESS"
+                                                  : "GDK_KEY_RELEASE"),
+           gdk_keyval_name(aGdkKeyEvent->keyval), aGdkKeyEvent->keyval,
+           aGdkKeyEvent->state, aGdkKeyEvent->hardware_keycode,
+           aGdkKeyEvent->time, GetBoolName(aGdkKeyEvent->is_modifier)));
+
+  // if we are in the middle of composing text, XIM gets to see it
+  // before mozilla does.
+  // FYI: Don't dispatch keydown event before notifying IME of the event
+  //      because IME may send a key event synchronously and consume the
+  //      original event.
+  bool IMEWasEnabled = false;
+  KeyHandlingState handlingState = KeyHandlingState::eNotHandled;
+  RefPtr<IMContextWrapper> imContext = aWindow->GetIMContext();
+  if (imContext) {
+    IMEWasEnabled = imContext->IsEnabled();
+    handlingState = imContext->OnKeyEvent(aWindow, aGdkKeyEvent);
+    if (handlingState == KeyHandlingState::eHandled) {
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), the event was handled by "
+               "IMContextWrapper"));
+      return;
+    }
+  }
+
+  // work around for annoying things.
+  if (aGdkKeyEvent->keyval == GDK_Tab &&
+      AreModifiersActive(CTRL | ALT, aGdkKeyEvent->state)) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("  HandleKeyPressEvent(), didn't dispatch keyboard events "
+             "because it's Ctrl + Alt + Tab"));
+    return;
+  }
+
+  // Dispatch keydown event always.  At auto repeating, we should send
+  // KEYDOWN -> KEYPRESS -> KEYDOWN -> KEYPRESS ... -> KEYUP
+  // However, old distributions (e.g., Ubuntu 9.10) sent native key
+  // release event, so, on such platform, the DOM events will be:
+  // KEYDOWN -> KEYPRESS -> KEYUP -> KEYDOWN -> KEYPRESS -> KEYUP...
+
+  bool isKeyDownCancelled = false;
+  if (handlingState == KeyHandlingState::eNotHandled) {
+    if (DispatchKeyDownOrKeyUpEvent(aWindow, aGdkKeyEvent, false,
+                                    &isKeyDownCancelled) &&
+        (MOZ_UNLIKELY(aWindow->IsDestroyed()) || isKeyDownCancelled)) {
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched eKeyDown event and "
+               "stopped handling the event because %s",
+               aWindow->IsDestroyed() ? "the window has been destroyed"
+                                      : "the event was consumed"));
+      return;
+    }
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("  HandleKeyPressEvent(), dispatched eKeyDown event and "
+             "it wasn't consumed"));
+    handlingState = KeyHandlingState::eNotHandledButEventDispatched;
+  }
+
+  // If a keydown event handler causes to enable IME, i.e., it moves
+  // focus from IME unusable content to IME usable editor, we should
+  // send the native key event to IME for the first input on the editor.
+  imContext = aWindow->GetIMContext();
+  if (!IMEWasEnabled && imContext && imContext->IsEnabled()) {
+    // Notice our keydown event was already dispatched.  This prevents
+    // unnecessary DOM keydown event in the editor.
+    handlingState = imContext->OnKeyEvent(aWindow, aGdkKeyEvent, true);
+    if (handlingState == KeyHandlingState::eHandled) {
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), the event was handled by "
+               "IMContextWrapper which was enabled by the preceding eKeyDown "
+               "event"));
+      return;
+    }
+  }
+
+  // Look for specialized app-command keys
+  switch (aGdkKeyEvent->keyval) {
+    case GDK_Back:
+      aWindow->DispatchCommandEvent(nsGkAtoms::Back);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Back\" command event"));
+      return;
+    case GDK_Forward:
+      aWindow->DispatchCommandEvent(nsGkAtoms::Forward);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Forward\" command "
+               "event"));
+      return;
+    case GDK_Reload:
+    case GDK_Refresh:
+      aWindow->DispatchCommandEvent(nsGkAtoms::Reload);
+      return;
+    case GDK_Stop:
+      aWindow->DispatchCommandEvent(nsGkAtoms::Stop);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Stop\" command event"));
+      return;
+    case GDK_Search:
+      aWindow->DispatchCommandEvent(nsGkAtoms::Search);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Search\" command event"));
+      return;
+    case GDK_Favorites:
+      aWindow->DispatchCommandEvent(nsGkAtoms::Bookmarks);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Bookmarks\" command "
+               "event"));
+      return;
+    case GDK_HomePage:
+      aWindow->DispatchCommandEvent(nsGkAtoms::Home);
+      return;
+    case GDK_Copy:
+    case GDK_F16:  // F16, F20, F18, F14 are old keysyms for Copy Cut Paste Undo
+      aWindow->DispatchContentCommandEvent(eContentCommandCopy);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Copy\" content command "
+               "event"));
+      return;
+    case GDK_Cut:
+    case GDK_F20:
+      aWindow->DispatchContentCommandEvent(eContentCommandCut);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Cut\" content command "
+               "event"));
+      return;
+    case GDK_Paste:
+    case GDK_F18:
+      aWindow->DispatchContentCommandEvent(eContentCommandPaste);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Paste\" content command "
+               "event"));
+      return;
+    case GDK_Redo:
+      aWindow->DispatchContentCommandEvent(eContentCommandRedo);
+      return;
+    case GDK_Undo:
+    case GDK_F14:
+      aWindow->DispatchContentCommandEvent(eContentCommandUndo);
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched \"Undo\" content command "
+               "event"));
+      return;
+    default:
+      break;
+  }
+
+  // before we dispatch a key, check if it's the context menu key.
+  // If so, send a context menu key event instead.
+  if (MaybeDispatchContextMenuEvent(aWindow, aGdkKeyEvent)) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("  HandleKeyPressEvent(), stopped dispatching eKeyPress event "
+             "because eContextMenu event was dispatched"));
+    return;
+  }
+
+  RefPtr<TextEventDispatcher> textEventDispatcher =
+      aWindow->GetTextEventDispatcher();
+  nsresult rv = textEventDispatcher->BeginNativeInputTransaction();
+  if (NS_WARN_IF(NS_FAILED(rv))) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Error,
+            ("  HandleKeyPressEvent(), stopped dispatching eKeyPress event "
+             "because of failed to initialize TextEventDispatcher"));
+    return;
+  }
+
+  // If the character code is in the BMP, send the key press event.
+  // Otherwise, send a compositionchange event with the equivalent UTF-16
+  // string.
+  // TODO: Investigate other browser's behavior in this case because
+  //       this hack is odd for UI Events.
+  WidgetKeyboardEvent keypressEvent(true, eKeyPress, aWindow);
+  KeymapWrapper::InitKeyEvent(keypressEvent, aGdkKeyEvent, false);
+  nsEventStatus status = nsEventStatus_eIgnore;
+  if (keypressEvent.mKeyNameIndex != KEY_NAME_INDEX_USE_STRING ||
+      keypressEvent.mKeyValue.Length() == 1) {
+    if (textEventDispatcher->MaybeDispatchKeypressEvents(keypressEvent, status,
+                                                         aGdkKeyEvent)) {
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), dispatched eKeyPress event "
+               "(status=%s)",
+               GetStatusName(status)));
+    } else {
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyPressEvent(), didn't dispatch eKeyPress event "
+               "(status=%s)",
+               GetStatusName(status)));
+    }
+  } else {
+    WidgetEventTime eventTime = aWindow->GetWidgetEventTime(aGdkKeyEvent->time);
+    textEventDispatcher->CommitComposition(status, &keypressEvent.mKeyValue,
+                                           &eventTime);
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("  HandleKeyPressEvent(), dispatched a set of composition "
+             "events"));
+  }
+}
+
+/* static */
+bool KeymapWrapper::HandleKeyReleaseEvent(nsWindow* aWindow,
+                                          GdkEventKey* aGdkKeyEvent) {
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("HandleKeyReleaseEvent(aWindow=%p, aGdkKeyEvent={ type=%s, "
+           "keyval=%s(0x%X), state=0x%08X, hardware_keycode=0x%08X, "
+           "time=%u, is_modifier=%s })",
+           aWindow,
+           ((aGdkKeyEvent->type == GDK_KEY_PRESS) ? "GDK_KEY_PRESS"
+                                                  : "GDK_KEY_RELEASE"),
+           gdk_keyval_name(aGdkKeyEvent->keyval), aGdkKeyEvent->keyval,
+           aGdkKeyEvent->state, aGdkKeyEvent->hardware_keycode,
+           aGdkKeyEvent->time, GetBoolName(aGdkKeyEvent->is_modifier)));
+
+  RefPtr<IMContextWrapper> imContext = aWindow->GetIMContext();
+  if (imContext) {
+    KeyHandlingState handlingState =
+        imContext->OnKeyEvent(aWindow, aGdkKeyEvent);
+    if (handlingState != KeyHandlingState::eNotHandled) {
+      MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+              ("  HandleKeyReleaseEvent(), the event was handled by "
+               "IMContextWrapper"));
+      return true;
+    }
+  }
+
+  bool isCancelled = false;
+  if (NS_WARN_IF(!DispatchKeyDownOrKeyUpEvent(aWindow, aGdkKeyEvent, false,
+                                              &isCancelled))) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Error,
+            ("  HandleKeyReleaseEvent(), didn't dispatch eKeyUp event"));
+    return false;
+  }
+
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("  HandleKeyReleaseEvent(), dispatched eKeyUp event "
+           "(isCancelled=%s)",
+           GetBoolName(isCancelled)));
+  return true;
+}
+
+/* static */
+void KeymapWrapper::InitKeyEvent(WidgetKeyboardEvent& aKeyEvent,
+                                 GdkEventKey* aGdkKeyEvent,
+                                 bool aIsProcessedByIME) {
+  MOZ_ASSERT(
+      !aIsProcessedByIME || aKeyEvent.mMessage != eKeyPress,
+      "If the key event is handled by IME, keypress event shouldn't be fired");
+
+  KeymapWrapper* keymapWrapper = GetInstance();
+
+  aKeyEvent.mCodeNameIndex = ComputeDOMCodeNameIndex(aGdkKeyEvent);
+  MOZ_ASSERT(aKeyEvent.mCodeNameIndex != CODE_NAME_INDEX_USE_STRING);
+  aKeyEvent.mKeyNameIndex =
+      aIsProcessedByIME ? KEY_NAME_INDEX_Process
+                        : keymapWrapper->ComputeDOMKeyNameIndex(aGdkKeyEvent);
+  if (aKeyEvent.mKeyNameIndex == KEY_NAME_INDEX_Unidentified) {
+    uint32_t charCode = GetCharCodeFor(aGdkKeyEvent);
+    if (!charCode) {
+      charCode = keymapWrapper->GetUnmodifiedCharCodeFor(aGdkKeyEvent);
+    }
+    if (charCode) {
+      aKeyEvent.mKeyNameIndex = KEY_NAME_INDEX_USE_STRING;
+      MOZ_ASSERT(aKeyEvent.mKeyValue.IsEmpty(),
+                 "Uninitialized mKeyValue must be empty");
+      AppendUCS4ToUTF16(charCode, aKeyEvent.mKeyValue);
+    }
+  }
+
+  if (aIsProcessedByIME) {
+    aKeyEvent.mKeyCode = NS_VK_PROCESSKEY;
+  } else if (aKeyEvent.mKeyNameIndex != KEY_NAME_INDEX_USE_STRING ||
+             aKeyEvent.mMessage != eKeyPress) {
+    aKeyEvent.mKeyCode = ComputeDOMKeyCode(aGdkKeyEvent);
+  } else {
+    aKeyEvent.mKeyCode = 0;
+  }
+
+  // NOTE: The state of given key event indicates adjacent state of
+  // modifier keys.  E.g., even if the event is Shift key press event,
+  // the bit for Shift is still false.  By the same token, even if the
+  // event is Shift key release event, the bit for Shift is still true.
+  // Unfortunately, gdk_keyboard_get_modifiers() returns current modifier
+  // state.  It means if there're some pending modifier key press or
+  // key release events, the result isn't what we want.
+  guint modifierState = aGdkKeyEvent->state;
+  GdkDisplay* gdkDisplay = gdk_display_get_default();
+  if (aGdkKeyEvent->is_modifier && GDK_IS_X11_DISPLAY(gdkDisplay)) {
+    Display* display = gdk_x11_display_get_xdisplay(gdkDisplay);
+    if (XEventsQueued(display, QueuedAfterReading)) {
+      XEvent nextEvent;
+      XPeekEvent(display, &nextEvent);
+      if (nextEvent.type == keymapWrapper->mXKBBaseEventCode) {
+        XkbEvent* XKBEvent = (XkbEvent*)&nextEvent;
+        if (XKBEvent->any.xkb_type == XkbStateNotify) {
+          XkbStateNotifyEvent* stateNotifyEvent =
+              (XkbStateNotifyEvent*)XKBEvent;
+          modifierState &= ~0xFF;
+          modifierState |= stateNotifyEvent->lookup_mods;
+        }
+      }
+    }
+  }
+  InitInputEvent(aKeyEvent, modifierState);
+
+  switch (aGdkKeyEvent->keyval) {
+    case GDK_Shift_L:
+    case GDK_Control_L:
+    case GDK_Alt_L:
+    case GDK_Super_L:
+    case GDK_Hyper_L:
+    case GDK_Meta_L:
+      aKeyEvent.mLocation = eKeyLocationLeft;
+      break;
+
+    case GDK_Shift_R:
+    case GDK_Control_R:
+    case GDK_Alt_R:
+    case GDK_Super_R:
+    case GDK_Hyper_R:
+    case GDK_Meta_R:
+      aKeyEvent.mLocation = eKeyLocationRight;
+      break;
+
+    case GDK_KP_0:
+    case GDK_KP_1:
+    case GDK_KP_2:
+    case GDK_KP_3:
+    case GDK_KP_4:
+    case GDK_KP_5:
+    case GDK_KP_6:
+    case GDK_KP_7:
+    case GDK_KP_8:
+    case GDK_KP_9:
+    case GDK_KP_Space:
+    case GDK_KP_Tab:
+    case GDK_KP_Enter:
+    case GDK_KP_F1:
+    case GDK_KP_F2:
+    case GDK_KP_F3:
+    case GDK_KP_F4:
+    case GDK_KP_Home:
+    case GDK_KP_Left:
+    case GDK_KP_Up:
+    case GDK_KP_Right:
+    case GDK_KP_Down:
+    case GDK_KP_Prior:  // same as GDK_KP_Page_Up
+    case GDK_KP_Next:   // same as GDK_KP_Page_Down
+    case GDK_KP_End:
+    case GDK_KP_Begin:
+    case GDK_KP_Insert:
+    case GDK_KP_Delete:
+    case GDK_KP_Equal:
+    case GDK_KP_Multiply:
+    case GDK_KP_Add:
+    case GDK_KP_Separator:
+    case GDK_KP_Subtract:
+    case GDK_KP_Decimal:
+    case GDK_KP_Divide:
+      aKeyEvent.mLocation = eKeyLocationNumpad;
+      break;
+
+    default:
+      aKeyEvent.mLocation = eKeyLocationStandard;
+      break;
+  }
+
+  // The transformations above and in gdk for the keyval are not invertible
+  // so link to the GdkEvent (which will vanish soon after return from the
+  // event callback) to give plugins access to hardware_keycode and state.
+  // (An XEvent would be nice but the GdkEvent is good enough.)
+  aKeyEvent.mPluginEvent.Copy(*aGdkKeyEvent);
+  aKeyEvent.mTime = aGdkKeyEvent->time;
+  aKeyEvent.mNativeKeyEvent = static_cast<void*>(aGdkKeyEvent);
+  aKeyEvent.mIsRepeat =
+      sRepeatState == REPEATING &&
+      aGdkKeyEvent->hardware_keycode == sLastRepeatableHardwareKeyCode;
+
+  MOZ_LOG(
+      gKeymapWrapperLog, LogLevel::Info,
+      ("%p InitKeyEvent, modifierState=0x%08X "
+       "aKeyEvent={ mMessage=%s, isShift=%s, isControl=%s, "
+       "isAlt=%s, isMeta=%s , mKeyCode=0x%02X, mCharCode=%s, "
+       "mKeyNameIndex=%s, mKeyValue=%s, mCodeNameIndex=%s, mCodeValue=%s, "
+       "mLocation=%s, mIsRepeat=%s }",
+       keymapWrapper, modifierState, ToChar(aKeyEvent.mMessage),
+       GetBoolName(aKeyEvent.IsShift()), GetBoolName(aKeyEvent.IsControl()),
+       GetBoolName(aKeyEvent.IsAlt()), GetBoolName(aKeyEvent.IsMeta()),
+       aKeyEvent.mKeyCode,
+       GetCharacterCodeName(static_cast<char16_t>(aKeyEvent.mCharCode)).get(),
+       ToString(aKeyEvent.mKeyNameIndex).get(),
+       GetCharacterCodeNames(aKeyEvent.mKeyValue).get(),
+       ToString(aKeyEvent.mCodeNameIndex).get(),
+       GetCharacterCodeNames(aKeyEvent.mCodeValue).get(),
+       GetKeyLocationName(aKeyEvent.mLocation).get(),
+       GetBoolName(aKeyEvent.mIsRepeat)));
+}
+
+/* static */
+uint32_t KeymapWrapper::GetCharCodeFor(const GdkEventKey* aGdkKeyEvent) {
+  // Anything above 0xf000 is considered a non-printable
+  // Exception: directly encoded UCS characters
+  if (aGdkKeyEvent->keyval > 0xf000 &&
+      (aGdkKeyEvent->keyval & 0xff000000) != 0x01000000) {
+    // Keypad keys are an exception: they return a value different
+    // from their non-keypad equivalents, but mozilla doesn't distinguish.
+    switch (aGdkKeyEvent->keyval) {
+      case GDK_KP_Space:
+        return ' ';
+      case GDK_KP_Equal:
+        return '=';
+      case GDK_KP_Multiply:
+        return '*';
+      case GDK_KP_Add:
+        return '+';
+      case GDK_KP_Separator:
+        return ',';
+      case GDK_KP_Subtract:
+        return '-';
+      case GDK_KP_Decimal:
+        return '.';
+      case GDK_KP_Divide:
+        return '/';
+      case GDK_KP_0:
+        return '0';
+      case GDK_KP_1:
+        return '1';
+      case GDK_KP_2:
+        return '2';
+      case GDK_KP_3:
+        return '3';
+      case GDK_KP_4:
+        return '4';
+      case GDK_KP_5:
+        return '5';
+      case GDK_KP_6:
+        return '6';
+      case GDK_KP_7:
+        return '7';
+      case GDK_KP_8:
+        return '8';
+      case GDK_KP_9:
+        return '9';
+      default:
+        return 0;  // non-printables
+    }
+  }
+
+  static const long MAX_UNICODE = 0x10FFFF;
+
+  // we're supposedly printable, let's try to convert
+  long ucs = keysym2ucs(aGdkKeyEvent->keyval);
+  if ((ucs != -1) && (ucs < MAX_UNICODE)) {
+    return ucs;
+  }
+
+  // I guess we couldn't convert
+  return 0;
+}
+
+uint32_t KeymapWrapper::GetCharCodeFor(const GdkEventKey* aGdkKeyEvent,
+                                       guint aModifierState, gint aGroup) {
+  guint keyval;
+  if (!gdk_keymap_translate_keyboard_state(
+          mGdkKeymap, aGdkKeyEvent->hardware_keycode,
+          GdkModifierType(aModifierState), aGroup, &keyval, nullptr, nullptr,
+          nullptr)) {
+    return 0;
+  }
+  GdkEventKey tmpEvent = *aGdkKeyEvent;
+  tmpEvent.state = aModifierState;
+  tmpEvent.keyval = keyval;
+  tmpEvent.group = aGroup;
+  return GetCharCodeFor(&tmpEvent);
+}
+
+uint32_t KeymapWrapper::GetUnmodifiedCharCodeFor(
+    const GdkEventKey* aGdkKeyEvent) {
+  guint state = aGdkKeyEvent->state &
+                (GetModifierMask(SHIFT) | GetModifierMask(CAPS_LOCK) |
+                 GetModifierMask(NUM_LOCK) | GetModifierMask(SCROLL_LOCK) |
+                 GetModifierMask(LEVEL3) | GetModifierMask(LEVEL5));
+  uint32_t charCode =
+      GetCharCodeFor(aGdkKeyEvent, GdkModifierType(state), aGdkKeyEvent->group);
+  if (charCode) {
+    return charCode;
+  }
+  // If no character is mapped to the key when Level3 Shift or Level5 Shift
+  // is active, let's return a character which is inputted by the key without
+  // Level3 nor Level5 Shift.
+  guint stateWithoutAltGraph =
+      state & ~(GetModifierMask(LEVEL3) | GetModifierMask(LEVEL5));
+  if (state == stateWithoutAltGraph) {
+    return 0;
+  }
+  return GetCharCodeFor(aGdkKeyEvent, GdkModifierType(stateWithoutAltGraph),
+                        aGdkKeyEvent->group);
+}
+
+gint KeymapWrapper::GetKeyLevel(GdkEventKey* aGdkKeyEvent) {
+  gint level;
+  if (!gdk_keymap_translate_keyboard_state(
+          mGdkKeymap, aGdkKeyEvent->hardware_keycode,
+          GdkModifierType(aGdkKeyEvent->state), aGdkKeyEvent->group, nullptr,
+          nullptr, &level, nullptr)) {
+    return -1;
+  }
+  return level;
+}
+
+gint KeymapWrapper::GetFirstLatinGroup() {
+  GdkKeymapKey* keys;
+  gint count;
+  gint minGroup = -1;
+  if (gdk_keymap_get_entries_for_keyval(mGdkKeymap, GDK_a, &keys, &count)) {
+    // find the minimum number group for latin inputtable layout
+    for (gint i = 0; i < count && minGroup != 0; ++i) {
+      if (keys[i].level != 0 && keys[i].level != 1) {
+        continue;
+      }
+      if (minGroup >= 0 && keys[i].group > minGroup) {
+        continue;
+      }
+      minGroup = keys[i].group;
+    }
+    g_free(keys);
+  }
+  return minGroup;
+}
+
+bool KeymapWrapper::IsLatinGroup(guint8 aGroup) {
+  GdkKeymapKey* keys;
+  gint count;
+  bool result = false;
+  if (gdk_keymap_get_entries_for_keyval(mGdkKeymap, GDK_a, &keys, &count)) {
+    for (gint i = 0; i < count; ++i) {
+      if (keys[i].level != 0 && keys[i].level != 1) {
+        continue;
+      }
+      if (keys[i].group == aGroup) {
+        result = true;
+        break;
+      }
+    }
+    g_free(keys);
+  }
+  return result;
+}
+
+bool KeymapWrapper::IsAutoRepeatableKey(guint aHardwareKeyCode) {
+  uint8_t indexOfArray = aHardwareKeyCode / 8;
+  MOZ_ASSERT(indexOfArray < ArrayLength(mKeyboardState.auto_repeats),
+             "invalid index");
+  char bitMask = 1 << (aHardwareKeyCode % 8);
+  return (mKeyboardState.auto_repeats[indexOfArray] & bitMask) != 0;
+}
+
+/* static */
+bool KeymapWrapper::IsBasicLatinLetterOrNumeral(uint32_t aCharCode) {
+  return (aCharCode >= 'a' && aCharCode <= 'z') ||
+         (aCharCode >= 'A' && aCharCode <= 'Z') ||
+         (aCharCode >= '0' && aCharCode <= '9');
+}
+
+/* static */
+guint KeymapWrapper::GetGDKKeyvalWithoutModifier(
+    const GdkEventKey* aGdkKeyEvent) {
+  KeymapWrapper* keymapWrapper = GetInstance();
+  guint state =
+      (aGdkKeyEvent->state & keymapWrapper->GetModifierMask(NUM_LOCK));
+  guint keyval;
+  if (!gdk_keymap_translate_keyboard_state(
+          keymapWrapper->mGdkKeymap, aGdkKeyEvent->hardware_keycode,
+          GdkModifierType(state), aGdkKeyEvent->group, &keyval, nullptr,
+          nullptr, nullptr)) {
+    return 0;
+  }
+  return keyval;
+}
+
+/* static */
+uint32_t KeymapWrapper::GetDOMKeyCodeFromKeyPairs(guint aGdkKeyval) {
+  switch (aGdkKeyval) {
+    case GDK_Cancel:
+      return NS_VK_CANCEL;
+    case GDK_BackSpace:
+      return NS_VK_BACK;
+    case GDK_Tab:
+    case GDK_ISO_Left_Tab:
+      return NS_VK_TAB;
+    case GDK_Clear:
+      return NS_VK_CLEAR;
+    case GDK_Return:
+      return NS_VK_RETURN;
+    case GDK_Shift_L:
+    case GDK_Shift_R:
+    case GDK_Shift_Lock:
+      return NS_VK_SHIFT;
+    case GDK_Control_L:
+    case GDK_Control_R:
+      return NS_VK_CONTROL;
+    case GDK_Alt_L:
+    case GDK_Alt_R:
+      return NS_VK_ALT;
+    case GDK_Meta_L:
+    case GDK_Meta_R:
+      return NS_VK_META;
+
+    // Assume that Super or Hyper is always mapped to physical Win key.
+    case GDK_Super_L:
+    case GDK_Super_R:
+    case GDK_Hyper_L:
+    case GDK_Hyper_R:
+      return NS_VK_WIN;
+
+    // GTK's AltGraph key is similar to Mac's Option (Alt) key.  However,
+    // unfortunately, browsers on Mac are using NS_VK_ALT for it even though
+    // it's really different from Alt key on Windows.
+    // On the other hand, GTK's AltGrapsh keys are really different from
+    // Alt key.  However, there is no AltGrapsh key on Windows.  On Windows,
+    // both Ctrl and Alt keys are pressed internally when AltGr key is
+    // pressed.  For some languages' users, AltGraph key is important, so,
+    // web applications on such locale may want to know AltGraph key press.
+    // Therefore, we should map AltGr keycode for them only on GTK.
+    case GDK_ISO_Level3_Shift:
+    case GDK_ISO_Level5_Shift:
+    // We assume that Mode_switch is always used for level3 shift.
+    case GDK_Mode_switch:
+      return NS_VK_ALTGR;
+
+    case GDK_Pause:
+      return NS_VK_PAUSE;
+    case GDK_Caps_Lock:
+      return NS_VK_CAPS_LOCK;
+    case GDK_Kana_Lock:
+    case GDK_Kana_Shift:
+      return NS_VK_KANA;
+    case GDK_Hangul:
+      return NS_VK_HANGUL;
+    // case GDK_XXX:                   return NS_VK_JUNJA;
+    // case GDK_XXX:                   return NS_VK_FINAL;
+    case GDK_Hangul_Hanja:
+      return NS_VK_HANJA;
+    case GDK_Kanji:
+      return NS_VK_KANJI;
+    case GDK_Escape:
+      return NS_VK_ESCAPE;
+    case GDK_Henkan:
+      return NS_VK_CONVERT;
+    case GDK_Muhenkan:
+      return NS_VK_NONCONVERT;
+    // case GDK_XXX:                   return NS_VK_ACCEPT;
+    // case GDK_XXX:                   return NS_VK_MODECHANGE;
+    case GDK_Page_Up:
+      return NS_VK_PAGE_UP;
+    case GDK_Page_Down:
+      return NS_VK_PAGE_DOWN;
+    case GDK_End:
+      return NS_VK_END;
+    case GDK_Home:
+      return NS_VK_HOME;
+    case GDK_Left:
+      return NS_VK_LEFT;
+    case GDK_Up:
+      return NS_VK_UP;
+    case GDK_Right:
+      return NS_VK_RIGHT;
+    case GDK_Down:
+      return NS_VK_DOWN;
+    case GDK_Select:
+      return NS_VK_SELECT;
+    case GDK_Print:
+      return NS_VK_PRINT;
+    case GDK_Execute:
+      return NS_VK_EXECUTE;
+    case GDK_Insert:
+      return NS_VK_INSERT;
+    case GDK_Delete:
+      return NS_VK_DELETE;
+    case GDK_Help:
+      return NS_VK_HELP;
+
+    // keypad keys
+    case GDK_KP_Left:
+      return NS_VK_LEFT;
+    case GDK_KP_Right:
+      return NS_VK_RIGHT;
+    case GDK_KP_Up:
+      return NS_VK_UP;
+    case GDK_KP_Down:
+      return NS_VK_DOWN;
+    case GDK_KP_Page_Up:
+      return NS_VK_PAGE_UP;
+    // Not sure what these are
+    // case GDK_KP_Prior:              return NS_VK_;
+    // case GDK_KP_Next:               return NS_VK_;
+    case GDK_KP_Begin:
+      return NS_VK_CLEAR;  // Num-unlocked 5
+    case GDK_KP_Page_Down:
+      return NS_VK_PAGE_DOWN;
+    case GDK_KP_Home:
+      return NS_VK_HOME;
+    case GDK_KP_End:
+      return NS_VK_END;
+    case GDK_KP_Insert:
+      return NS_VK_INSERT;
+    case GDK_KP_Delete:
+      return NS_VK_DELETE;
+    case GDK_KP_Enter:
+      return NS_VK_RETURN;
+
+    case GDK_Num_Lock:
+      return NS_VK_NUM_LOCK;
+    case GDK_Scroll_Lock:
+      return NS_VK_SCROLL_LOCK;
+
+    // Function keys
+    case GDK_F1:
+      return NS_VK_F1;
+    case GDK_F2:
+      return NS_VK_F2;
+    case GDK_F3:
+      return NS_VK_F3;
+    case GDK_F4:
+      return NS_VK_F4;
+    case GDK_F5:
+      return NS_VK_F5;
+    case GDK_F6:
+      return NS_VK_F6;
+    case GDK_F7:
+      return NS_VK_F7;
+    case GDK_F8:
+      return NS_VK_F8;
+    case GDK_F9:
+      return NS_VK_F9;
+    case GDK_F10:
+      return NS_VK_F10;
+    case GDK_F11:
+      return NS_VK_F11;
+    case GDK_F12:
+      return NS_VK_F12;
+    case GDK_F13:
+      return NS_VK_F13;
+    case GDK_F14:
+      return NS_VK_F14;
+    case GDK_F15:
+      return NS_VK_F15;
+    case GDK_F16:
+      return NS_VK_F16;
+    case GDK_F17:
+      return NS_VK_F17;
+    case GDK_F18:
+      return NS_VK_F18;
+    case GDK_F19:
+      return NS_VK_F19;
+    case GDK_F20:
+      return NS_VK_F20;
+    case GDK_F21:
+      return NS_VK_F21;
+    case GDK_F22:
+      return NS_VK_F22;
+    case GDK_F23:
+      return NS_VK_F23;
+    case GDK_F24:
+      return NS_VK_F24;
+
+    // context menu key, keysym 0xff67, typically keycode 117 on 105-key
+    // (Microsoft) x86 keyboards, located between right 'Windows' key and
+    // right Ctrl key
+    case GDK_Menu:
+      return NS_VK_CONTEXT_MENU;
+    case GDK_Sleep:
+      return NS_VK_SLEEP;
+
+    case GDK_3270_Attn:
+      return NS_VK_ATTN;
+    case GDK_3270_CursorSelect:
+      return NS_VK_CRSEL;
+    case GDK_3270_ExSelect:
+      return NS_VK_EXSEL;
+    case GDK_3270_EraseEOF:
+      return NS_VK_EREOF;
+    case GDK_3270_Play:
+      return NS_VK_PLAY;
+    // case GDK_XXX:                   return NS_VK_ZOOM;
+    case GDK_3270_PA1:
+      return NS_VK_PA1;
+
+    // map Sun Keyboard special keysyms on to NS_VK keys
+
+    // Sun F11 key generates SunF36(0x1005ff10) keysym
+    case 0x1005ff10:
+      return NS_VK_F11;
+    // Sun F12 key generates SunF37(0x1005ff11) keysym
+    case 0x1005ff11:
+      return NS_VK_F12;
+    default:
+      return 0;
+  }
+}
+
+void KeymapWrapper::WillDispatchKeyboardEvent(WidgetKeyboardEvent& aKeyEvent,
+                                              GdkEventKey* aGdkKeyEvent) {
+  GetInstance()->WillDispatchKeyboardEventInternal(aKeyEvent, aGdkKeyEvent);
+}
+
+void KeymapWrapper::WillDispatchKeyboardEventInternal(
+    WidgetKeyboardEvent& aKeyEvent, GdkEventKey* aGdkKeyEvent) {
+  if (!aGdkKeyEvent) {
+    // If aGdkKeyEvent is nullptr, we're trying to dispatch a fake keyboard
+    // event in such case, we don't need to set alternative char codes.
+    // So, we don't need to do nothing here.  This case is typically we're
+    // dispatching eKeyDown or eKeyUp event during composition.
+    return;
+  }
+
+  uint32_t charCode = GetCharCodeFor(aGdkKeyEvent);
+  if (!charCode) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p WillDispatchKeyboardEventInternal, "
+             "mKeyCode=0x%02X, charCode=0x%08X",
+             this, aKeyEvent.mKeyCode, aKeyEvent.mCharCode));
+    return;
+  }
+
+  // The mCharCode was set from mKeyValue. However, for example, when Ctrl key
+  // is pressed, its value should indicate an ASCII character for backward
+  // compatibility rather than inputting character without the modifiers.
+  // Therefore, we need to modify mCharCode value here.
+  aKeyEvent.SetCharCode(charCode);
+
+  gint level = GetKeyLevel(aGdkKeyEvent);
+  if (level != 0 && level != 1) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p WillDispatchKeyboardEventInternal, "
+             "mKeyCode=0x%02X, mCharCode=0x%08X, level=%d",
+             this, aKeyEvent.mKeyCode, aKeyEvent.mCharCode, level));
+    return;
+  }
+
+  guint baseState =
+      aGdkKeyEvent->state & ~(GetModifierMask(SHIFT) | GetModifierMask(CTRL) |
+                              GetModifierMask(ALT) | GetModifierMask(META) |
+                              GetModifierMask(SUPER) | GetModifierMask(HYPER));
+
+  // We shold send both shifted char and unshifted char, all keyboard layout
+  // users can use all keys.  Don't change event.mCharCode. On some keyboard
+  // layouts, Ctrl/Alt/Meta keys are used for inputting some characters.
+  AlternativeCharCode altCharCodes(0, 0);
+  // unshifted charcode of current keyboard layout.
+  altCharCodes.mUnshiftedCharCode =
+      GetCharCodeFor(aGdkKeyEvent, baseState, aGdkKeyEvent->group);
+  bool isLatin = (altCharCodes.mUnshiftedCharCode <= 0xFF);
+  // shifted charcode of current keyboard layout.
+  altCharCodes.mShiftedCharCode = GetCharCodeFor(
+      aGdkKeyEvent, baseState | GetModifierMask(SHIFT), aGdkKeyEvent->group);
+  isLatin = isLatin && (altCharCodes.mShiftedCharCode <= 0xFF);
+  if (altCharCodes.mUnshiftedCharCode || altCharCodes.mShiftedCharCode) {
+    aKeyEvent.mAlternativeCharCodes.AppendElement(altCharCodes);
+  }
+
+  bool needLatinKeyCodes = !isLatin;
+  if (!needLatinKeyCodes) {
+    needLatinKeyCodes =
+        (IS_ASCII_ALPHABETICAL(altCharCodes.mUnshiftedCharCode) !=
+         IS_ASCII_ALPHABETICAL(altCharCodes.mShiftedCharCode));
+  }
+
+  // If current keyboard layout can input Latin characters, we don't need
+  // more information.
+  if (!needLatinKeyCodes) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p WillDispatchKeyboardEventInternal, "
+             "mKeyCode=0x%02X, mCharCode=0x%08X, level=%d, altCharCodes={ "
+             "mUnshiftedCharCode=0x%08X, mShiftedCharCode=0x%08X }",
+             this, aKeyEvent.mKeyCode, aKeyEvent.mCharCode, level,
+             altCharCodes.mUnshiftedCharCode, altCharCodes.mShiftedCharCode));
+    return;
+  }
+
+  // Next, find Latin inputtable keyboard layout.
+  gint minGroup = GetFirstLatinGroup();
+  if (minGroup < 0) {
+    MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+            ("%p WillDispatchKeyboardEventInternal, "
+             "Latin keyboard layout isn't found: "
+             "mKeyCode=0x%02X, mCharCode=0x%08X, level=%d, "
+             "altCharCodes={ mUnshiftedCharCode=0x%08X, "
+             "mShiftedCharCode=0x%08X }",
+             this, aKeyEvent.mKeyCode, aKeyEvent.mCharCode, level,
+             altCharCodes.mUnshiftedCharCode, altCharCodes.mShiftedCharCode));
+    return;
+  }
+
+  AlternativeCharCode altLatinCharCodes(0, 0);
+  uint32_t unmodifiedCh = aKeyEvent.IsShift() ? altCharCodes.mShiftedCharCode
+                                              : altCharCodes.mUnshiftedCharCode;
+
+  // unshifted charcode of found keyboard layout.
+  uint32_t ch = GetCharCodeFor(aGdkKeyEvent, baseState, minGroup);
+  altLatinCharCodes.mUnshiftedCharCode =
+      IsBasicLatinLetterOrNumeral(ch) ? ch : 0;
+  // shifted charcode of found keyboard layout.
+  ch = GetCharCodeFor(aGdkKeyEvent, baseState | GetModifierMask(SHIFT),
+                      minGroup);
+  altLatinCharCodes.mShiftedCharCode = IsBasicLatinLetterOrNumeral(ch) ? ch : 0;
+  if (altLatinCharCodes.mUnshiftedCharCode ||
+      altLatinCharCodes.mShiftedCharCode) {
+    aKeyEvent.mAlternativeCharCodes.AppendElement(altLatinCharCodes);
+  }
+  // If the mCharCode is not Latin, and the level is 0 or 1, we should
+  // replace the mCharCode to Latin char if Alt and Meta keys are not
+  // pressed. (Alt should be sent the localized char for accesskey
+  // like handling of Web Applications.)
+  ch = aKeyEvent.IsShift() ? altLatinCharCodes.mShiftedCharCode
+                           : altLatinCharCodes.mUnshiftedCharCode;
+  if (ch && !(aKeyEvent.IsAlt() || aKeyEvent.IsMeta()) &&
+      charCode == unmodifiedCh) {
+    aKeyEvent.SetCharCode(ch);
+  }
+
+  MOZ_LOG(gKeymapWrapperLog, LogLevel::Info,
+          ("%p WillDispatchKeyboardEventInternal, "
+           "mKeyCode=0x%02X, mCharCode=0x%08X, level=%d, minGroup=%d, "
+           "altCharCodes={ mUnshiftedCharCode=0x%08X, "
+           "mShiftedCharCode=0x%08X } "
+           "altLatinCharCodes={ mUnshiftedCharCode=0x%08X, "
+           "mShiftedCharCode=0x%08X }",
+           this, aKeyEvent.mKeyCode, aKeyEvent.mCharCode, level, minGroup,
+           altCharCodes.mUnshiftedCharCode, altCharCodes.mShiftedCharCode,
+           altLatinCharCodes.mUnshiftedCharCode,
+           altLatinCharCodes.mShiftedCharCode));
+}
+
+}  // namespace widget
+}  // namespace mozilla
diff --git a/widget/gtk/nsGtkKeyUtils.h b/widget/gtk/nsGtkKeyUtils.h
index 3354cf2fee..14b19b9628 100644
--- a/widget/gtk/nsGtkKeyUtils.h
+++ b/widget/gtk/nsGtkKeyUtils.h
@@ -12,7 +12,9 @@
 #include "mozilla/EventForwards.h"
 
 #include <gdk/gdk.h>
-#include <X11/XKBlib.h>
+#ifdef MOZ_X11
+#  include <X11/XKBlib.h>
+#endif
 #ifdef MOZ_WAYLAND
 #  include <gdk/gdkwayland.h>
 #  include <xkbcommon/xkbcommon.h>
@@ -224,8 +226,10 @@ class KeymapWrapper {
    * Initializing methods.
    */
   void Init();
+#ifdef MOZ_X11
   void InitXKBExtension();
   void InitBySystemSettingsX11();
+#endif
 #ifdef MOZ_WAYLAND
   void InitBySystemSettingsWayland();
 #endif
@@ -301,6 +305,7 @@ class KeymapWrapper {
    */
   int mXKBBaseEventCode;
 
+#ifdef MOZ_X11
   /**
    * Only auto_repeats[] stores valid value.  If you need to use other
    * members, you need to listen notification events for them.
@@ -308,6 +313,7 @@ class KeymapWrapper {
    * InitXKBExtension().
    */
   XKeyboardState mKeyboardState;
+#endif
 
   /**
    * Pointer of the singleton instance.
@@ -318,7 +324,9 @@ class KeymapWrapper {
    * Auto key repeat management.
    */
   static guint sLastRepeatableHardwareKeyCode;
+#ifdef MOZ_X11
   static Time sLastRepeatableKeyTime;
+#endif
   enum RepeatState { NOT_PRESSED, FIRST_PRESS, REPEATING };
   static RepeatState sRepeatState;
 
@@ -424,6 +432,7 @@ class KeymapWrapper {
    */
   static uint32_t GetDOMKeyCodeFromKeyPairs(guint aGdkKeyval);
 
+#ifdef MOZ_X11
   /**
    * FilterEvents() listens all events on all our windows.
    * Be careful, this may make damage to performance if you add expensive
@@ -431,6 +440,7 @@ class KeymapWrapper {
    */
   static GdkFilterReturn FilterEvents(GdkXEvent* aXEvent, GdkEvent* aGdkEvent,
                                       gpointer aData);
+#endif
 
   /**
    * MaybeDispatchContextMenuEvent() may dispatch eContextMenu event if
diff --git a/widget/gtk/nsLookAndFeel.cpp b/widget/gtk/nsLookAndFeel.cpp
index 8c92f6ca3c..0265300969 100644
--- a/widget/gtk/nsLookAndFeel.cpp
+++ b/widget/gtk/nsLookAndFeel.cpp
@@ -38,6 +38,8 @@
 #include "WidgetStyleCache.h"
 #include "prenv.h"
 #include "nsCSSColorUtils.h"
+#include "mozilla/Preferences.h"
+#include <dlfcn.h>
 
 using namespace mozilla;
 using mozilla::LookAndFeel;
diff --git a/widget/gtk/nsPrintDialogGTK.cpp b/widget/gtk/nsPrintDialogGTK.cpp
index 9c1a72a6e3..04bddae735 100644
--- a/widget/gtk/nsPrintDialogGTK.cpp
+++ b/widget/gtk/nsPrintDialogGTK.cpp
@@ -25,7 +25,10 @@
 #include "nsIObserverService.h"
 
 // for gdk_x11_window_get_xid
-#include <gdk/gdkx.h>
+#include <gdk/gdk.h>
+#ifdef MOZ_X11
+#  include <gdk/gdkx.h>
+#endif
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
@@ -527,6 +530,7 @@ static gboolean window_export_handle(GtkWindow* window,
                                      GtkWindowHandleExported callback,
                                      gpointer user_data) {
   if (gfxPlatformGtk::GetPlatform()->IsX11Display()) {
+#ifdef MOZ_X11
     GdkWindow* gdk_window = gtk_widget_get_window(GTK_WIDGET(window));
     char* handle_str;
     guint32 xid = (guint32)gdk_x11_window_get_xid(gdk_window);
@@ -535,6 +539,7 @@ static gboolean window_export_handle(GtkWindow* window,
     callback(window, handle_str, user_data);
     g_free(handle_str);
     return true;
+#endif
   }
 #ifdef MOZ_WAYLAND
   else {
diff --git a/widget/gtk/nsUserIdleServiceGTK.cpp b/widget/gtk/nsUserIdleServiceGTK.cpp
index 882ded8cad..09b94eb675 100644
--- a/widget/gtk/nsUserIdleServiceGTK.cpp
+++ b/widget/gtk/nsUserIdleServiceGTK.cpp
@@ -16,6 +16,7 @@ using mozilla::LogLevel;
 
 static mozilla::LazyLogModule sIdleLog("nsIUserIdleService");
 
+#ifdef MOZ_X11
 typedef bool (*_XScreenSaverQueryExtension_fn)(Display* dpy, int* event_base,
                                                int* error_base);
 
@@ -24,12 +25,14 @@ typedef XScreenSaverInfo* (*_XScreenSaverAllocInfo_fn)(void);
 typedef void (*_XScreenSaverQueryInfo_fn)(Display* dpy, Drawable drw,
                                           XScreenSaverInfo* info);
 
-static bool sInitialized = false;
 static _XScreenSaverQueryExtension_fn _XSSQueryExtension = nullptr;
 static _XScreenSaverAllocInfo_fn _XSSAllocInfo = nullptr;
 static _XScreenSaverQueryInfo_fn _XSSQueryInfo = nullptr;
+#endif
+static bool sInitialized = false;
 
 static void Initialize() {
+#ifdef MOZ_X11
   if (!gdk_display_get_default() ||
       !GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
     return;
@@ -59,14 +62,21 @@ static void Initialize() {
     MOZ_LOG(sIdleLog, LogLevel::Warning, ("Failed to get XSSQueryInfo!\n"));
 
   sInitialized = true;
+#endif
 }
 
+#ifdef MOZ_X11
 nsUserIdleServiceGTK::nsUserIdleServiceGTK() : mXssInfo(nullptr) {
+#else
+nsUserIdleServiceGTK::nsUserIdleServiceGTK() {
+#endif
   Initialize();
 }
 
 nsUserIdleServiceGTK::~nsUserIdleServiceGTK() {
+#ifdef MOZ_X11
   if (mXssInfo) XFree(mXssInfo);
+#endif
 
 // It is not safe to unload libXScrnSaver until each display is closed because
 // the library registers callbacks through XESetCloseDisplay (Bug 397607).
@@ -80,6 +90,7 @@ nsUserIdleServiceGTK::~nsUserIdleServiceGTK() {
 }
 
 bool nsUserIdleServiceGTK::PollIdleTime(uint32_t* aIdleTime) {
+#ifdef MOZ_X11
   if (!sInitialized) {
     // For some reason, we could not find xscreensaver.
     return false;
@@ -109,6 +120,7 @@ bool nsUserIdleServiceGTK::PollIdleTime(uint32_t* aIdleTime) {
   }
   // If we get here, we couldn't get to XScreenSaver:
   MOZ_LOG(sIdleLog, LogLevel::Warning, ("XSSQueryExtension returned false!\n"));
+#endif
   return false;
 }
 
diff --git a/widget/gtk/nsUserIdleServiceGTK.h b/widget/gtk/nsUserIdleServiceGTK.h
index 9b9ba31846..e596283e24 100644
--- a/widget/gtk/nsUserIdleServiceGTK.h
+++ b/widget/gtk/nsUserIdleServiceGTK.h
@@ -9,10 +9,13 @@
 #define nsUserIdleServiceGTK_h__
 
 #include "nsUserIdleService.h"
-#include <X11/Xlib.h>
-#include <X11/Xutil.h>
-#include <gdk/gdkx.h>
+#ifdef MOZ_X11
+#  include <X11/Xlib.h>
+#  include <X11/Xutil.h>
+#  include <gdk/gdkx.h>
+#endif
 
+#ifdef MOZ_X11
 typedef struct {
   Window window;               // Screen saver window
   int state;                   // ScreenSaver(Off,On,Disabled)
@@ -21,6 +24,7 @@ typedef struct {
   unsigned long idle;          // milliseconds idle
   unsigned long event_mask;    // event stuff
 } XScreenSaverInfo;
+#endif
 
 class nsUserIdleServiceGTK : public nsUserIdleService {
  public:
@@ -40,7 +44,9 @@ class nsUserIdleServiceGTK : public nsUserIdleService {
 
  private:
   ~nsUserIdleServiceGTK();
+#ifdef MOZ_X11
   XScreenSaverInfo* mXssInfo;
+#endif
 
  protected:
   nsUserIdleServiceGTK();
diff --git a/widget/gtk/nsWaylandDisplay.cpp b/widget/gtk/nsWaylandDisplay.cpp
index c6be3c3e27..94df72bd90 100644
--- a/widget/gtk/nsWaylandDisplay.cpp
+++ b/widget/gtk/nsWaylandDisplay.cpp
@@ -103,7 +103,7 @@ RefPtr<nsWaylandDisplay> WaylandDisplayGet(GdkDisplay* aGdkDisplay) {
 wl_display* WaylandDisplayGetWLDisplay(GdkDisplay* aGdkDisplay) {
   if (!aGdkDisplay) {
     aGdkDisplay = gdk_display_get_default();
-    if (!aGdkDisplay || GDK_IS_X11_DISPLAY(aGdkDisplay)) {
+    if (!aGdkDisplay || !GDK_IS_WAYLAND_DISPLAY(aGdkDisplay)) {
       return nullptr;
     }
   }
diff --git a/widget/gtk/nsWidgetFactory.cpp b/widget/gtk/nsWidgetFactory.cpp
index d649c7e0bf..b499207736 100644
--- a/widget/gtk/nsWidgetFactory.cpp
+++ b/widget/gtk/nsWidgetFactory.cpp
@@ -20,7 +20,7 @@
 #include "nsHTMLFormatConverter.h"
 #include "HeadlessClipboard.h"
 #include "IMContextWrapper.h"
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
 #  include "nsClipboard.h"
 #endif
 #include "TaskbarProgress.h"
@@ -36,7 +36,7 @@
 using namespace mozilla;
 using namespace mozilla::widget;
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
 NS_IMPL_COMPONENT_FACTORY(nsIClipboard) {
   nsCOMPtr<nsIClipboard> inst;
   if (gfxPlatform::IsHeadless()) {
diff --git a/widget/gtk/nsWindow.cpp b/widget/gtk/nsWindow.cpp
index fc1cdd098a..8fa1b2a77f 100644
--- a/widget/gtk/nsWindow.cpp
+++ b/widget/gtk/nsWindow.cpp
@@ -21,7 +21,9 @@
 #include "mozilla/TouchEvents.h"
 #include "mozilla/UniquePtrExtensions.h"
 #include "mozilla/WidgetUtils.h"
-#include "mozilla/X11Util.h"
+#ifdef MOZ_X11
+#  include "mozilla/X11Util.h"
+#endif
 #include "mozilla/XREAppData.h"
 #include "mozilla/dom/Document.h"
 #include "mozilla/dom/WheelEventBinding.h"
@@ -49,13 +51,14 @@
 #include "ScreenHelperGTK.h"
 
 #include <gtk/gtk.h>
-#include <gtk/gtkx.h>
 
 #ifdef MOZ_WAYLAND
 #  include <gdk/gdkwayland.h>
+#  include <gdk/gdkkeysyms-compat.h>
 #endif /* MOZ_WAYLAND */
 
 #ifdef MOZ_X11
+#  include <gtk/gtkx.h>
 #  include <gdk/gdkx.h>
 #  include <X11/Xatom.h>
 #  include <X11/extensions/XShm.h>
@@ -125,11 +128,13 @@ using namespace mozilla::widget;
 #include "mozilla/layers/APZInputBridge.h"
 #include "mozilla/layers/IAPZCTreeManager.h"
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
 #  include "mozilla/gfx/gfxVars.h"
-#  include "GLContextGLX.h"  // for GLContextGLX::FindVisual()
 #  include "GLContextEGL.h"  // for GLContextEGL::FindVisual()
 #  include "GtkCompositorWidget.h"
+#endif
+#ifdef MOZ_X11
+#  include "GLContextGLX.h"  // for GLContextGLX::FindVisual()
 #  include "gfxXlibSurface.h"
 #  include "WindowSurfaceX11Image.h"
 #  include "WindowSurfaceX11SHM.h"
@@ -152,7 +157,9 @@ using namespace mozilla::gfx;
 using namespace mozilla::widget;
 using namespace mozilla::layers;
 using mozilla::gl::GLContextEGL;
+#ifdef MOZ_X11
 using mozilla::gl::GLContextGLX;
+#endif
 
 // Don't put more than this many rects in the dirty region, just fluff
 // out to the bounding-box if there are more
@@ -277,6 +284,7 @@ bool nsWindow::sTransparentMainWindow = false;
 
 namespace mozilla {
 
+#ifdef MOZ_X11
 class CurrentX11TimeGetter {
  public:
   explicit CurrentX11TimeGetter(GdkWindow* aWindow)
@@ -324,6 +332,7 @@ class CurrentX11TimeGetter {
   GdkWindow* mWindow;
   TimeStamp mAsyncUpdateStart;
 };
+#endif
 
 }  // namespace mozilla
 
@@ -716,7 +725,7 @@ void nsWindow::Destroy() {
   // destroys the the gl context attached to it).
   DestroyCompositor();
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
   // Ensure any resources assigned to the window get cleaned up first
   // to avoid double-freeing.
   mSurfaceProvider.CleanupResources();
@@ -1872,6 +1881,7 @@ static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
     return false;
   }
 
+#ifdef MOZ_X11
   Display* xdisplay = gdk_x11_get_default_xdisplay();
   GdkScreen* screen = gdk_window_get_screen(gdk_window);
   Window root_win = GDK_WINDOW_XID(gdk_screen_get_root_window(screen));
@@ -1935,6 +1945,7 @@ static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
 
   wmName = reinterpret_cast<const char*>(prop_return);
   return true;
+#endif
 }
 
 #define kDesktopMutterSchema "org.gnome.mutter"
@@ -1991,6 +2002,7 @@ void nsWindow::GetWorkspaceID(nsAString& workspaceID) {
   if (!mIsX11Display || !mShell) {
     return;
   }
+#ifdef MOZ_X11
   // Get the gdk window for this widget.
   GdkWindow* gdk_window = gtk_widget_get_window(mShell);
   if (!gdk_window) {
@@ -2019,6 +2031,7 @@ void nsWindow::GetWorkspaceID(nsAString& workspaceID) {
 
   workspaceID.AppendInt((int32_t)wm_desktop[0]);
   g_free(wm_desktop);
+#endif
 }
 
 void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
@@ -2028,6 +2041,7 @@ void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
     return;
   }
 
+#ifdef MOZ_X11
   // Get the gdk window for this widget.
   GdkWindow* gdk_window = gtk_widget_get_window(mShell);
   if (!gdk_window) {
@@ -2061,6 +2075,7 @@ void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
              SubstructureNotifyMask | SubstructureRedirectMask, &xevent);
 
   XFlush(xdisplay);
+#endif
 }
 
 typedef void (*SetUserTimeFunc)(GdkWindow* aWindow, guint32 aTimestamp);
@@ -2100,10 +2115,14 @@ guint32 nsWindow::GetLastUserInputTime() {
   // WM_DELETE_WINDOW delete events, but not usually mouse motion nor
   // button and key releases.  Therefore use the most recent of
   // gdk_x11_display_get_user_time and the last time that we have seen.
+#ifdef MOZ_X11
   GdkDisplay* gdkDisplay = gdk_display_get_default();
   guint32 timestamp = GDK_IS_X11_DISPLAY(gdkDisplay)
                           ? gdk_x11_display_get_user_time(gdkDisplay)
                           : gtk_get_current_event_time();
+#else
+  guint32 timestamp = gtk_get_current_event_time();
+#endif
 
   if (sLastUserInputTime != GDK_CURRENT_TIME &&
       TimestampIsNewerThan(sLastUserInputTime, timestamp)) {
@@ -2157,6 +2176,7 @@ void nsWindow::SetFocus(Raise aRaise, mozilla::dom::CallerType aCallerType) {
         return;
       }
 
+#ifdef MOZ_X11
       uint32_t timestamp = GDK_CURRENT_TIME;
 
       nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
@@ -2168,6 +2188,7 @@ void nsWindow::SetFocus(Raise aRaise, mozilla::dom::CallerType aCallerType) {
       gtk_window_present_with_time(GTK_WINDOW(owningWindow->mShell), timestamp);
 
       if (GTKToolkit) GTKToolkit->SetFocusTimestamp(0);
+#endif
     }
     return;
   }
@@ -2250,6 +2271,7 @@ void nsWindow::UpdateClientOffsetFromFrameExtents() {
     return;
   }
 
+#ifdef MOZ_X11
   if (!mIsTopLevel || !mShell ||
       gtk_window_get_window_type(GTK_WINDOW(mShell)) == GTK_WINDOW_POPUP) {
     mClientOffset = nsIntPoint(0, 0);
@@ -2289,6 +2311,7 @@ void nsWindow::UpdateClientOffsetFromFrameExtents() {
 
   LOG(("nsWindow::UpdateClientOffsetFromFrameExtents [%p] %d,%d\n", (void*)this,
        mClientOffset.x, mClientOffset.y));
+#endif
 }
 
 LayoutDeviceIntPoint nsWindow::GetClientOffset() {
@@ -2303,9 +2326,11 @@ gboolean nsWindow::OnPropertyNotifyEvent(GtkWidget* aWidget,
     return FALSE;
   }
 
+#ifdef MOZ_X11
   if (GetCurrentTimeGetter()->PropertyNotifyHandler(aWidget, aEvent)) {
     return TRUE;
   }
+#endif
 
   return FALSE;
 }
@@ -2432,9 +2457,11 @@ void* nsWindow::GetNativeData(uint32_t aDataType) {
 
     case NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID:
     case NS_NATIVE_SHAREABLE_WINDOW:
+#ifdef MOZ_X11
       if (mIsX11Display) {
         return (void*)GDK_WINDOW_XID(gdk_window_get_toplevel(mGdkWindow));
       }
+#endif
       NS_WARNING(
           "nsWindow::GetNativeData(): "
           "NS_NATIVE_SHAREABLE_WINDOW / NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID is "
@@ -2456,9 +2483,11 @@ void* nsWindow::GetNativeData(uint32_t aDataType) {
     case NS_NATIVE_OPENGL_CONTEXT:
       return nullptr;
     case NS_NATIVE_EGL_WINDOW: {
+#ifdef MOZ_X11
       if (mIsX11Display) {
         return mGdkWindow ? (void*)GDK_WINDOW_XID(mGdkWindow) : nullptr;
       }
+#endif
 #ifdef MOZ_WAYLAND
       if (mContainer) {
         return moz_container_wayland_get_egl_window(mContainer,
@@ -2794,6 +2823,7 @@ gboolean nsWindow::OnExposeEvent(cairo_t* cr) {
   }
 #endif
 
+#ifdef MOZ_X11
   nsIWidgetListener* listener = GetListener();
   if (!listener) return FALSE;
 
@@ -3008,6 +3038,7 @@ gboolean nsWindow::OnExposeEvent(cairo_t* cr) {
 
   // check the return value!
   return TRUE;
+#endif
 }
 
 void nsWindow::UpdateAlpha(SourceSurface* aSourceSurface,
@@ -3181,7 +3212,7 @@ void nsWindow::OnSizeAllocate(GtkAllocation* aAllocation) {
 
   mBounds.SizeTo(size);
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
   // Notify the GtkCompositorWidget of a ClientSizeChange
   if (mCompositorWidgetDelegate) {
     mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
@@ -3286,6 +3317,7 @@ void nsWindow::OnMotionNotifyEvent(GdkEventMotion* aEvent) {
     MOZ_ASSERT(gdk_window, "gdk_window_get_toplevel should not return null");
 
     bool canDrag = true;
+#ifdef MOZ_X11
     if (mIsX11Display) {
       // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
       // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
@@ -3296,6 +3328,7 @@ void nsWindow::OnMotionNotifyEvent(GdkEventMotion* aEvent) {
         canDrag = false;
       }
     }
+#endif
 
     if (canDrag) {
       gdk_window_begin_move_drag(gdk_window, 1, aEvent->x_root, aEvent->y_root,
@@ -3741,15 +3774,18 @@ TimeStamp nsWindow::GetEventTimeStamp(guint32 aEventTime) {
         BaseTimeDurationPlatformUtils::TicksFromMilliseconds(timestampTime);
     eventTimeStamp = TimeStamp::FromSystemTime(tick);
   } else {
+#ifdef MOZ_X11
     CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
     MOZ_ASSERT(getCurrentTime,
                "Null current time getter despite having a window");
     eventTimeStamp =
         TimeConverter().GetTimeStampFromSystemTime(aEventTime, *getCurrentTime);
+#endif
   }
   return eventTimeStamp;
 }
 
+#ifdef MOZ_X11
 mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
   MOZ_ASSERT(mGdkWindow, "Expected mGdkWindow to be set");
   if (MOZ_UNLIKELY(!mCurrentTimeGetter)) {
@@ -3757,6 +3793,7 @@ mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
   }
   return mCurrentTimeGetter.get();
 }
+#endif
 
 gboolean nsWindow::OnKeyPressEvent(GdkEventKey* aEvent) {
   LOGFOCUS(("OnKeyPressEvent [%p]\n", (void*)this));
@@ -3917,6 +3954,7 @@ void nsWindow::OnWindowStateEvent(GtkWidget* aWidget,
   //
   // This may be fixed in Gtk 3.24+ but some DE still have this issue
   // (Bug 1624199) so let's remove it for Wayland only.
+#ifdef MOZ_X11
   if (mIsX11Display) {
     if (!mIsShown) {
       aEvent->changed_mask = static_cast<GdkWindowState>(
@@ -3927,6 +3965,7 @@ void nsWindow::OnWindowStateEvent(GtkWidget* aWidget,
           aEvent->changed_mask | GDK_WINDOW_STATE_MAXIMIZED);
     }
   }
+#endif
 
   // This is a workaround for https://gitlab.gnome.org/GNOME/gtk/issues/1395
   // Gtk+ controls window active appearance by window-state-event signal.
@@ -4244,6 +4283,7 @@ static GdkWindow* CreateGdkWindow(GdkWindow* parent, GtkWidget* widget) {
   return window;
 }
 
+#ifdef MOZ_X11
 // Configure GL visual on X11. We add alpha silently
 // if we use WebRender to workaround NVIDIA specific Bug 1663273.
 bool nsWindow::ConfigureX11GLVisual(bool aUseAlpha) {
@@ -4295,6 +4335,7 @@ bool nsWindow::ConfigureX11GLVisual(bool aUseAlpha) {
 
   return true;
 }
+#endif
 
 nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
                           const LayoutDeviceIntRect& aRect,
@@ -4839,8 +4880,13 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
        mWindowType == eWindowType_toplevel ? "Toplevel" : "Popup",
        mIsPIPWindow ? "PIP window" : ""));
   if (mShell) {
+#ifdef MOZ_X11
     LOG(("\tmShell %p mContainer %p mGdkWindow %p 0x%lx\n", mShell, mContainer,
          mGdkWindow, mIsX11Display ? gdk_x11_window_get_xid(mGdkWindow) : 0));
+#else
+    LOG(("\tmShell %p mContainer %p mGdkWindow %p 0x%lx\n", mShell, mContainer,
+         mGdkWindow, 0));
+#endif
   } else if (mContainer) {
     LOG(("\tmContainer %p mGdkWindow %p\n", mContainer, mGdkWindow));
   } else if (mGdkWindow) {
@@ -4874,7 +4920,7 @@ nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
     }
   }
 #  ifdef MOZ_WAYLAND
-  else if (!mIsX11Display) {
+  if (!mIsX11Display) {
     mSurfaceProvider.Initialize(this);
     WaylandStartVsync();
   }
@@ -4992,7 +5038,7 @@ void nsWindow::NativeResize() {
     gdk_window_resize(mGdkWindow, size.width, size.height);
   }
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
   // Notify the GtkCompositorWidget of a ClientSizeChange
   // This is different than OnSizeAllocate to catch initial sizing
   if (mCompositorWidgetDelegate) {
@@ -5052,7 +5098,7 @@ void nsWindow::NativeMoveResize() {
     }
   }
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
   // Notify the GtkCompositorWidget of a ClientSizeChange
   // This is different than OnSizeAllocate to catch initial sizing
   if (mCompositorWidgetDelegate) {
@@ -5612,6 +5658,7 @@ void nsWindow::ApplyTransparencyBitmap() {
                     ShapeSet);
   XFreePixmap(xDisplay, maskPixmap);
 #else
+#  if 0 //Not working
   cairo_surface_t* maskBitmap;
   maskBitmap = cairo_image_surface_create_for_data(
       (unsigned char*)mTransparencyBitmap, CAIRO_FORMAT_A1,
@@ -5623,6 +5670,7 @@ void nsWindow::ApplyTransparencyBitmap() {
   gtk_widget_shape_combine_region(mShell, maskRegion);
   cairo_region_destroy(maskRegion);
   cairo_surface_destroy(maskBitmap);
+#  endif
 #endif  // MOZ_X11
 }
 
@@ -5751,6 +5799,7 @@ void nsWindow::UpdateTitlebarTransparencyBitmap() {
     cairo_surface_destroy(surface);
   }
 
+#ifdef MOZ_X11
   if (!mNeedsShow) {
     Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
     Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
@@ -5773,6 +5822,7 @@ void nsWindow::UpdateTitlebarTransparencyBitmap() {
 
     XFreePixmap(xDisplay, maskPixmap);
   }
+#endif
 }
 
 void nsWindow::GrabPointer(guint32 aTime) {
@@ -5799,6 +5849,7 @@ void nsWindow::GrabPointer(guint32 aTime) {
     return;
   }
 
+#ifdef MOZ_X11
   gint retval;
   // Note that we need GDK_TOUCH_MASK below to work around a GDK/X11 bug that
   // causes touch events that would normally be received by this client on
@@ -5825,6 +5876,7 @@ void nsWindow::GrabPointer(guint32 aTime) {
                           &nsWindow::CheckForRollupDuringGrab);
     NS_DispatchToCurrentThread(event.forget());
   }
+#endif
 }
 
 void nsWindow::ReleaseGrabs(void) {
@@ -5838,7 +5890,9 @@ void nsWindow::ReleaseGrabs(void) {
     return;
   }
 
+#ifdef MOZ_X11
   gdk_pointer_ungrab(GDK_CURRENT_TIME);
+#endif
 }
 
 GtkWidget* nsWindow::GetToplevelWidget() {
@@ -7319,6 +7373,7 @@ bool nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
     return false;
   }
 
+#ifdef MOZ_X11
   if (mIsX11Display) {
     // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
     // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
@@ -7334,6 +7389,7 @@ bool nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
       }
     }
   }
+#endif
 
   // FIXME: It would be nice to have the widget position at the time
   // of the event, but it's relatively unlikely that the widget has
@@ -7537,7 +7593,7 @@ void nsWindow::SetDrawsInTitlebar(bool aState) {
     // can find its way home.
     g_object_set_data(G_OBJECT(gtk_widget_get_window(mShell)), "nsWindow",
                       this);
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
     SetCompositorHint(GTK_WIDGET_COMPOSIDED_ENABLED);
 #endif
     RefreshWindowClass();
@@ -7840,13 +7896,16 @@ nsWindow::CSDSupportLevel nsWindow::GetSystemCSDSupportLevel(bool aIsPopup) {
     return sCSDSupportLevel;
   }
 
+#ifdef MOZ_WAYLAND
   // nsWindow::GetSystemCSDSupportLevel can be called from various threads
   // so we can't use gfxPlatformGtk here.
-  if (!GDK_IS_X11_DISPLAY(gdk_display_get_default())) {
+  if (GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
     sCSDSupportLevel = CSD_SUPPORT_CLIENT;
     return sCSDSupportLevel;
   }
+#endif
 
+#ifdef MOZ_X11
   const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
   if (currentDesktop) {
     // GNOME Flashback (fallback)
@@ -7909,6 +7968,7 @@ nsWindow::CSDSupportLevel nsWindow::GetSystemCSDSupportLevel(bool aIsPopup) {
   }
 
   return sCSDSupportLevel;
+#endif
 }
 
 bool nsWindow::TitlebarUseShapeMask() {
@@ -7961,18 +8021,26 @@ int32_t nsWindow::RoundsWidgetCoordinatesTo() { return GdkScaleFactor(); }
 
 void nsWindow::GetCompositorWidgetInitData(
     mozilla::widget::CompositorWidgetInitData* aInitData) {
+#ifdef MOZ_X11
   // Make sure the window XID is propagated to X server, we can fail otherwise
   // in GPU process (Bug 1401634).
   if (mXDisplay && mXWindow != X11None) {
     XFlush(mXDisplay);
   }
+#endif
 
   bool isShaped =
       mIsTransparent && !mHasAlphaVisual && !mTransparencyBitmapForTitlebar;
+#ifdef MOZ_X11
   *aInitData = mozilla::widget::GtkCompositorWidgetInitData(
       (mXWindow != X11None) ? mXWindow : (uintptr_t) nullptr,
       mXDisplay ? nsCString(XDisplayString(mXDisplay)) : nsCString(), isShaped,
       mIsX11Display, GetClientSize());
+#else
+  *aInitData = mozilla::widget::GtkCompositorWidgetInitData(
+      (uintptr_t) nullptr, nsCString(), isShaped,
+      mIsX11Display, GetClientSize());
+#endif
 }
 
 #ifdef MOZ_WAYLAND
@@ -8033,8 +8101,8 @@ void nsWindow::SetProgress(unsigned long progressPercent) {
 #endif  // MOZ_X11
 }
 
-#ifdef MOZ_X11
 void nsWindow::SetCompositorHint(WindowComposeRequest aState) {
+#ifdef MOZ_X11
   if (!mIsX11Display) {
     return;
   }
@@ -8046,8 +8114,8 @@ void nsWindow::SetCompositorHint(WindowComposeRequest aState) {
                       cardinal_atom,
                       32,  // format
                       GDK_PROP_MODE_REPLACE, (guchar*)&value, 1);
-}
 #endif
+}
 
 nsresult nsWindow::SetSystemFont(const nsCString& aFontName) {
   GtkSettings* settings = gtk_settings_get_default();
diff --git a/widget/gtk/nsWindow.cpp.orig b/widget/gtk/nsWindow.cpp.orig
new file mode 100644
index 0000000000..6b403a4a1c
--- /dev/null
+++ b/widget/gtk/nsWindow.cpp.orig
@@ -0,0 +1,8335 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:expandtab:shiftwidth=2:tabstop=2:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsWindow.h"
+
+#include "mozilla/ArrayUtils.h"
+#include "mozilla/EventForwards.h"
+#include "mozilla/MiscEvents.h"
+#include "mozilla/MouseEvents.h"
+#include "mozilla/PresShell.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/ScopeExit.h"
+#include "mozilla/StaticPrefs_apz.h"
+#include "mozilla/StaticPrefs_ui.h"
+#include "mozilla/TextEvents.h"
+#include "mozilla/TimeStamp.h"
+#include "mozilla/TouchEvents.h"
+#include "mozilla/UniquePtrExtensions.h"
+#include "mozilla/WidgetUtils.h"
+#ifdef MOZ_X11
+#  include "mozilla/X11Util.h"
+#endif
+#include "mozilla/XREAppData.h"
+#include "mozilla/dom/Document.h"
+#include "mozilla/dom/WheelEventBinding.h"
+#include "nsAppRunner.h"
+#include <algorithm>
+
+#include "GeckoProfiler.h"
+
+#include "prlink.h"
+#include "nsGTKToolkit.h"
+#include "nsIRollupListener.h"
+#include "nsINode.h"
+
+#include "nsWidgetsCID.h"
+#include "nsDragService.h"
+#include "nsIWidgetListener.h"
+#include "nsIScreenManager.h"
+#include "SystemTimeConverter.h"
+#include "nsViewManager.h"
+#include "nsMenuPopupFrame.h"
+#include "nsXPLookAndFeel.h"
+
+#include "nsGtkKeyUtils.h"
+#include "nsGtkCursors.h"
+#include "ScreenHelperGTK.h"
+
+#include <gtk/gtk.h>
+
+#ifdef MOZ_WAYLAND
+#  include <gdk/gdkwayland.h>
+#endif /* MOZ_WAYLAND */
+
+#ifdef MOZ_X11
+#  include <gtk/gtkx.h>
+#  include <gdk/gdkx.h>
+#  include <X11/Xatom.h>
+#  include <X11/extensions/XShm.h>
+#  include <X11/extensions/shape.h>
+#  include <gdk/gdkkeysyms-compat.h>
+#endif /* MOZ_X11 */
+
+#include <gdk/gdkkeysyms.h>
+
+#if defined(MOZ_WAYLAND)
+#  include <gdk/gdkwayland.h>
+#  include "nsView.h"
+#endif
+
+#include "nsGkAtoms.h"
+
+#include "mozilla/Assertions.h"
+#include "mozilla/Likely.h"
+#include "mozilla/Preferences.h"
+#include "nsGfxCIID.h"
+#include "nsGtkUtils.h"
+#include "nsLayoutUtils.h"
+#include "mozilla/layers/LayersTypes.h"
+#include "nsIUserIdleServiceInternal.h"
+#include "GLContext.h"
+#include "gfx2DGlue.h"
+
+#ifdef ACCESSIBILITY
+#  include "mozilla/a11y/Accessible.h"
+#  include "mozilla/a11y/Platform.h"
+#  include "nsAccessibilityService.h"
+
+using namespace mozilla;
+using namespace mozilla::widget;
+#endif
+
+/* For SetIcon */
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsString.h"
+#include "nsIFile.h"
+
+/* SetCursor(imgIContainer*) */
+#include <gdk/gdk.h>
+#include <wchar.h>
+#include "imgIContainer.h"
+#include "nsGfxCIID.h"
+#include "nsImageToPixbuf.h"
+#include "nsIInterfaceRequestorUtils.h"
+#include "ClientLayerManager.h"
+#include "nsIGSettingsService.h"
+
+#include "gfxPlatformGtk.h"
+#include "gfxContext.h"
+#include "gfxImageSurface.h"
+#include "gfxUtils.h"
+#include "Layers.h"
+#include "GLContextProvider.h"
+#include "mozilla/gfx/2D.h"
+#include "mozilla/gfx/HelpersCairo.h"
+#include "mozilla/gfx/GPUProcessManager.h"
+#include "mozilla/layers/CompositorBridgeParent.h"
+#include "mozilla/layers/CompositorThread.h"
+#include "mozilla/layers/KnowsCompositor.h"
+#include "mozilla/layers/WebRenderBridgeChild.h"
+#include "mozilla/layers/WebRenderLayerManager.h"
+
+#include "mozilla/layers/APZInputBridge.h"
+#include "mozilla/layers/IAPZCTreeManager.h"
+
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
+#  include "mozilla/gfx/gfxVars.h"
+#  include "GLContextEGL.h"  // for GLContextEGL::FindVisual()
+#  include "GtkCompositorWidget.h"
+#endif
+#ifdef MOZ_X11
+#  include "GLContextGLX.h"  // for GLContextGLX::FindVisual()
+#  include "gfxXlibSurface.h"
+#  include "WindowSurfaceX11Image.h"
+#  include "WindowSurfaceX11SHM.h"
+#  include "WindowSurfaceXRender.h"
+#endif  // MOZ_X11
+#ifdef MOZ_WAYLAND
+#  include "nsIClipboard.h"
+#endif
+
+#include "nsShmImage.h"
+#include "gtkdrawing.h"
+
+#include "NativeKeyBindings.h"
+
+#include <dlfcn.h>
+#include "nsPresContext.h"
+
+using namespace mozilla;
+using namespace mozilla::gfx;
+using namespace mozilla::widget;
+using namespace mozilla::layers;
+using mozilla::gl::GLContextEGL;
+#ifdef MOZ_X11
+using mozilla::gl::GLContextGLX;
+#endif
+
+// Don't put more than this many rects in the dirty region, just fluff
+// out to the bounding-box if there are more
+#define MAX_RECTS_IN_REGION 100
+
+const gint kEvents =
+    GDK_EXPOSURE_MASK | GDK_STRUCTURE_MASK | GDK_VISIBILITY_NOTIFY_MASK |
+    GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK | GDK_BUTTON_PRESS_MASK |
+    GDK_BUTTON_RELEASE_MASK | GDK_SMOOTH_SCROLL_MASK | GDK_TOUCH_MASK |
+    GDK_SCROLL_MASK | GDK_POINTER_MOTION_MASK | GDK_PROPERTY_CHANGE_MASK |
+    GDK_FOCUS_CHANGE_MASK;
+
+#if !GTK_CHECK_VERSION(3, 22, 0)
+typedef enum {
+  GDK_ANCHOR_FLIP_X = 1 << 0,
+  GDK_ANCHOR_FLIP_Y = 1 << 1,
+  GDK_ANCHOR_SLIDE_X = 1 << 2,
+  GDK_ANCHOR_SLIDE_Y = 1 << 3,
+  GDK_ANCHOR_RESIZE_X = 1 << 4,
+  GDK_ANCHOR_RESIZE_Y = 1 << 5,
+  GDK_ANCHOR_FLIP = GDK_ANCHOR_FLIP_X | GDK_ANCHOR_FLIP_Y,
+  GDK_ANCHOR_SLIDE = GDK_ANCHOR_SLIDE_X | GDK_ANCHOR_SLIDE_Y,
+  GDK_ANCHOR_RESIZE = GDK_ANCHOR_RESIZE_X | GDK_ANCHOR_RESIZE_Y
+} GdkAnchorHints;
+#endif
+
+/* utility functions */
+static bool is_mouse_in_window(GdkWindow* aWindow, gdouble aMouseX,
+                               gdouble aMouseY);
+static nsWindow* get_window_for_gtk_widget(GtkWidget* widget);
+static nsWindow* get_window_for_gdk_window(GdkWindow* window);
+static GtkWidget* get_gtk_widget_for_gdk_window(GdkWindow* window);
+static GdkCursor* get_gtk_cursor(nsCursor aCursor);
+
+static GdkWindow* get_inner_gdk_window(GdkWindow* aWindow, gint x, gint y,
+                                       gint* retx, gint* rety);
+
+static int is_parent_ungrab_enter(GdkEventCrossing* aEvent);
+static int is_parent_grab_leave(GdkEventCrossing* aEvent);
+
+/* callbacks from widgets */
+static gboolean expose_event_cb(GtkWidget* widget, cairo_t* rect);
+static gboolean configure_event_cb(GtkWidget* widget, GdkEventConfigure* event);
+static void container_unrealize_cb(GtkWidget* widget);
+static void size_allocate_cb(GtkWidget* widget, GtkAllocation* allocation);
+static void toplevel_window_size_allocate_cb(GtkWidget* widget,
+                                             GtkAllocation* allocation);
+static gboolean delete_event_cb(GtkWidget* widget, GdkEventAny* event);
+static gboolean enter_notify_event_cb(GtkWidget* widget,
+                                      GdkEventCrossing* event);
+static gboolean leave_notify_event_cb(GtkWidget* widget,
+                                      GdkEventCrossing* event);
+static gboolean motion_notify_event_cb(GtkWidget* widget,
+                                       GdkEventMotion* event);
+static gboolean button_press_event_cb(GtkWidget* widget, GdkEventButton* event);
+static gboolean button_release_event_cb(GtkWidget* widget,
+                                        GdkEventButton* event);
+static gboolean focus_in_event_cb(GtkWidget* widget, GdkEventFocus* event);
+static gboolean focus_out_event_cb(GtkWidget* widget, GdkEventFocus* event);
+static gboolean key_press_event_cb(GtkWidget* widget, GdkEventKey* event);
+static gboolean key_release_event_cb(GtkWidget* widget, GdkEventKey* event);
+static gboolean property_notify_event_cb(GtkWidget* widget,
+                                         GdkEventProperty* event);
+static gboolean scroll_event_cb(GtkWidget* widget, GdkEventScroll* event);
+static void hierarchy_changed_cb(GtkWidget* widget,
+                                 GtkWidget* previous_toplevel);
+static gboolean window_state_event_cb(GtkWidget* widget,
+                                      GdkEventWindowState* event);
+static void settings_changed_cb(GtkSettings* settings, GParamSpec* pspec,
+                                nsWindow* data);
+static void settings_xft_dpi_changed_cb(GtkSettings* settings,
+                                        GParamSpec* pspec, nsWindow* data);
+static void check_resize_cb(GtkContainer* container, gpointer user_data);
+static void screen_composited_changed_cb(GdkScreen* screen, gpointer user_data);
+static void widget_composited_changed_cb(GtkWidget* widget, gpointer user_data);
+
+static void scale_changed_cb(GtkWidget* widget, GParamSpec* aPSpec,
+                             gpointer aPointer);
+static gboolean touch_event_cb(GtkWidget* aWidget, GdkEventTouch* aEvent);
+static nsWindow* GetFirstNSWindowForGDKWindow(GdkWindow* aGdkWindow);
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+#ifdef MOZ_X11
+static GdkFilterReturn popup_take_focus_filter(GdkXEvent* gdk_xevent,
+                                               GdkEvent* event, gpointer data);
+#endif /* MOZ_X11 */
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+static gboolean drag_motion_event_cb(GtkWidget* aWidget,
+                                     GdkDragContext* aDragContext, gint aX,
+                                     gint aY, guint aTime, gpointer aData);
+static void drag_leave_event_cb(GtkWidget* aWidget,
+                                GdkDragContext* aDragContext, guint aTime,
+                                gpointer aData);
+static gboolean drag_drop_event_cb(GtkWidget* aWidget,
+                                   GdkDragContext* aDragContext, gint aX,
+                                   gint aY, guint aTime, gpointer aData);
+static void drag_data_received_event_cb(GtkWidget* aWidget,
+                                        GdkDragContext* aDragContext, gint aX,
+                                        gint aY,
+                                        GtkSelectionData* aSelectionData,
+                                        guint aInfo, guint32 aTime,
+                                        gpointer aData);
+
+/* initialization static functions */
+static nsresult initialize_prefs(void);
+
+static guint32 sLastUserInputTime = GDK_CURRENT_TIME;
+static guint32 sRetryGrabTime;
+
+static SystemTimeConverter<guint32>& TimeConverter() {
+  static SystemTimeConverter<guint32> sTimeConverterSingleton;
+  return sTimeConverterSingleton;
+}
+
+nsWindow::CSDSupportLevel nsWindow::sCSDSupportLevel = CSD_SUPPORT_UNKNOWN;
+bool nsWindow::sTransparentMainWindow = false;
+
+namespace mozilla {
+
+#ifdef MOZ_X11
+class CurrentX11TimeGetter {
+ public:
+  explicit CurrentX11TimeGetter(GdkWindow* aWindow)
+      : mWindow(aWindow), mAsyncUpdateStart() {}
+
+  guint32 GetCurrentTime() const { return gdk_x11_get_server_time(mWindow); }
+
+  void GetTimeAsyncForPossibleBackwardsSkew(const TimeStamp& aNow) {
+    // Check for in-flight request
+    if (!mAsyncUpdateStart.IsNull()) {
+      return;
+    }
+    mAsyncUpdateStart = aNow;
+
+    Display* xDisplay = GDK_WINDOW_XDISPLAY(mWindow);
+    Window xWindow = GDK_WINDOW_XID(mWindow);
+    unsigned char c = 'a';
+    Atom timeStampPropAtom = TimeStampPropAtom();
+    XChangeProperty(xDisplay, xWindow, timeStampPropAtom, timeStampPropAtom, 8,
+                    PropModeReplace, &c, 1);
+    XFlush(xDisplay);
+  }
+
+  gboolean PropertyNotifyHandler(GtkWidget* aWidget, GdkEventProperty* aEvent) {
+    if (aEvent->atom != gdk_x11_xatom_to_atom(TimeStampPropAtom())) {
+      return FALSE;
+    }
+
+    guint32 eventTime = aEvent->time;
+    TimeStamp lowerBound = mAsyncUpdateStart;
+
+    TimeConverter().CompensateForBackwardsSkew(eventTime, lowerBound);
+    mAsyncUpdateStart = TimeStamp();
+    return TRUE;
+  }
+
+ private:
+  static Atom TimeStampPropAtom() {
+    return gdk_x11_get_xatom_by_name_for_display(gdk_display_get_default(),
+                                                 "GDK_TIMESTAMP_PROP");
+  }
+
+  // This is safe because this class is stored as a member of mWindow and
+  // won't outlive it.
+  GdkWindow* mWindow;
+  TimeStamp mAsyncUpdateStart;
+};
+#endif
+
+}  // namespace mozilla
+
+static NS_DEFINE_IID(kCDragServiceCID, NS_DRAGSERVICE_CID);
+
+// The window from which the focus manager asks us to dispatch key events.
+static nsWindow* gFocusWindow = nullptr;
+static bool gBlockActivateEvent = false;
+static bool gGlobalsInitialized = false;
+static bool gRaiseWindows = true;
+static bool gUseWaylandVsync = true;
+static bool gUseWaylandUseOpaqueRegion = true;
+static bool gUseAspectRatio = true;
+static GList* gVisibleWaylandPopupWindows = nullptr;
+static uint32_t gLastTouchID = 0;
+
+#define NS_WINDOW_TITLE_MAX_LENGTH 4095
+
+// If after selecting profile window, the startup fail, please refer to
+// http://bugzilla.gnome.org/show_bug.cgi?id=88940
+
+// needed for imgIContainer cursors
+// GdkDisplay* was added in 2.2
+typedef struct _GdkDisplay GdkDisplay;
+
+#define kWindowPositionSlop 20
+
+// cursor cache
+static GdkCursor* gCursorCache[eCursorCount];
+
+static GtkWidget* gInvisibleContainer = nullptr;
+
+// Sometimes this actually also includes the state of the modifier keys, but
+// only the button state bits are used.
+static guint gButtonState;
+
+static inline int32_t GetBitmapStride(int32_t width) {
+#if defined(MOZ_X11)
+  return (width + 7) / 8;
+#else
+  return cairo_format_stride_for_width(CAIRO_FORMAT_A1, width);
+#endif
+}
+
+static inline bool TimestampIsNewerThan(guint32 a, guint32 b) {
+  // Timestamps are just the least significant bits of a monotonically
+  // increasing function, and so the use of unsigned overflow arithmetic.
+  return a - b <= G_MAXUINT32 / 2;
+}
+
+static void UpdateLastInputEventTime(void* aGdkEvent) {
+  nsCOMPtr<nsIUserIdleServiceInternal> idleService =
+      do_GetService("@mozilla.org/widget/useridleservice;1");
+  if (idleService) {
+    idleService->ResetIdleTimeOut(0);
+  }
+
+  guint timestamp = gdk_event_get_time(static_cast<GdkEvent*>(aGdkEvent));
+  if (timestamp == GDK_CURRENT_TIME) return;
+
+  sLastUserInputTime = timestamp;
+}
+
+void GetWindowOrigin(GdkWindow* aWindow, int* aX, int* aY) {
+  if (aWindow) {
+    gdk_window_get_origin(aWindow, aX, aY);
+  }
+
+  // TODO(bug 1655924): gdk_window_get_origin is can block waiting for the x
+  // server for a long time, we would like to use the implementation below
+  // instead. However, removing the synchronous x server queries causes a race
+  // condition to surface, causing issues such as bug 1652743 and bug 1653711.
+#if 0
+  *aX = 0;
+  *aY = 0;
+  if (!aWindow) {
+    return;
+  }
+
+  GdkWindow* current = aWindow;
+  while (GdkWindow* parent = gdk_window_get_parent(current)) {
+    if (parent == current) {
+      break;
+    }
+
+    int x = 0;
+    int y = 0;
+    gdk_window_get_position(current, &x, &y);
+    *aX += x;
+    *aY += y;
+
+    current = parent;
+  }
+#endif
+}
+
+nsWindow::nsWindow() {
+  mIsTopLevel = false;
+  mIsDestroyed = false;
+  mListenForResizes = false;
+  mNeedsDispatchResized = false;
+  mIsShown = false;
+  mNeedsShow = false;
+  mEnabled = true;
+  mCreated = false;
+  mHandleTouchEvent = false;
+  mIsDragPopup = false;
+  mIsX11Display = gfxPlatformGtk::GetPlatform()->IsX11Display();
+
+  mContainer = nullptr;
+  mGdkWindow = nullptr;
+  mShell = nullptr;
+  mCompositorWidgetDelegate = nullptr;
+  mHasMappedToplevel = false;
+  mRetryPointerGrab = false;
+  mWindowType = eWindowType_child;
+  mSizeState = nsSizeMode_Normal;
+  mBoundsAreValid = true;
+  mAspectRatio = 0.0f;
+  mAspectRatioSaved = 0.0f;
+  mLastSizeMode = nsSizeMode_Normal;
+  mSizeConstraints.mMaxSize = GetSafeWindowSize(mSizeConstraints.mMaxSize);
+
+#ifdef MOZ_X11
+  mOldFocusWindow = 0;
+
+  mXDisplay = nullptr;
+  mXWindow = X11None;
+  mXVisual = nullptr;
+  mXDepth = 0;
+#endif /* MOZ_X11 */
+
+#ifdef MOZ_WAYLAND
+  mNeedsCompositorResume = false;
+  mCompositorInitiallyPaused = false;
+#endif
+  mWaitingForMoveToRectCB = false;
+  mPendingSizeRect = LayoutDeviceIntRect(0, 0, 0, 0);
+
+  if (!gGlobalsInitialized) {
+    gGlobalsInitialized = true;
+
+    // It's OK if either of these fail, but it may not be one day.
+    initialize_prefs();
+
+#ifdef MOZ_WAYLAND
+    // Wayland provides clipboard data to application on focus-in event
+    // so we need to init our clipboard hooks before we create window
+    // and get focus.
+    if (!mIsX11Display) {
+      nsCOMPtr<nsIClipboard> clipboard =
+          do_GetService("@mozilla.org/widget/clipboard;1");
+      NS_ASSERTION(clipboard, "Failed to init clipboard!");
+    }
+#endif
+  }
+
+  mLastMotionPressure = 0;
+
+#ifdef ACCESSIBILITY
+  mRootAccessible = nullptr;
+#endif
+
+  mIsTransparent = false;
+  mTransparencyBitmap = nullptr;
+  mTransparencyBitmapForTitlebar = false;
+
+  mTransparencyBitmapWidth = 0;
+  mTransparencyBitmapHeight = 0;
+
+  mLastScrollEventTime = GDK_CURRENT_TIME;
+
+  mPendingConfigures = 0;
+  mCSDSupportLevel = CSD_SUPPORT_NONE;
+  mDrawToContainer = false;
+  mDrawInTitlebar = false;
+  mTitlebarBackdropState = false;
+
+  mHasAlphaVisual = false;
+  mIsPIPWindow = false;
+  mAlwaysOnTop = false;
+
+  mWindowScaleFactorChanged = true;
+  mWindowScaleFactor = 1;
+
+  mCompositedScreen = gdk_screen_is_composited(gdk_screen_get_default());
+}
+
+nsWindow::~nsWindow() {
+  LOG(("nsWindow::~nsWindow() [%p]\n", (void*)this));
+
+  delete[] mTransparencyBitmap;
+  mTransparencyBitmap = nullptr;
+
+  Destroy();
+}
+
+/* static */
+void nsWindow::ReleaseGlobals() {
+  for (auto& cursor : gCursorCache) {
+    if (cursor) {
+      g_object_unref(cursor);
+      cursor = nullptr;
+    }
+  }
+}
+
+void nsWindow::CommonCreate(nsIWidget* aParent, bool aListenForResizes) {
+  mParent = aParent;
+  mListenForResizes = aListenForResizes;
+  mCreated = true;
+}
+
+void nsWindow::DispatchActivateEvent(void) {
+  NS_ASSERTION(mContainer || mIsDestroyed,
+               "DispatchActivateEvent only intended for container windows");
+
+#ifdef ACCESSIBILITY
+  DispatchActivateEventAccessible();
+#endif  // ACCESSIBILITY
+
+  if (mWidgetListener) mWidgetListener->WindowActivated();
+}
+
+void nsWindow::DispatchDeactivateEvent(void) {
+  if (mWidgetListener) mWidgetListener->WindowDeactivated();
+
+#ifdef ACCESSIBILITY
+  DispatchDeactivateEventAccessible();
+#endif  // ACCESSIBILITY
+}
+
+void nsWindow::DispatchResized() {
+  mNeedsDispatchResized = false;
+  if (mWidgetListener) {
+    mWidgetListener->WindowResized(this, mBounds.width, mBounds.height);
+  }
+  if (mAttachedWidgetListener) {
+    mAttachedWidgetListener->WindowResized(this, mBounds.width, mBounds.height);
+  }
+}
+
+void nsWindow::MaybeDispatchResized() {
+  if (mNeedsDispatchResized && !mIsDestroyed) {
+    DispatchResized();
+  }
+}
+
+nsIWidgetListener* nsWindow::GetListener() {
+  return mAttachedWidgetListener ? mAttachedWidgetListener : mWidgetListener;
+}
+
+nsresult nsWindow::DispatchEvent(WidgetGUIEvent* aEvent,
+                                 nsEventStatus& aStatus) {
+#ifdef DEBUG
+  debug_DumpEvent(stdout, aEvent->mWidget, aEvent, "something", 0);
+#endif
+  aStatus = nsEventStatus_eIgnore;
+  nsIWidgetListener* listener = GetListener();
+  if (listener) {
+    aStatus = listener->HandleEvent(aEvent, mUseAttachedEvents);
+  }
+
+  return NS_OK;
+}
+
+void nsWindow::OnDestroy(void) {
+  if (mOnDestroyCalled) return;
+
+  mOnDestroyCalled = true;
+
+  // Prevent deletion.
+  nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
+
+  // release references to children, device context, toolkit + app shell
+  nsBaseWidget::OnDestroy();
+
+  // Remove association between this object and its parent and siblings.
+  nsBaseWidget::Destroy();
+  mParent = nullptr;
+
+  NotifyWindowDestroyed();
+}
+
+bool nsWindow::AreBoundsSane() {
+  return mBounds.width > 0 && mBounds.height > 0;
+}
+
+static GtkWidget* EnsureInvisibleContainer() {
+  if (!gInvisibleContainer) {
+    // GtkWidgets need to be anchored to a GtkWindow to be realized (to
+    // have a window).  Using GTK_WINDOW_POPUP rather than
+    // GTK_WINDOW_TOPLEVEL in the hope that POPUP results in less
+    // initialization and window manager interaction.
+    GtkWidget* window = gtk_window_new(GTK_WINDOW_POPUP);
+    gInvisibleContainer = moz_container_new();
+    gtk_container_add(GTK_CONTAINER(window), gInvisibleContainer);
+    gtk_widget_realize(gInvisibleContainer);
+  }
+  return gInvisibleContainer;
+}
+
+static void CheckDestroyInvisibleContainer() {
+  MOZ_ASSERT(gInvisibleContainer, "oh, no");
+
+  if (!gdk_window_peek_children(gtk_widget_get_window(gInvisibleContainer))) {
+    // No children, so not in use.
+    // Make sure to destroy the GtkWindow also.
+    gtk_widget_destroy(gtk_widget_get_parent(gInvisibleContainer));
+    gInvisibleContainer = nullptr;
+  }
+}
+
+// Change the containing GtkWidget on a sub-hierarchy of GdkWindows belonging
+// to aOldWidget and rooted at aWindow, and reparent any child GtkWidgets of
+// the GdkWindow hierarchy to aNewWidget.
+static void SetWidgetForHierarchy(GdkWindow* aWindow, GtkWidget* aOldWidget,
+                                  GtkWidget* aNewWidget) {
+  gpointer data;
+  gdk_window_get_user_data(aWindow, &data);
+
+  if (data != aOldWidget) {
+    if (!GTK_IS_WIDGET(data)) return;
+
+    auto* widget = static_cast<GtkWidget*>(data);
+    if (gtk_widget_get_parent(widget) != aOldWidget) return;
+
+    // This window belongs to a child widget, which will no longer be a
+    // child of aOldWidget.
+    gtk_widget_reparent(widget, aNewWidget);
+
+    return;
+  }
+
+  GList* children = gdk_window_get_children(aWindow);
+  for (GList* list = children; list; list = list->next) {
+    SetWidgetForHierarchy(GDK_WINDOW(list->data), aOldWidget, aNewWidget);
+  }
+  g_list_free(children);
+
+  gdk_window_set_user_data(aWindow, aNewWidget);
+}
+
+// Walk the list of child windows and call destroy on them.
+void nsWindow::DestroyChildWindows() {
+  if (!mGdkWindow) return;
+
+  while (GList* children = gdk_window_peek_children(mGdkWindow)) {
+    GdkWindow* child = GDK_WINDOW(children->data);
+    nsWindow* kid = get_window_for_gdk_window(child);
+    if (kid) {
+      kid->Destroy();
+    } else {
+      // This child is not an nsWindow.
+      // Destroy the child GtkWidget.
+      gpointer data;
+      gdk_window_get_user_data(child, &data);
+      if (GTK_IS_WIDGET(data)) {
+        gtk_widget_destroy(static_cast<GtkWidget*>(data));
+      }
+    }
+  }
+}
+
+void nsWindow::Destroy() {
+  if (mIsDestroyed || !mCreated) return;
+
+  LOG(("nsWindow::Destroy [%p]\n", (void*)this));
+  mIsDestroyed = true;
+  mCreated = false;
+
+  /** Need to clean our LayerManager up while still alive */
+  if (mLayerManager) {
+    mLayerManager->Destroy();
+  }
+  mLayerManager = nullptr;
+
+#ifdef MOZ_WAYLAND
+  // Shut down our local vsync source
+  if (mWaylandVsyncSource) {
+    mWaylandVsyncSource->Shutdown();
+    mWaylandVsyncSource = nullptr;
+  }
+#endif
+
+  // It is safe to call DestroyeCompositor several times (here and
+  // in the parent class) since it will take effect only once.
+  // The reason we call it here is because on gtk platforms we need
+  // to destroy the compositor before we destroy the gdk window (which
+  // destroys the the gl context attached to it).
+  DestroyCompositor();
+
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
+  // Ensure any resources assigned to the window get cleaned up first
+  // to avoid double-freeing.
+  mSurfaceProvider.CleanupResources();
+#endif
+
+  ClearCachedResources();
+
+  g_signal_handlers_disconnect_by_data(gtk_settings_get_default(), this);
+
+  nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
+  if (rollupListener) {
+    nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
+    if (static_cast<nsIWidget*>(this) == rollupWidget) {
+      rollupListener->Rollup(0, false, nullptr, nullptr);
+    }
+  }
+
+  // dragService will be null after shutdown of the service manager.
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  if (dragService && this == dragService->GetMostRecentDestWindow()) {
+    dragService->ScheduleLeaveEvent();
+  }
+
+  NativeShow(false);
+
+  if (mIMContext) {
+    mIMContext->OnDestroyWindow(this);
+  }
+
+  // make sure that we remove ourself as the focus window
+  if (gFocusWindow == this) {
+    LOGFOCUS(("automatically losing focus...\n"));
+    gFocusWindow = nullptr;
+  }
+
+  GtkWidget* owningWidget = GetMozContainerWidget();
+  if (mShell) {
+    gtk_widget_destroy(mShell);
+    mShell = nullptr;
+    mContainer = nullptr;
+    MOZ_ASSERT(!mGdkWindow,
+               "mGdkWindow should be NULL when mContainer is destroyed");
+  } else if (mContainer) {
+    gtk_widget_destroy(GTK_WIDGET(mContainer));
+    mContainer = nullptr;
+    MOZ_ASSERT(!mGdkWindow,
+               "mGdkWindow should be NULL when mContainer is destroyed");
+  } else if (mGdkWindow) {
+    // Destroy child windows to ensure that their mThebesSurfaces are
+    // released and to remove references from GdkWindows back to their
+    // container widget.  (OnContainerUnrealize() does this when the
+    // MozContainer widget is destroyed.)
+    DestroyChildWindows();
+
+    gdk_window_set_user_data(mGdkWindow, nullptr);
+    g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", nullptr);
+    gdk_window_destroy(mGdkWindow);
+    mGdkWindow = nullptr;
+  }
+
+  if (gInvisibleContainer && owningWidget == gInvisibleContainer) {
+    CheckDestroyInvisibleContainer();
+  }
+
+#ifdef ACCESSIBILITY
+  if (mRootAccessible) {
+    mRootAccessible = nullptr;
+  }
+#endif
+
+  // Save until last because OnDestroy() may cause us to be deleted.
+  OnDestroy();
+}
+
+nsIWidget* nsWindow::GetParent(void) { return mParent; }
+
+float nsWindow::GetDPI() {
+  float dpi = 96.0f;
+  nsCOMPtr<nsIScreen> screen = GetWidgetScreen();
+  if (screen) {
+    screen->GetDpi(&dpi);
+  }
+  return dpi;
+}
+
+double nsWindow::GetDefaultScaleInternal() {
+  return GdkScaleFactor() * gfxPlatformGtk::GetFontScaleFactor();
+}
+
+DesktopToLayoutDeviceScale nsWindow::GetDesktopToDeviceScale() {
+#ifdef MOZ_WAYLAND
+  if (!mIsX11Display) {
+    return DesktopToLayoutDeviceScale(GdkScaleFactor());
+  }
+#endif
+
+  // In Gtk/X11, we manage windows using device pixels.
+  return DesktopToLayoutDeviceScale(1.0);
+}
+
+DesktopToLayoutDeviceScale nsWindow::GetDesktopToDeviceScaleByScreen() {
+#ifdef MOZ_WAYLAND
+  // In Wayland there's no way to get absolute position of the window and use it
+  // to determine the screen factor of the monitor on which the window is
+  // placed. The window is notified of the current scale factor but not at this
+  // point, so the GdkScaleFactor can return wrong value which can lead to wrong
+  // popup placement. We need to use parent's window scale factor for the new
+  // one.
+  if (!mIsX11Display) {
+    nsView* view = nsView::GetViewFor(this);
+    if (view) {
+      nsView* parentView = view->GetParent();
+      if (parentView) {
+        nsIWidget* parentWidget = parentView->GetNearestWidget(nullptr);
+        if (parentWidget) {
+          return DesktopToLayoutDeviceScale(
+              parentWidget->RoundsWidgetCoordinatesTo());
+        }
+        NS_WARNING("Widget has no parent");
+      }
+    } else {
+      NS_WARNING("Cannot find widget view");
+    }
+  }
+#endif
+  return nsBaseWidget::GetDesktopToDeviceScale();
+}
+
+void nsWindow::SetParent(nsIWidget* aNewParent) {
+  if (!mGdkWindow) {
+    MOZ_ASSERT_UNREACHABLE("The native window has already been destroyed");
+    return;
+  }
+
+  if (mContainer) {
+    // FIXME bug 1469183
+    NS_ERROR("nsWindow should not have a container here");
+    return;
+  }
+
+  nsCOMPtr<nsIWidget> kungFuDeathGrip = this;
+  if (mParent) {
+    mParent->RemoveChild(this);
+  }
+  mParent = aNewParent;
+
+  GtkWidget* oldContainer = GetMozContainerWidget();
+  if (!oldContainer) {
+    // The GdkWindows have been destroyed so there is nothing else to
+    // reparent.
+    MOZ_ASSERT(gdk_window_is_destroyed(mGdkWindow),
+               "live GdkWindow with no widget");
+    return;
+  }
+
+  nsWindow* newParent = static_cast<nsWindow*>(aNewParent);
+  GdkWindow* newParentWindow = nullptr;
+  GtkWidget* newContainer = nullptr;
+  if (aNewParent) {
+    aNewParent->AddChild(this);
+    newParentWindow = newParent->mGdkWindow;
+    newContainer = newParent->GetMozContainerWidget();
+  } else {
+    // aNewParent is nullptr, but reparent to a hidden window to avoid
+    // destroying the GdkWindow and its descendants.
+    // An invisible container widget is needed to hold descendant
+    // GtkWidgets.
+    newContainer = EnsureInvisibleContainer();
+    newParentWindow = gtk_widget_get_window(newContainer);
+  }
+
+  if (!newContainer) {
+    // The new parent GdkWindow has been destroyed.
+    MOZ_ASSERT(!newParentWindow || gdk_window_is_destroyed(newParentWindow),
+               "live GdkWindow with no widget");
+    Destroy();
+  } else {
+    if (newContainer != oldContainer) {
+      MOZ_ASSERT(!gdk_window_is_destroyed(newParentWindow),
+                 "destroyed GdkWindow with widget");
+      SetWidgetForHierarchy(mGdkWindow, oldContainer, newContainer);
+
+      if (oldContainer == gInvisibleContainer) {
+        CheckDestroyInvisibleContainer();
+      }
+    }
+
+    gdk_window_reparent(mGdkWindow, newParentWindow,
+                        DevicePixelsToGdkCoordRoundDown(mBounds.x),
+                        DevicePixelsToGdkCoordRoundDown(mBounds.y));
+  }
+
+  bool parentHasMappedToplevel = newParent && newParent->mHasMappedToplevel;
+  if (mHasMappedToplevel != parentHasMappedToplevel) {
+    SetHasMappedToplevel(parentHasMappedToplevel);
+  }
+}
+
+bool nsWindow::WidgetTypeSupportsAcceleration() {
+  if (IsSmallPopup()) {
+    return false;
+  }
+  // Workaround for Bug 1479135
+  // We draw transparent popups on non-compositing screens by SW as we don't
+  // implement X shape masks in WebRender.
+  if (mWindowType == eWindowType_popup) {
+    return mCompositedScreen;
+  }
+  return true;
+}
+
+void nsWindow::ReparentNativeWidget(nsIWidget* aNewParent) {
+  MOZ_ASSERT(aNewParent, "null widget");
+  MOZ_ASSERT(!mIsDestroyed, "");
+  MOZ_ASSERT(!static_cast<nsWindow*>(aNewParent)->mIsDestroyed, "");
+  MOZ_ASSERT(!gdk_window_is_destroyed(mGdkWindow),
+             "destroyed GdkWindow with widget");
+
+  MOZ_ASSERT(
+      !mParent,
+      "nsWindow::ReparentNativeWidget() works on toplevel windows only.");
+
+  auto* newParent = static_cast<nsWindow*>(aNewParent);
+  GtkWindow* newParentWidget = GTK_WINDOW(newParent->GetGtkWidget());
+  GtkWindow* shell = GTK_WINDOW(mShell);
+
+  if (shell && gtk_window_get_transient_for(shell)) {
+    gtk_window_set_transient_for(shell, newParentWidget);
+  }
+}
+
+void nsWindow::SetModal(bool aModal) {
+  LOG(("nsWindow::SetModal [%p] %d\n", (void*)this, aModal));
+  if (mIsDestroyed) return;
+  if (!mIsTopLevel || !mShell) return;
+  gtk_window_set_modal(GTK_WINDOW(mShell), aModal ? TRUE : FALSE);
+}
+
+// nsIWidget method, which means IsShown.
+bool nsWindow::IsVisible() const { return mIsShown; }
+
+void nsWindow::RegisterTouchWindow() {
+  mHandleTouchEvent = true;
+  mTouches.Clear();
+}
+
+void nsWindow::ConstrainPosition(bool aAllowSlop, int32_t* aX, int32_t* aY) {
+  if (!mIsTopLevel || !mShell) return;
+
+  double dpiScale = GetDefaultScale().scale;
+
+  // we need to use the window size in logical screen pixels
+  int32_t logWidth = std::max(NSToIntRound(mBounds.width / dpiScale), 1);
+  int32_t logHeight = std::max(NSToIntRound(mBounds.height / dpiScale), 1);
+
+  /* get our playing field. use the current screen, or failing that
+    for any reason, use device caps for the default screen. */
+  nsCOMPtr<nsIScreen> screen;
+  nsCOMPtr<nsIScreenManager> screenmgr =
+      do_GetService("@mozilla.org/gfx/screenmanager;1");
+  if (screenmgr) {
+    screenmgr->ScreenForRect(*aX, *aY, logWidth, logHeight,
+                             getter_AddRefs(screen));
+  }
+
+  // We don't have any screen so leave the coordinates as is
+  if (!screen) return;
+
+  nsIntRect screenRect;
+  if (mSizeMode != nsSizeMode_Fullscreen) {
+    // For normalized windows, use the desktop work area.
+    screen->GetAvailRectDisplayPix(&screenRect.x, &screenRect.y,
+                                   &screenRect.width, &screenRect.height);
+  } else {
+    // For full screen windows, use the desktop.
+    screen->GetRectDisplayPix(&screenRect.x, &screenRect.y, &screenRect.width,
+                              &screenRect.height);
+  }
+
+  if (aAllowSlop) {
+    if (*aX < screenRect.x - logWidth + kWindowPositionSlop)
+      *aX = screenRect.x - logWidth + kWindowPositionSlop;
+    else if (*aX >= screenRect.XMost() - kWindowPositionSlop)
+      *aX = screenRect.XMost() - kWindowPositionSlop;
+
+    if (*aY < screenRect.y - logHeight + kWindowPositionSlop)
+      *aY = screenRect.y - logHeight + kWindowPositionSlop;
+    else if (*aY >= screenRect.YMost() - kWindowPositionSlop)
+      *aY = screenRect.YMost() - kWindowPositionSlop;
+  } else {
+    if (*aX < screenRect.x)
+      *aX = screenRect.x;
+    else if (*aX >= screenRect.XMost() - logWidth)
+      *aX = screenRect.XMost() - logWidth;
+
+    if (*aY < screenRect.y)
+      *aY = screenRect.y;
+    else if (*aY >= screenRect.YMost() - logHeight)
+      *aY = screenRect.YMost() - logHeight;
+  }
+}
+
+void nsWindow::SetSizeConstraints(const SizeConstraints& aConstraints) {
+  mSizeConstraints.mMinSize = GetSafeWindowSize(aConstraints.mMinSize);
+  mSizeConstraints.mMaxSize = GetSafeWindowSize(aConstraints.mMaxSize);
+
+  ApplySizeConstraints();
+}
+
+void nsWindow::AddCSDDecorationSize(int* aWidth, int* aHeight) {
+  if (mCSDSupportLevel == CSD_SUPPORT_CLIENT && mDrawInTitlebar) {
+    GtkBorder decorationSize = GetCSDDecorationSize(!mIsTopLevel);
+    *aWidth += decorationSize.left + decorationSize.right;
+    *aHeight += decorationSize.top + decorationSize.bottom;
+  }
+}
+
+void nsWindow::ApplySizeConstraints(void) {
+  if (mShell) {
+    GdkGeometry geometry;
+    geometry.min_width =
+        DevicePixelsToGdkCoordRoundUp(mSizeConstraints.mMinSize.width);
+    geometry.min_height =
+        DevicePixelsToGdkCoordRoundUp(mSizeConstraints.mMinSize.height);
+    geometry.max_width =
+        DevicePixelsToGdkCoordRoundDown(mSizeConstraints.mMaxSize.width);
+    geometry.max_height =
+        DevicePixelsToGdkCoordRoundDown(mSizeConstraints.mMaxSize.height);
+
+    uint32_t hints = 0;
+    if (mSizeConstraints.mMinSize != LayoutDeviceIntSize(0, 0)) {
+      AddCSDDecorationSize(&geometry.min_width, &geometry.min_height);
+      hints |= GDK_HINT_MIN_SIZE;
+      LOG(("nsWindow::ApplySizeConstraints [%p] min size %d %d\n", (void*)this,
+           geometry.min_width, geometry.min_height));
+    }
+    if (mSizeConstraints.mMaxSize !=
+        LayoutDeviceIntSize(NS_MAXSIZE, NS_MAXSIZE)) {
+      AddCSDDecorationSize(&geometry.max_width, &geometry.max_height);
+      hints |= GDK_HINT_MAX_SIZE;
+      LOG(("nsWindow::ApplySizeConstraints [%p] max size %d %d\n", (void*)this,
+           geometry.max_width, geometry.max_height));
+    }
+
+    if (mAspectRatio != 0.0f) {
+      geometry.min_aspect = mAspectRatio;
+      geometry.max_aspect = mAspectRatio;
+      hints |= GDK_HINT_ASPECT;
+    }
+
+    gtk_window_set_geometry_hints(GTK_WINDOW(mShell), nullptr, &geometry,
+                                  GdkWindowHints(hints));
+  }
+}
+
+void nsWindow::Show(bool aState) {
+  if (aState == mIsShown) return;
+
+  // Clear our cached resources when the window is hidden.
+  if (mIsShown && !aState) {
+    ClearCachedResources();
+  }
+
+  mIsShown = aState;
+
+  LOG(("nsWindow::Show [%p] state %d\n", (void*)this, aState));
+
+  if (aState) {
+    // Now that this window is shown, mHasMappedToplevel needs to be
+    // tracked on viewable descendants.
+    SetHasMappedToplevel(mHasMappedToplevel);
+  }
+
+  // Ok, someone called show on a window that isn't sized to a sane
+  // value.  Mark this window as needing to have Show() called on it
+  // and return.
+  if ((aState && !AreBoundsSane()) || !mCreated) {
+    LOG(("\tbounds are insane or window hasn't been created yet\n"));
+    mNeedsShow = true;
+    return;
+  }
+
+  // If someone is hiding this widget, clear any needing show flag.
+  if (!aState) mNeedsShow = false;
+
+#ifdef ACCESSIBILITY
+  if (aState && a11y::ShouldA11yBeEnabled()) CreateRootAccessible();
+#endif
+
+  NativeShow(aState);
+}
+
+void nsWindow::ResizeInt(int aX, int aY, int aWidth, int aHeight, bool aMove,
+                         bool aRepaint) {
+  LOG(("nsWindow::ResizeInt [%p] x:%d y:%d -> w:%d h:%d repaint %d aMove %d\n",
+       (void*)this, aX, aY, aWidth, aHeight, aRepaint, aMove));
+
+  ConstrainSize(&aWidth, &aHeight);
+
+  LOG(("  ConstrainSize: w:%d h;%d\n", aWidth, aHeight));
+
+  // If we used to have insane bounds, we may have skipped actually positioning
+  // the widget in NativeMoveResizeWaylandPopup, in which case we need to
+  // actually position it now as well.
+  const bool hadInsaneWaylandPopupDimensions =
+      !AreBoundsSane() && IsWaylandPopup();
+
+  if (aMove) {
+    mBounds.x = aX;
+    mBounds.y = aY;
+  }
+
+  // For top-level windows, aWidth and aHeight should possibly be
+  // interpreted as frame bounds, but NativeResize treats these as window
+  // bounds (Bug 581866).
+  mBounds.SizeTo(aWidth, aHeight);
+
+  // We set correct mBounds in advance here. This can be invalided by state
+  // event.
+  mBoundsAreValid = true;
+
+  // Recalculate aspect ratio when resized from DOM
+  if (mAspectRatio != 0.0) {
+    LockAspectRatio(true);
+  }
+
+  if (!mCreated) return;
+
+  if (aMove || mPreferredPopupRectFlushed || hadInsaneWaylandPopupDimensions) {
+    LOG(("  Need also to move, flushed? %d, bounds were insane: %d\n",
+         mPreferredPopupRectFlushed, hadInsaneWaylandPopupDimensions));
+    NativeMoveResize();
+  } else {
+    NativeResize();
+  }
+
+  NotifyRollupGeometryChange();
+
+  // send a resize notification if this is a toplevel
+  if (mIsTopLevel || mListenForResizes) {
+    DispatchResized();
+  }
+}
+
+void nsWindow::Resize(double aWidth, double aHeight, bool aRepaint) {
+  LOG(("nsWindow::Resize [%p] %f %f\n", (void*)this, aWidth, aHeight));
+
+  double scale =
+      BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+  int32_t width = NSToIntRound(scale * aWidth);
+  int32_t height = NSToIntRound(scale * aHeight);
+
+  ResizeInt(0, 0, width, height, /* aMove */ false, aRepaint);
+}
+
+void nsWindow::Resize(double aX, double aY, double aWidth, double aHeight,
+                      bool aRepaint) {
+  LOG(("nsWindow::Resize [%p] %f %f repaint %d\n", (void*)this, aWidth, aHeight,
+       aRepaint));
+
+  double scale =
+      BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+  int32_t width = NSToIntRound(scale * aWidth);
+  int32_t height = NSToIntRound(scale * aHeight);
+
+  int32_t x = NSToIntRound(scale * aX);
+  int32_t y = NSToIntRound(scale * aY);
+
+  ResizeInt(x, y, width, height, /* aMove */ true, aRepaint);
+}
+
+void nsWindow::Enable(bool aState) { mEnabled = aState; }
+
+bool nsWindow::IsEnabled() const { return mEnabled; }
+
+void nsWindow::Move(double aX, double aY) {
+  LOG(("nsWindow::Move [%p] %f %f\n", (void*)this, aX, aY));
+
+  double scale =
+      BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+  int32_t x = NSToIntRound(aX * scale);
+  int32_t y = NSToIntRound(aY * scale);
+
+  if (mWindowType == eWindowType_toplevel ||
+      mWindowType == eWindowType_dialog) {
+    SetSizeMode(nsSizeMode_Normal);
+  }
+
+  // Since a popup window's x/y coordinates are in relation to to
+  // the parent, the parent might have moved so we always move a
+  // popup window.
+  if (x == mBounds.x && y == mBounds.y && mWindowType != eWindowType_popup)
+    return;
+
+  // XXX Should we do some AreBoundsSane check here?
+
+  mBounds.x = x;
+  mBounds.y = y;
+
+  if (!mCreated) return;
+
+  if (IsWaylandPopup()) {
+    int32_t p2a = AppUnitsPerCSSPixel() / gfxPlatformGtk::GetFontScaleFactor();
+    if (mPreferredPopupRect.x != mBounds.x * p2a &&
+        mPreferredPopupRect.y != mBounds.y * p2a) {
+      NativeMove();
+      NotifyRollupGeometryChange();
+    } else {
+      LOG(("  mBounds same as mPreferredPopupRect, no need to move"));
+    }
+  } else {
+    NativeMove();
+    NotifyRollupGeometryChange();
+  }
+}
+
+bool nsWindow::IsWaylandPopup() {
+  return !mIsX11Display && mIsTopLevel && mWindowType == eWindowType_popup;
+}
+
+void nsWindow::HideWaylandTooltips() {
+  while (gVisibleWaylandPopupWindows) {
+    nsWindow* window =
+        static_cast<nsWindow*>(gVisibleWaylandPopupWindows->data);
+    if (window->mPopupType != ePopupTypeTooltip) break;
+    LOG(("nsWindow::HideWaylandTooltips [%p] hidding tooltip [%p].\n",
+         (void*)this, window));
+    window->HideWaylandWindow();
+  }
+}
+
+void nsWindow::HideWaylandOpenedPopups() {
+  while (gVisibleWaylandPopupWindows) {
+    nsWindow* window =
+        static_cast<nsWindow*>(gVisibleWaylandPopupWindows->data);
+    window->HideWaylandWindow();
+  }
+}
+
+// Hide popup nsWindows which are no longer in the nsXULPopupManager widget
+// chain list.
+void nsWindow::CleanupWaylandPopups() {
+  LOG(("nsWindow::CleanupWaylandPopups...\n"));
+  nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
+  AutoTArray<nsIWidget*, 5> widgetChain;
+  pm->GetSubmenuWidgetChain(&widgetChain);
+  GList* popupList = gVisibleWaylandPopupWindows;
+  while (popupList) {
+    LOG(("  Looking for %p [nsWindow]\n", popupList->data));
+    nsWindow* waylandWnd = static_cast<nsWindow*>(popupList->data);
+    // Remove only menu popups or empty frames - they are most likely
+    // already rolledup popups
+    if (waylandWnd->IsMainMenuWindow() || !waylandWnd->GetFrame()) {
+      bool popupFound = false;
+      for (unsigned long i = 0; i < widgetChain.Length(); i++) {
+        if (waylandWnd == widgetChain[i]) {
+          popupFound = true;
+          break;
+        }
+      }
+      if (!popupFound) {
+        LOG(("    nsWindow [%p] not found in PopupManager, hiding it.\n",
+             waylandWnd));
+        waylandWnd->HideWaylandWindow();
+        popupList = gVisibleWaylandPopupWindows;
+      } else {
+        LOG(("    nsWindow [%p] is still open.\n", waylandWnd));
+        popupList = popupList->next;
+      }
+    } else {
+      popupList = popupList->next;
+    }
+  }
+}
+
+static nsMenuPopupFrame* GetMenuPopupFrame(nsIFrame* aFrame) {
+  if (aFrame) {
+    nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(aFrame);
+    return menuPopupFrame;
+  }
+  return nullptr;
+}
+
+// The MenuList popups are used as dropdown menus for example in WebRTC
+// microphone/camera chooser or autocomplete widgets.
+bool nsWindow::IsMainMenuWindow() {
+  nsMenuPopupFrame* menuPopupFrame = GetMenuPopupFrame(GetFrame());
+  if (menuPopupFrame) {
+    LOG(("  nsMenuPopupFrame [%p] type: %d IsMenu: %d, IsMenuList: %d\n",
+         menuPopupFrame, menuPopupFrame->PopupType(), menuPopupFrame->IsMenu(),
+         menuPopupFrame->IsMenuList()));
+    return mPopupType == ePopupTypeMenu && !menuPopupFrame->IsMenuList();
+  }
+  return false;
+}
+
+GtkWindow* nsWindow::GetTopmostWindow() {
+  nsView* view = nsView::GetViewFor(this);
+  if (view) {
+    nsView* parentView = view->GetParent();
+    if (parentView) {
+      nsIWidget* parentWidget = parentView->GetNearestWidget(nullptr);
+      if (parentWidget) {
+        nsWindow* parentnsWindow = static_cast<nsWindow*>(parentWidget);
+        LOG(("  Topmost window: %p [nsWindow]\n", parentnsWindow));
+        return GTK_WINDOW(parentnsWindow->mShell);
+      }
+    }
+  }
+  return nullptr;
+}
+
+GtkWindow* nsWindow::GetCurrentWindow() {
+  GtkWindow* parentGtkWindow = nullptr;
+  // get the last opened window from gVisibleWaylandPopupWindows
+  if (gVisibleWaylandPopupWindows) {
+    nsWindow* parentnsWindow =
+        static_cast<nsWindow*>(gVisibleWaylandPopupWindows->data);
+    if (parentnsWindow) {
+      LOG(("  Setting parent to last opened window: %p [nsWindow]\n",
+           parentnsWindow));
+      parentGtkWindow = GTK_WINDOW(parentnsWindow->GetGtkWidget());
+    }
+  }
+  // get the topmost window if the last opened windows are empty
+  if (!parentGtkWindow) {
+    parentGtkWindow = GetTopmostWindow();
+  }
+  if (parentGtkWindow && GTK_IS_WINDOW(parentGtkWindow)) {
+    return GTK_WINDOW(parentGtkWindow);
+  } else {
+    LOG(("  Failed to get current window for %p: %p\n", this, parentGtkWindow));
+  }
+  return nullptr;
+}
+
+bool nsWindow::IsWidgetOverflowWindow() {
+  if (this->GetFrame() && this->GetFrame()->GetContent()->GetID()) {
+    nsCString nodeId;
+    this->GetFrame()->GetContent()->GetID()->ToUTF8String(nodeId);
+    return nodeId.Equals("widget-overflow");
+  }
+  return false;
+}
+
+// Wayland keeps strong popup window hierarchy. We need to track active
+// (visible) popup windows and make sure we hide popup on the same level
+// before we open another one on that level. It means that every open
+// popup needs to have an unique parent.
+GtkWidget* nsWindow::ConfigureWaylandPopupWindows() {
+  MOZ_ASSERT(this->mWindowType == eWindowType_popup);
+  LOG(
+      ("nsWindow::ConfigureWaylandPopupWindows [%p], frame %p hasRemoteContent "
+       "%d\n",
+       (void*)this, this->GetFrame(), this->HasRemoteContent()));
+#if DEBUG
+  if (this->GetFrame() && this->GetFrame()->GetContent()->GetID()) {
+    nsCString nodeId;
+    this->GetFrame()->GetContent()->GetID()->ToUTF8String(nodeId);
+    LOG(("  [%p] popup node id=%s\n", this, nodeId.get()));
+  }
+#endif
+
+  if (!GetFrame()) {
+    LOG(("  Window without frame cannot be configured.\n"));
+    return nullptr;
+  }
+
+  // Check if we're already configured.
+  if (gVisibleWaylandPopupWindows &&
+      g_list_find(gVisibleWaylandPopupWindows, this)) {
+    LOG(("  [%p] is already configured.\n", (void*)this));
+    return GTK_WIDGET(gtk_window_get_transient_for(GTK_WINDOW(mShell)));
+  }
+
+  // If we're opening a new window we don't want to attach it to a tooltip
+  // as it's short lived temporary window.
+  HideWaylandTooltips();
+
+  // Cleanup already closed menus
+  CleanupWaylandPopups();
+
+  if (gVisibleWaylandPopupWindows &&
+      (HasRemoteContent() || IsWidgetOverflowWindow())) {
+    nsWindow* openedWindow =
+        static_cast<nsWindow*>(gVisibleWaylandPopupWindows->data);
+    LOG(("  this [%p], lastOpenedWindow [%p]", this, openedWindow));
+    if (openedWindow != this) {
+      LOG(
+          ("  Hiding all opened popups because the window is remote content or "
+           "overflow-widget"));
+      HideWaylandOpenedPopups();
+    }
+  }
+
+  GtkWindow* parentGtkWindow = GetCurrentWindow();
+  if (parentGtkWindow) {
+    MOZ_ASSERT(parentGtkWindow != GTK_WINDOW(this->GetGtkWidget()),
+               "Cannot set self as parent");
+    gtk_window_set_transient_for(GTK_WINDOW(mShell),
+                                 GTK_WINDOW(parentGtkWindow));
+    // Add current window to the visible popup list
+    gVisibleWaylandPopupWindows =
+        g_list_prepend(gVisibleWaylandPopupWindows, this);
+    LOG(("  Parent window for %p: %p [GtkWindow]", this, parentGtkWindow));
+  }
+
+  MOZ_ASSERT(parentGtkWindow, "NO parent window for %p: expect popup glitches");
+  return GTK_WIDGET(parentGtkWindow);
+}
+
+static void NativeMoveResizeWaylandPopupCallback(
+    GdkWindow* window, const GdkRectangle* flipped_rect,
+    const GdkRectangle* final_rect, gboolean flipped_x, gboolean flipped_y,
+    void* aWindow) {
+  LOG(("NativeMoveResizeWaylandPopupCallback [%p] flipped_x %d flipped_y %d\n",
+       aWindow, flipped_x, flipped_y));
+
+  LOG(("  flipped_rect x=%d y=%d width=%d height=%d\n", flipped_rect->x,
+       flipped_rect->y, flipped_rect->width, flipped_rect->height));
+  LOG(("  final_rect   x=%d y=%d width=%d height=%d\n", final_rect->x,
+       final_rect->y, final_rect->width, final_rect->height));
+  nsWindow* wnd = get_window_for_gdk_window(window);
+
+  wnd->NativeMoveResizeWaylandPopupCB(final_rect, flipped_x, flipped_y);
+}
+
+void nsWindow::NativeMoveResizeWaylandPopupCB(const GdkRectangle* aFinalSize,
+                                              bool aFlippedX, bool aFlippedY) {
+  LOG(("  orig mBounds x=%d y=%d width=%d height=%d\n", mBounds.x, mBounds.y,
+       mBounds.width, mBounds.height));
+
+  // Remove signal handler because it can also be called from
+  // xdg_popup_configure
+  GdkWindow* gdkWindow = gtk_widget_get_window(GTK_WIDGET(mShell));
+  if (g_signal_handler_find(
+          gdkWindow, G_SIGNAL_MATCH_FUNC, 0, 0, nullptr,
+          FuncToGpointer(NativeMoveResizeWaylandPopupCallback), this)) {
+    LOG(("  Disconnecting NativeMoveResizeWaylandPopupCallback"));
+    g_signal_handlers_disconnect_by_func(
+        gdkWindow, FuncToGpointer(NativeMoveResizeWaylandPopupCallback), this);
+  }
+  mWaitingForMoveToRectCB = false;
+
+  // We ignore the callback position data because the another resize has been
+  // called before the callback have been triggered.
+  if (mPendingSizeRect.height > 0 || mPendingSizeRect.width > 0) {
+    LOG(
+        ("  Another resize called during waiting for callback, calling "
+         "Resize(%d, %d)\n",
+         mPendingSizeRect.width, mPendingSizeRect.height));
+    // Set the preferred size to zero to avoid wrong size of popup because the
+    // mPreferredPopupRect is used in nsMenuPopupFrame to set dimensions
+    mPreferredPopupRect = nsRect(0, 0, 0, 0);
+
+    // We need to schedule another resize because the window has been resized
+    // again before callback was called.
+    Resize(mPendingSizeRect.width, mPendingSizeRect.height, true);
+    DispatchResized();
+    mPendingSizeRect.width = mPendingSizeRect.height = 0;
+    return;
+  }
+
+  GtkWindow* parentGtkWindow = gtk_window_get_transient_for(GTK_WINDOW(mShell));
+  if (!parentGtkWindow || !GTK_IS_WIDGET(parentGtkWindow)) {
+    NS_WARNING("Popup has no parent!");
+    return;
+  }
+
+  // The position of the menu in GTK is relative to it's parent window while
+  // in mBounds we have position relative to toplevel window. We need to check
+  // and update mBounds in the toplevel coordinates.
+  int x_parent, y_parent;
+  GetWindowOrigin(gtk_widget_get_window(GTK_WIDGET(parentGtkWindow)), &x_parent,
+                  &y_parent);
+
+  LayoutDeviceIntRect newBounds(aFinalSize->x, aFinalSize->y, aFinalSize->width,
+                                aFinalSize->height);
+
+  newBounds.x = GdkCoordToDevicePixels(newBounds.x);
+  newBounds.y = GdkCoordToDevicePixels(newBounds.y);
+
+  double scale =
+      BoundsUseDesktopPixels() ? GetDesktopToDeviceScale().scale : 1.0;
+  int32_t newWidth = NSToIntRound(scale * newBounds.width);
+  int32_t newHeight = NSToIntRound(scale * newBounds.height);
+
+  LOG(("  new mBounds  x=%d y=%d width=%d height=%d\n", newBounds.x,
+       newBounds.y, newWidth, newHeight));
+
+  bool needsPositionUpdate =
+      (newBounds.x != mBounds.x || newBounds.y != mBounds.y);
+  bool needsSizeUpdate =
+      (newWidth != mBounds.width || newHeight != mBounds.height);
+  // Update view
+
+  if (needsSizeUpdate) {
+    LOG(("  needSizeUpdate\n"));
+    int32_t p2a = AppUnitsPerCSSPixel() / gfxPlatformGtk::GetFontScaleFactor();
+    mPreferredPopupRect = nsRect(NSIntPixelsToAppUnits(newBounds.x, p2a),
+                                 NSIntPixelsToAppUnits(newBounds.y, p2a),
+                                 NSIntPixelsToAppUnits(newBounds.width, p2a),
+                                 NSIntPixelsToAppUnits(newBounds.height, p2a));
+    mPreferredPopupRectFlushed = false;
+    Resize(newBounds.width, newBounds.height, true);
+    DispatchResized();
+
+    nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+    if (popupFrame) {
+      RefPtr<PresShell> presShell = popupFrame->PresShell();
+      presShell->FrameNeedsReflow(popupFrame, IntrinsicDirty::Resize,
+                                  NS_FRAME_IS_DIRTY);
+    }
+  }
+
+  if (needsPositionUpdate) {
+    LOG(("  needPositionUpdate\n"));
+    // The newBounds are in coordinates relative to the parent window/popup.
+    // The NotifyWindowMoved requires the coordinates relative to the toplevel.
+    // We use the gdk_window_get_origin to get correct coordinates.
+    gint x = 0, y = 0;
+    GetWindowOrigin(gtk_widget_get_window(GTK_WIDGET(mShell)), &x, &y);
+    NotifyWindowMoved(GdkCoordToDevicePixels(x), GdkCoordToDevicePixels(y));
+  }
+}
+
+#ifdef MOZ_WAYLAND
+static GdkGravity PopupAlignmentToGdkGravity(int8_t aAlignment) {
+  switch (aAlignment) {
+    case POPUPALIGNMENT_NONE:
+      return GDK_GRAVITY_NORTH_WEST;
+      break;
+    case POPUPALIGNMENT_TOPLEFT:
+      return GDK_GRAVITY_NORTH_WEST;
+      break;
+    case POPUPALIGNMENT_TOPRIGHT:
+      return GDK_GRAVITY_NORTH_EAST;
+      break;
+    case POPUPALIGNMENT_BOTTOMLEFT:
+      return GDK_GRAVITY_SOUTH_WEST;
+      break;
+    case POPUPALIGNMENT_BOTTOMRIGHT:
+      return GDK_GRAVITY_SOUTH_EAST;
+      break;
+    case POPUPALIGNMENT_LEFTCENTER:
+      return GDK_GRAVITY_WEST;
+      break;
+    case POPUPALIGNMENT_RIGHTCENTER:
+      return GDK_GRAVITY_EAST;
+      break;
+    case POPUPALIGNMENT_TOPCENTER:
+      return GDK_GRAVITY_NORTH;
+      break;
+    case POPUPALIGNMENT_BOTTOMCENTER:
+      return GDK_GRAVITY_SOUTH;
+      break;
+  }
+  return GDK_GRAVITY_STATIC;
+}
+#endif
+
+void nsWindow::NativeMoveResizeWaylandPopup(GdkPoint* aPosition,
+                                            GdkRectangle* aSize) {
+  // Available as of GTK 3.24+
+  static auto sGdkWindowMoveToRect = (void (*)(
+      GdkWindow*, const GdkRectangle*, GdkGravity, GdkGravity, GdkAnchorHints,
+      gint, gint))dlsym(RTLD_DEFAULT, "gdk_window_move_to_rect");
+  LOG(("nsWindow::NativeMoveResizeWaylandPopup [%p]\n", (void*)this));
+
+  // Compositor may be confused by windows with width/height = 0
+  // and positioning such windows leads to Bug 1555866.
+  if (!AreBoundsSane()) {
+    LOG(("  Bounds are not sane (width: %d height: %d)\n", mBounds.width,
+         mBounds.height));
+    return;
+  }
+
+  if (aSize) {
+    gtk_window_resize(GTK_WINDOW(mShell), aSize->width, aSize->height);
+  }
+
+  GdkWindow* gdkWindow = gtk_widget_get_window(GTK_WIDGET(mShell));
+
+  // Use standard gtk_window_move() instead of gdk_window_move_to_rect() when:
+  // - gdk_window_move_to_rect() is not available
+  // - the widget doesn't have a valid GdkWindow
+  if (!sGdkWindowMoveToRect || !gdkWindow) {
+    LOG(("  use gtk_window_move(%d, %d)\n", aPosition->x, aPosition->y));
+    gtk_window_move(GTK_WINDOW(mShell), aPosition->x, aPosition->y);
+    return;
+  }
+
+  GtkWidget* parentWindow = ConfigureWaylandPopupWindows();
+  LOG(("nsWindow::NativeMoveResizeWaylandPopup: Set popup parent %p\n",
+       parentWindow));
+
+  // Get anchor rectangle
+  LayoutDeviceIntRect anchorRect(0, 0, 0, 0);
+  nsMenuPopupFrame* popupFrame = GetMenuPopupFrame(GetFrame());
+
+  int32_t p2a;
+  double devPixelsPerCSSPixel = StaticPrefs::layout_css_devPixelsPerPx();
+  if (devPixelsPerCSSPixel > 0.0) {
+    p2a = AppUnitsPerCSSPixel() / devPixelsPerCSSPixel * GdkScaleFactor();
+  } else {
+    p2a = AppUnitsPerCSSPixel() / gfxPlatformGtk::GetFontScaleFactor();
+  }
+  if (popupFrame) {
+#ifdef MOZ_WAYLAND
+    anchorRect = LayoutDeviceIntRect::FromAppUnitsToOutside(
+        popupFrame->GetAnchorRect(), p2a);
+#endif
+  }
+
+#ifdef MOZ_WAYLAND
+  bool hasAnchorRect = true;
+#endif
+  if (anchorRect.width == 0) {
+    LOG(("  No anchor rect given, use aPosition for anchor"));
+    anchorRect.SetRect(aPosition->x, aPosition->y, 1, 1);
+#ifdef MOZ_WAYLAND
+    hasAnchorRect = false;
+#endif
+  }
+  LOG(("  anchor x %d y %d width %d height %d (absolute coords)\n",
+       anchorRect.x, anchorRect.y, anchorRect.width, anchorRect.height));
+
+  // Anchor rect is in the toplevel coordinates but we need to transfer it to
+  // the coordinates relative to the popup parent for the
+  // gdk_window_move_to_rect
+  int x_parent = 0, y_parent = 0;
+  GtkWindow* parentGtkWindow = gtk_window_get_transient_for(GTK_WINDOW(mShell));
+  if (parentGtkWindow) {
+    GetWindowOrigin(gtk_widget_get_window(GTK_WIDGET(parentGtkWindow)),
+                    &x_parent, &y_parent);
+  }
+  LOG(("  x_parent    %d   y_parent    %d\n", x_parent, y_parent));
+  anchorRect.MoveBy(-x_parent, -y_parent);
+  GdkRectangle rect = {anchorRect.x, anchorRect.y, anchorRect.width,
+                       anchorRect.height};
+
+  // Get gravity and flip type
+  GdkGravity rectAnchor = GDK_GRAVITY_NORTH_WEST;
+  GdkGravity menuAnchor = GDK_GRAVITY_NORTH_WEST;
+  FlipType flipType = FlipType_Default;
+  int8_t position = -1;
+  if (popupFrame) {
+#ifdef MOZ_WAYLAND
+    rectAnchor = PopupAlignmentToGdkGravity(popupFrame->GetPopupAnchor());
+    menuAnchor = PopupAlignmentToGdkGravity(popupFrame->GetPopupAlignment());
+    flipType = popupFrame->GetFlipType();
+    position = popupFrame->GetAlignmentPosition();
+#endif
+  } else {
+    LOG(("  NO ANCHOR INFO"));
+    if (GetTextDirection() == GTK_TEXT_DIR_RTL) {
+      rectAnchor = GDK_GRAVITY_NORTH_EAST;
+      menuAnchor = GDK_GRAVITY_NORTH_EAST;
+    }
+  }
+  LOG((" parentRect gravity: %d anchor gravity: %d\n", rectAnchor, menuAnchor));
+
+  GdkAnchorHints hints = GdkAnchorHints(GDK_ANCHOR_RESIZE);
+
+  // slideHorizontal from nsMenuPopupFrame::SetPopupPosition
+  if (position >= POPUPPOSITION_BEFORESTART &&
+      position <= POPUPPOSITION_AFTEREND) {
+    hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE_X);
+  }
+  // slideVertical from nsMenuPopupFrame::SetPopupPosition
+  if (position >= POPUPPOSITION_STARTBEFORE &&
+      position <= POPUPPOSITION_ENDAFTER) {
+    hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE_Y);
+  }
+
+  if (popupFrame && rectAnchor == GDK_GRAVITY_CENTER &&
+      menuAnchor == GDK_GRAVITY_CENTER) {
+    // only slide
+    hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE);
+  } else {
+    switch (flipType) {
+      case FlipType_Both:
+        hints = GdkAnchorHints(hints | GDK_ANCHOR_FLIP);
+        break;
+      case FlipType_Slide:
+        hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE);
+        break;
+      case FlipType_Default:
+        hints = GdkAnchorHints(hints | GDK_ANCHOR_FLIP);
+        break;
+      default:
+        break;
+    }
+  }
+  if (!IsMainMenuWindow()) {
+    // we don't want to slide menus to fit the screen rather resize them
+    hints = GdkAnchorHints(hints | GDK_ANCHOR_SLIDE);
+  }
+
+  // A workaround for https://gitlab.gnome.org/GNOME/gtk/issues/1986
+  // gdk_window_move_to_rect() does not reposition visible windows.
+  static auto sGtkWidgetIsVisible =
+      (gboolean(*)(GtkWidget*))dlsym(RTLD_DEFAULT, "gtk_widget_is_visible");
+
+  bool isWidgetVisible =
+      (sGtkWidgetIsVisible != nullptr) && sGtkWidgetIsVisible(mShell);
+  if (isWidgetVisible) {
+    PauseRemoteRenderer();
+    gtk_widget_hide(mShell);
+  }
+
+  LOG(("  requested rect: x: %d y: %d width: %d height: %d\n", rect.x, rect.y,
+       rect.width, rect.height));
+  if (aSize) {
+    LOG(("  aSize: x%d y%d w%d h%d\n", aSize->x, aSize->y, aSize->width,
+         aSize->height));
+  } else {
+    LOG(("  No aSize given"));
+  }
+
+  // Inspired by nsMenuPopupFrame::AdjustPositionForAnchorAlign
+  nsPoint cursorOffset(0, 0);
+#ifdef MOZ_WAYLAND
+  // Offset is already computed to the tooltips
+  if (hasAnchorRect && popupFrame && mPopupType != ePopupTypeTooltip) {
+    nsMargin margin(0, 0, 0, 0);
+    popupFrame->StyleMargin()->GetMargin(margin);
+    switch (popupFrame->GetPopupAlignment()) {
+      case POPUPALIGNMENT_TOPRIGHT:
+        cursorOffset.MoveBy(-margin.right, margin.top);
+        break;
+      case POPUPALIGNMENT_BOTTOMLEFT:
+        cursorOffset.MoveBy(margin.left, -margin.bottom);
+        break;
+      case POPUPALIGNMENT_BOTTOMRIGHT:
+        cursorOffset.MoveBy(-margin.right, -margin.bottom);
+        break;
+      case POPUPALIGNMENT_TOPLEFT:
+      default:
+        cursorOffset.MoveBy(margin.left, margin.top);
+        break;
+    }
+  }
+#endif
+
+  if (!g_signal_handler_find(
+          gdkWindow, G_SIGNAL_MATCH_FUNC, 0, 0, nullptr,
+          FuncToGpointer(NativeMoveResizeWaylandPopupCallback), this)) {
+    g_signal_connect(gdkWindow, "moved-to-rect",
+                     G_CALLBACK(NativeMoveResizeWaylandPopupCallback), this);
+  }
+
+  LOG(("  popup window cursor offset x: %d y: %d\n", cursorOffset.x / p2a,
+       cursorOffset.y / p2a));
+  mWaitingForMoveToRectCB = true;
+  sGdkWindowMoveToRect(gdkWindow, &rect, rectAnchor, menuAnchor, hints,
+                       cursorOffset.x / p2a, cursorOffset.y / p2a);
+
+  if (isWidgetVisible) {
+    // We show the popup with the same configuration so no need to call
+    // ConfigureWaylandPopupWindows() before gtk_widget_show().
+    gtk_widget_show(mShell);
+  }
+}
+
+void nsWindow::NativeMove() {
+  GdkPoint point = DevicePixelsToGdkPointRoundDown(mBounds.TopLeft());
+
+  LOG(("nsWindow::NativeMove [%p] %d %d\n", (void*)this, point.x, point.y));
+
+  if (IsWaylandPopup()) {
+    GdkRectangle size = DevicePixelsToGdkSizeRoundUp(mBounds.Size());
+    NativeMoveResizeWaylandPopup(&point, &size);
+  } else if (mIsTopLevel) {
+    gtk_window_move(GTK_WINDOW(mShell), point.x, point.y);
+  } else if (mGdkWindow) {
+    gdk_window_move(mGdkWindow, point.x, point.y);
+  }
+}
+
+void nsWindow::SetZIndex(int32_t aZIndex) {
+  nsIWidget* oldPrev = GetPrevSibling();
+
+  nsBaseWidget::SetZIndex(aZIndex);
+
+  if (GetPrevSibling() == oldPrev) {
+    return;
+  }
+
+  NS_ASSERTION(!mContainer, "Expected Mozilla child widget");
+
+  // We skip the nsWindows that don't have mGdkWindows.
+  // These are probably in the process of being destroyed.
+
+  if (!GetNextSibling()) {
+    // We're to be on top.
+    if (mGdkWindow) gdk_window_raise(mGdkWindow);
+  } else {
+    // All the siblings before us need to be below our widget.
+    for (nsWindow* w = this; w;
+         w = static_cast<nsWindow*>(w->GetPrevSibling())) {
+      if (w->mGdkWindow) gdk_window_lower(w->mGdkWindow);
+    }
+  }
+}
+
+void nsWindow::SetSizeMode(nsSizeMode aMode) {
+  LOG(("nsWindow::SetSizeMode [%p] %d\n", (void*)this, aMode));
+
+  // Save the requested state.
+  nsBaseWidget::SetSizeMode(aMode);
+
+  // return if there's no shell or our current state is the same as
+  // the mode we were just set to.
+  if (!mShell || mSizeState == mSizeMode) {
+    LOG(("    already set"));
+    return;
+  }
+
+  switch (aMode) {
+    case nsSizeMode_Maximized:
+      LOG(("    set maximized"));
+      gtk_window_maximize(GTK_WINDOW(mShell));
+      break;
+    case nsSizeMode_Minimized:
+      LOG(("    set minimized"));
+      gtk_window_iconify(GTK_WINDOW(mShell));
+      break;
+    case nsSizeMode_Fullscreen:
+      LOG(("    set fullscreen"));
+      MakeFullScreen(true);
+      break;
+
+    default:
+      LOG(("    set normal"));
+      // nsSizeMode_Normal, really.
+      if (mSizeState == nsSizeMode_Minimized)
+        gtk_window_deiconify(GTK_WINDOW(mShell));
+      else if (mSizeState == nsSizeMode_Maximized)
+        gtk_window_unmaximize(GTK_WINDOW(mShell));
+      break;
+  }
+
+  // Request mBounds update from configure event as we may not get
+  // OnSizeAllocate for size state changes (Bug 1489463).
+  mBoundsAreValid = false;
+
+  mSizeState = mSizeMode;
+}
+
+static bool GetWindowManagerName(GdkWindow* gdk_window, nsACString& wmName) {
+  if (!gfxPlatformGtk::GetPlatform()->IsX11Display()) {
+    return false;
+  }
+
+#ifdef MOZ_X11
+  Display* xdisplay = gdk_x11_get_default_xdisplay();
+  GdkScreen* screen = gdk_window_get_screen(gdk_window);
+  Window root_win = GDK_WINDOW_XID(gdk_screen_get_root_window(screen));
+
+  int actual_format_return;
+  Atom actual_type_return;
+  unsigned long nitems_return;
+  unsigned long bytes_after_return;
+  unsigned char* prop_return = nullptr;
+  auto releaseXProperty = MakeScopeExit([&] {
+    if (prop_return) {
+      XFree(prop_return);
+    }
+  });
+
+  Atom property = XInternAtom(xdisplay, "_NET_SUPPORTING_WM_CHECK", true);
+  Atom req_type = XInternAtom(xdisplay, "WINDOW", true);
+  if (!property || !req_type) {
+    return false;
+  }
+  int result =
+      XGetWindowProperty(xdisplay, root_win, property,
+                         0L,                  // offset
+                         sizeof(Window) / 4,  // length
+                         false,               // delete
+                         req_type, &actual_type_return, &actual_format_return,
+                         &nitems_return, &bytes_after_return, &prop_return);
+
+  if (result != Success || bytes_after_return != 0 || nitems_return != 1) {
+    return false;
+  }
+
+  Window wmWindow = reinterpret_cast<Window*>(prop_return)[0];
+  if (!wmWindow) {
+    return false;
+  }
+
+  XFree(prop_return);
+  prop_return = nullptr;
+
+  property = XInternAtom(xdisplay, "_NET_WM_NAME", true);
+  req_type = XInternAtom(xdisplay, "UTF8_STRING", true);
+  if (!property || !req_type) {
+    return false;
+  }
+  {
+    // Suppress fatal errors for a missing window.
+    ScopedXErrorHandler handler;
+    result =
+        XGetWindowProperty(xdisplay, wmWindow, property,
+                           0L,         // offset
+                           INT32_MAX,  // length
+                           false,      // delete
+                           req_type, &actual_type_return, &actual_format_return,
+                           &nitems_return, &bytes_after_return, &prop_return);
+  }
+
+  if (result != Success || bytes_after_return != 0) {
+    return false;
+  }
+
+  wmName = reinterpret_cast<const char*>(prop_return);
+  return true;
+#endif
+}
+
+#define kDesktopMutterSchema "org.gnome.mutter"
+#define kDesktopDynamicWorkspacesKey "dynamic-workspaces"
+
+static bool WorkspaceManagementDisabled(GdkWindow* gdk_window) {
+  if (Preferences::GetBool("widget.disable-workspace-management", false)) {
+    return true;
+  }
+  if (Preferences::HasUserValue("widget.workspace-management")) {
+    return Preferences::GetBool("widget.workspace-management");
+  }
+
+  static const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+  if (currentDesktop && strstr(currentDesktop, "GNOME")) {
+    // Gnome uses dynamic workspaces by default so disable workspace management
+    // in that case.
+    bool usesDynamicWorkspaces = true;
+    nsCOMPtr<nsIGSettingsService> gsettings =
+        do_GetService(NS_GSETTINGSSERVICE_CONTRACTID);
+    if (gsettings) {
+      nsCOMPtr<nsIGSettingsCollection> mutterSettings;
+      gsettings->GetCollectionForSchema(nsLiteralCString(kDesktopMutterSchema),
+                                        getter_AddRefs(mutterSettings));
+      if (mutterSettings) {
+        if (NS_SUCCEEDED(mutterSettings->GetBoolean(
+                nsLiteralCString(kDesktopDynamicWorkspacesKey),
+                &usesDynamicWorkspaces))) {
+        }
+      }
+    }
+    return usesDynamicWorkspaces;
+  }
+
+  // When XDG_CURRENT_DESKTOP is missing, try to get window manager name.
+  if (!currentDesktop) {
+    nsAutoCString wmName;
+    if (GetWindowManagerName(gdk_window, wmName)) {
+      if (wmName.EqualsLiteral("bspwm")) {
+        return true;
+      }
+      if (wmName.EqualsLiteral("i3")) {
+        return true;
+      }
+    }
+  }
+
+  return false;
+}
+
+void nsWindow::GetWorkspaceID(nsAString& workspaceID) {
+  workspaceID.Truncate();
+
+  if (!mIsX11Display || !mShell) {
+    return;
+  }
+#ifdef MOZ_X11
+  // Get the gdk window for this widget.
+  GdkWindow* gdk_window = gtk_widget_get_window(mShell);
+  if (!gdk_window) {
+    return;
+  }
+
+  if (WorkspaceManagementDisabled(gdk_window)) {
+    return;
+  }
+
+  GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
+  GdkAtom type_returned;
+  int format_returned;
+  int length_returned;
+  long* wm_desktop;
+
+  if (!gdk_property_get(gdk_window, gdk_atom_intern("_NET_WM_DESKTOP", FALSE),
+                        cardinal_atom,
+                        0,          // offset
+                        INT32_MAX,  // length
+                        FALSE,      // delete
+                        &type_returned, &format_returned, &length_returned,
+                        (guchar**)&wm_desktop)) {
+    return;
+  }
+
+  workspaceID.AppendInt((int32_t)wm_desktop[0]);
+  g_free(wm_desktop);
+#endif
+}
+
+void nsWindow::MoveToWorkspace(const nsAString& workspaceIDStr) {
+  nsresult rv = NS_OK;
+  int32_t workspaceID = workspaceIDStr.ToInteger(&rv);
+  if (NS_FAILED(rv) || !workspaceID || !mIsX11Display || !mShell) {
+    return;
+  }
+
+#ifdef MOZ_X11
+  // Get the gdk window for this widget.
+  GdkWindow* gdk_window = gtk_widget_get_window(mShell);
+  if (!gdk_window) {
+    return;
+  }
+
+  // This code is inspired by some found in the 'gxtuner' project.
+  // https://github.com/brummer10/gxtuner/blob/792d453da0f3a599408008f0f1107823939d730d/deskpager.cpp#L50
+  XEvent xevent;
+  Display* xdisplay = gdk_x11_get_default_xdisplay();
+  GdkScreen* screen = gdk_window_get_screen(gdk_window);
+  Window root_win = GDK_WINDOW_XID(gdk_screen_get_root_window(screen));
+  GdkDisplay* display = gdk_window_get_display(gdk_window);
+  Atom type = gdk_x11_get_xatom_by_name_for_display(display, "_NET_WM_DESKTOP");
+
+  xevent.type = ClientMessage;
+  xevent.xclient.type = ClientMessage;
+  xevent.xclient.serial = 0;
+  xevent.xclient.send_event = TRUE;
+  xevent.xclient.display = xdisplay;
+  xevent.xclient.window = GDK_WINDOW_XID(gdk_window);
+  xevent.xclient.message_type = type;
+  xevent.xclient.format = 32;
+  xevent.xclient.data.l[0] = workspaceID;
+  xevent.xclient.data.l[1] = X11CurrentTime;
+  xevent.xclient.data.l[2] = 0;
+  xevent.xclient.data.l[3] = 0;
+  xevent.xclient.data.l[4] = 0;
+
+  XSendEvent(xdisplay, root_win, FALSE,
+             SubstructureNotifyMask | SubstructureRedirectMask, &xevent);
+
+  XFlush(xdisplay);
+#endif
+}
+
+typedef void (*SetUserTimeFunc)(GdkWindow* aWindow, guint32 aTimestamp);
+
+static void SetUserTimeAndStartupIDForActivatedWindow(GtkWidget* aWindow) {
+  nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
+  if (!GTKToolkit) return;
+
+  nsAutoCString desktopStartupID;
+  GTKToolkit->GetDesktopStartupID(&desktopStartupID);
+  if (desktopStartupID.IsEmpty()) {
+    // We don't have the data we need. Fall back to an
+    // approximation ... using the timestamp of the remote command
+    // being received as a guess for the timestamp of the user event
+    // that triggered it.
+    uint32_t timestamp = GTKToolkit->GetFocusTimestamp();
+    if (timestamp) {
+      gdk_window_focus(gtk_widget_get_window(aWindow), timestamp);
+      GTKToolkit->SetFocusTimestamp(0);
+    }
+    return;
+  }
+
+  gtk_window_set_startup_id(GTK_WINDOW(aWindow), desktopStartupID.get());
+
+  // If we used the startup ID, that already contains the focus timestamp;
+  // we don't want to reuse the timestamp next time we raise the window
+  GTKToolkit->SetFocusTimestamp(0);
+  GTKToolkit->SetDesktopStartupID(""_ns);
+}
+
+/* static */
+guint32 nsWindow::GetLastUserInputTime() {
+  // gdk_x11_display_get_user_time/gtk_get_current_event_time tracks
+  // button and key presses, DESKTOP_STARTUP_ID used to start the app,
+  // drop events from external drags,
+  // WM_DELETE_WINDOW delete events, but not usually mouse motion nor
+  // button and key releases.  Therefore use the most recent of
+  // gdk_x11_display_get_user_time and the last time that we have seen.
+#ifdef MOZ_X11
+  GdkDisplay* gdkDisplay = gdk_display_get_default();
+  guint32 timestamp = GDK_IS_X11_DISPLAY(gdkDisplay)
+                          ? gdk_x11_display_get_user_time(gdkDisplay)
+                          : gtk_get_current_event_time();
+#else
+  guint32 timestamp = gtk_get_current_event_time();
+#endif
+
+  if (sLastUserInputTime != GDK_CURRENT_TIME &&
+      TimestampIsNewerThan(sLastUserInputTime, timestamp)) {
+    return sLastUserInputTime;
+  }
+
+  return timestamp;
+}
+
+void nsWindow::SetFocus(Raise aRaise, mozilla::dom::CallerType aCallerType) {
+  // Make sure that our owning widget has focus.  If it doesn't try to
+  // grab it.  Note that we don't set our focus flag in this case.
+
+  LOGFOCUS(("  SetFocus %d [%p]\n", aRaise == Raise::Yes, (void*)this));
+
+  GtkWidget* owningWidget = GetMozContainerWidget();
+  if (!owningWidget) return;
+
+  // Raise the window if someone passed in true and the prefs are
+  // set properly.
+  GtkWidget* toplevelWidget = gtk_widget_get_toplevel(owningWidget);
+
+  if (gRaiseWindows && aRaise == Raise::Yes && toplevelWidget &&
+      !gtk_widget_has_focus(owningWidget) &&
+      !gtk_widget_has_focus(toplevelWidget)) {
+    GtkWidget* top_window = GetToplevelWidget();
+    if (top_window && (gtk_widget_get_visible(top_window))) {
+      gdk_window_show_unraised(gtk_widget_get_window(top_window));
+      // Unset the urgency hint if possible.
+      SetUrgencyHint(top_window, false);
+    }
+  }
+
+  RefPtr<nsWindow> owningWindow = get_window_for_gtk_widget(owningWidget);
+  if (!owningWindow) return;
+
+  if (aRaise == Raise::Yes) {
+    // means request toplevel activation.
+
+    // This is asynchronous.
+    // If and when the window manager accepts the request, then the focus
+    // widget will get a focus-in-event signal.
+    if (gRaiseWindows && owningWindow->mIsShown && owningWindow->mShell &&
+        !gtk_window_is_active(GTK_WINDOW(owningWindow->mShell))) {
+      if (!mIsX11Display &&
+          Preferences::GetBool("testing.browserTestHarness.running", false)) {
+        // Wayland does not support focus changes so we need to workaround it
+        // by window hide/show sequence but only when it's running in testsuite.
+        owningWindow->NativeShow(false);
+        owningWindow->NativeShow(true);
+        return;
+      }
+
+#ifdef MOZ_X11
+      uint32_t timestamp = GDK_CURRENT_TIME;
+
+      nsGTKToolkit* GTKToolkit = nsGTKToolkit::GetToolkit();
+      if (GTKToolkit) timestamp = GTKToolkit->GetFocusTimestamp();
+
+      LOGFOCUS(("  requesting toplevel activation [%p]\n", (void*)this));
+      NS_ASSERTION(owningWindow->mWindowType != eWindowType_popup || mParent,
+                   "Presenting an override-redirect window");
+      gtk_window_present_with_time(GTK_WINDOW(owningWindow->mShell), timestamp);
+
+      if (GTKToolkit) GTKToolkit->SetFocusTimestamp(0);
+#endif
+    }
+    return;
+  }
+
+  // aRaise == No means that keyboard events should be dispatched from this
+  // widget.
+
+  // Ensure owningWidget is the focused GtkWidget within its toplevel window.
+  //
+  // For eWindowType_popup, this GtkWidget may not actually be the one that
+  // receives the key events as it may be the parent window that is active.
+  if (!gtk_widget_is_focus(owningWidget)) {
+    // This is synchronous.  It takes focus from a plugin or from a widget
+    // in an embedder.  The focus manager already knows that this window
+    // is active so gBlockActivateEvent avoids another (unnecessary)
+    // activate notification.
+    gBlockActivateEvent = true;
+    gtk_widget_grab_focus(owningWidget);
+    gBlockActivateEvent = false;
+  }
+
+  // If this is the widget that already has focus, return.
+  if (gFocusWindow == this) {
+    LOGFOCUS(("  already have focus [%p]\n", (void*)this));
+    return;
+  }
+
+  // Set this window to be the focused child window
+  gFocusWindow = this;
+
+  if (mIMContext) {
+    mIMContext->OnFocusWindow(this);
+  }
+
+  LOGFOCUS(("  widget now has focus in SetFocus() [%p]\n", (void*)this));
+}
+
+LayoutDeviceIntRect nsWindow::GetScreenBounds() {
+  LayoutDeviceIntRect rect;
+  if (mIsTopLevel && mContainer) {
+    // use the point including window decorations
+    gint x, y;
+    gdk_window_get_root_origin(gtk_widget_get_window(GTK_WIDGET(mContainer)),
+                               &x, &y);
+    rect.MoveTo(GdkPointToDevicePixels({x, y}));
+  } else {
+    rect.MoveTo(WidgetToScreenOffset());
+  }
+  // mBounds.Size() is the window bounds, not the window-manager frame
+  // bounds (bug 581863).  gdk_window_get_frame_extents would give the
+  // frame bounds, but mBounds.Size() is returned here for consistency
+  // with Resize.
+  rect.SizeTo(mBounds.Size());
+#if MOZ_LOGGING
+  gint scale = GdkScaleFactor();
+  LOG(("GetScreenBounds [%p] %d,%d -> %d x %d, unscaled %d,%d -> %d x %d\n",
+       this, rect.x, rect.y, rect.width, rect.height, rect.x / scale,
+       rect.y / scale, rect.width / scale, rect.height / scale));
+#endif
+  return rect;
+}
+
+LayoutDeviceIntSize nsWindow::GetClientSize() {
+  return LayoutDeviceIntSize(mBounds.width, mBounds.height);
+}
+
+LayoutDeviceIntRect nsWindow::GetClientBounds() {
+  // GetBounds returns a rect whose top left represents the top left of the
+  // outer bounds, but whose width/height represent the size of the inner
+  // bounds (which is messed up).
+  LayoutDeviceIntRect rect = GetBounds();
+  rect.MoveBy(GetClientOffset());
+  return rect;
+}
+
+void nsWindow::UpdateClientOffsetFromFrameExtents() {
+  AUTO_PROFILER_LABEL("nsWindow::UpdateClientOffsetFromFrameExtents", OTHER);
+
+  if (mCSDSupportLevel == CSD_SUPPORT_CLIENT && mDrawInTitlebar) {
+    return;
+  }
+
+#ifdef MOZ_X11
+  if (!mIsTopLevel || !mShell ||
+      gtk_window_get_window_type(GTK_WINDOW(mShell)) == GTK_WINDOW_POPUP) {
+    mClientOffset = nsIntPoint(0, 0);
+    return;
+  }
+
+  GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
+
+  GdkAtom type_returned;
+  int format_returned;
+  int length_returned;
+  long* frame_extents;
+
+  if (!gdk_property_get(gtk_widget_get_window(mShell),
+                        gdk_atom_intern("_NET_FRAME_EXTENTS", FALSE),
+                        cardinal_atom,
+                        0,      // offset
+                        4 * 4,  // length
+                        FALSE,  // delete
+                        &type_returned, &format_returned, &length_returned,
+                        (guchar**)&frame_extents) ||
+      length_returned / sizeof(glong) != 4) {
+    mClientOffset = nsIntPoint(0, 0);
+  } else {
+    // data returned is in the order left, right, top, bottom
+    auto left = int32_t(frame_extents[0]);
+    auto top = int32_t(frame_extents[2]);
+    g_free(frame_extents);
+
+    mClientOffset = nsIntPoint(left, top);
+  }
+
+  // Send a WindowMoved notification. This ensures that BrowserParent
+  // picks up the new client offset and sends it to the child process
+  // if appropriate.
+  NotifyWindowMoved(mBounds.x, mBounds.y);
+
+  LOG(("nsWindow::UpdateClientOffsetFromFrameExtents [%p] %d,%d\n", (void*)this,
+       mClientOffset.x, mClientOffset.y));
+#endif
+}
+
+LayoutDeviceIntPoint nsWindow::GetClientOffset() {
+  return mIsX11Display ? LayoutDeviceIntPoint::FromUnknownPoint(mClientOffset)
+                       : LayoutDeviceIntPoint(0, 0);
+}
+
+gboolean nsWindow::OnPropertyNotifyEvent(GtkWidget* aWidget,
+                                         GdkEventProperty* aEvent) {
+  if (aEvent->atom == gdk_atom_intern("_NET_FRAME_EXTENTS", FALSE)) {
+    UpdateClientOffsetFromFrameExtents();
+    return FALSE;
+  }
+
+#ifdef MOZ_X11
+  if (GetCurrentTimeGetter()->PropertyNotifyHandler(aWidget, aEvent)) {
+    return TRUE;
+  }
+#endif
+
+  return FALSE;
+}
+
+static GdkCursor* GetCursorForImage(imgIContainer* aCursorImage,
+                                    uint32_t aHotspotX, uint32_t aHotspotY) {
+  if (!aCursorImage) {
+    return nullptr;
+  }
+  GdkPixbuf* pixbuf = nsImageToPixbuf::ImageToPixbuf(aCursorImage);
+  if (!pixbuf) {
+    return nullptr;
+  }
+
+  int width = gdk_pixbuf_get_width(pixbuf);
+  int height = gdk_pixbuf_get_height(pixbuf);
+
+  auto CleanupPixBuf =
+      mozilla::MakeScopeExit([&]() { g_object_unref(pixbuf); });
+
+  // Reject cursors greater than 128 pixels in some direction, to prevent
+  // spoofing.
+  // XXX ideally we should rescale. Also, we could modify the API to
+  // allow trusted content to set larger cursors.
+  //
+  // TODO(emilio, bug 1445844): Unify the solution for this with other
+  // platforms.
+  if (width > 128 || height > 128) {
+    return nullptr;
+  }
+
+  // Looks like all cursors need an alpha channel (tested on Gtk 2.4.4). This
+  // is of course not documented anywhere...
+  // So add one if there isn't one yet
+  if (!gdk_pixbuf_get_has_alpha(pixbuf)) {
+    GdkPixbuf* alphaBuf = gdk_pixbuf_add_alpha(pixbuf, FALSE, 0, 0, 0);
+    g_object_unref(pixbuf);
+    pixbuf = alphaBuf;
+    if (!alphaBuf) {
+      return nullptr;
+    }
+  }
+
+  return gdk_cursor_new_from_pixbuf(gdk_display_get_default(), pixbuf,
+                                    aHotspotX, aHotspotY);
+}
+
+void nsWindow::SetCursor(nsCursor aDefaultCursor, imgIContainer* aCursorImage,
+                         uint32_t aHotspotX, uint32_t aHotspotY) {
+  // if we're not the toplevel window pass up the cursor request to
+  // the toplevel window to handle it.
+  if (!mContainer && mGdkWindow) {
+    nsWindow* window = GetContainerWindow();
+    if (!window) return;
+
+    window->SetCursor(aDefaultCursor, aCursorImage, aHotspotX, aHotspotY);
+    return;
+  }
+
+  // Only change cursor if it's actually been changed
+  if (!aCursorImage && aDefaultCursor == mCursor && !mUpdateCursor) {
+    return;
+  }
+
+  mUpdateCursor = false;
+  mCursor = eCursorInvalid;
+
+  // Try to set the cursor image first, and fall back to the numeric cursor.
+  GdkCursor* newCursor = GetCursorForImage(aCursorImage, aHotspotX, aHotspotY);
+  if (!newCursor) {
+    newCursor = get_gtk_cursor(aDefaultCursor);
+    if (newCursor) {
+      mCursor = aDefaultCursor;
+    }
+  }
+
+  auto CleanupCursor = mozilla::MakeScopeExit([&]() {
+    // get_gtk_cursor returns a weak reference, which we shouldn't unref.
+    if (newCursor && mCursor == eCursorInvalid) {
+      g_object_unref(newCursor);
+    }
+  });
+
+  if (!newCursor || !mContainer) {
+    return;
+  }
+
+  gdk_window_set_cursor(gtk_widget_get_window(GTK_WIDGET(mContainer)),
+                        newCursor);
+}
+
+void nsWindow::Invalidate(const LayoutDeviceIntRect& aRect) {
+  if (!mGdkWindow) return;
+
+  GdkRectangle rect = DevicePixelsToGdkRectRoundOut(aRect);
+  gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+
+  LOGDRAW(("Invalidate (rect) [%p]: %d %d %d %d\n", (void*)this, rect.x, rect.y,
+           rect.width, rect.height));
+}
+
+void* nsWindow::GetNativeData(uint32_t aDataType) {
+  switch (aDataType) {
+    case NS_NATIVE_WINDOW:
+    case NS_NATIVE_WIDGET: {
+      if (!mGdkWindow) return nullptr;
+
+      return mGdkWindow;
+    }
+
+    case NS_NATIVE_DISPLAY: {
+#ifdef MOZ_X11
+      GdkDisplay* gdkDisplay = gdk_display_get_default();
+      if (gdkDisplay && GDK_IS_X11_DISPLAY(gdkDisplay)) {
+        return GDK_DISPLAY_XDISPLAY(gdkDisplay);
+      }
+#endif /* MOZ_X11 */
+      // Don't bother to return native display on Wayland as it's for
+      // X11 only NPAPI plugins.
+      return nullptr;
+    }
+    case NS_NATIVE_SHELLWIDGET:
+      return GetToplevelWidget();
+
+    case NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID:
+    case NS_NATIVE_SHAREABLE_WINDOW:
+#ifdef MOZ_X11
+      if (mIsX11Display) {
+        return (void*)GDK_WINDOW_XID(gdk_window_get_toplevel(mGdkWindow));
+      }
+#endif
+      NS_WARNING(
+          "nsWindow::GetNativeData(): "
+          "NS_NATIVE_SHAREABLE_WINDOW / NS_NATIVE_WINDOW_WEBRTC_DEVICE_ID is "
+          "not "
+          "handled on Wayland!");
+      return nullptr;
+    case NS_RAW_NATIVE_IME_CONTEXT: {
+      void* pseudoIMEContext = GetPseudoIMEContext();
+      if (pseudoIMEContext) {
+        return pseudoIMEContext;
+      }
+      // If IME context isn't available on this widget, we should set |this|
+      // instead of nullptr.
+      if (!mIMContext) {
+        return this;
+      }
+      return mIMContext.get();
+    }
+    case NS_NATIVE_OPENGL_CONTEXT:
+      return nullptr;
+    case NS_NATIVE_EGL_WINDOW: {
+#ifdef MOZ_X11
+      if (mIsX11Display) {
+        return mGdkWindow ? (void*)GDK_WINDOW_XID(mGdkWindow) : nullptr;
+      }
+#endif
+#ifdef MOZ_WAYLAND
+      if (mContainer) {
+        return moz_container_wayland_get_egl_window(mContainer,
+                                                    GdkScaleFactor());
+      }
+#endif
+      return nullptr;
+    }
+    default:
+      NS_WARNING("nsWindow::GetNativeData called with bad value");
+      return nullptr;
+  }
+}
+
+nsresult nsWindow::SetTitle(const nsAString& aTitle) {
+  if (!mShell) return NS_OK;
+
+    // convert the string into utf8 and set the title.
+#define UTF8_FOLLOWBYTE(ch) (((ch)&0xC0) == 0x80)
+  NS_ConvertUTF16toUTF8 titleUTF8(aTitle);
+  if (titleUTF8.Length() > NS_WINDOW_TITLE_MAX_LENGTH) {
+    // Truncate overlong titles (bug 167315). Make sure we chop after a
+    // complete sequence by making sure the next char isn't a follow-byte.
+    uint32_t len = NS_WINDOW_TITLE_MAX_LENGTH;
+    while (UTF8_FOLLOWBYTE(titleUTF8[len])) --len;
+    titleUTF8.Truncate(len);
+  }
+  gtk_window_set_title(GTK_WINDOW(mShell), (const char*)titleUTF8.get());
+
+  return NS_OK;
+}
+
+void nsWindow::SetIcon(const nsAString& aIconSpec) {
+  if (!mShell) return;
+
+  nsAutoCString iconName;
+
+  if (aIconSpec.EqualsLiteral("default")) {
+    nsAutoString brandName;
+    WidgetUtils::GetBrandShortName(brandName);
+    if (brandName.IsEmpty()) {
+      brandName.AssignLiteral(u"Mozilla");
+    }
+    AppendUTF16toUTF8(brandName, iconName);
+    ToLowerCase(iconName);
+  } else {
+    AppendUTF16toUTF8(aIconSpec, iconName);
+  }
+
+  nsCOMPtr<nsIFile> iconFile;
+  nsAutoCString path;
+
+  gint* iconSizes = gtk_icon_theme_get_icon_sizes(gtk_icon_theme_get_default(),
+                                                  iconName.get());
+  bool foundIcon = (iconSizes[0] != 0);
+  g_free(iconSizes);
+
+  if (!foundIcon) {
+    // Look for icons with the following suffixes appended to the base name
+    // The last two entries (for the old XPM format) will be ignored unless
+    // no icons are found using other suffixes. XPM icons are deprecated.
+
+    const char16_t extensions[9][8] = {u".png",    u"16.png", u"32.png",
+                                       u"48.png",  u"64.png", u"128.png",
+                                       u"256.png", u".xpm",   u"16.xpm"};
+
+    for (uint32_t i = 0; i < ArrayLength(extensions); i++) {
+      // Don't bother looking for XPM versions if we found a PNG.
+      if (i == ArrayLength(extensions) - 2 && foundIcon) break;
+
+      ResolveIconName(aIconSpec, nsDependentString(extensions[i]),
+                      getter_AddRefs(iconFile));
+      if (iconFile) {
+        iconFile->GetNativePath(path);
+        GdkPixbuf* icon = gdk_pixbuf_new_from_file(path.get(), nullptr);
+        if (icon) {
+          gtk_icon_theme_add_builtin_icon(iconName.get(),
+                                          gdk_pixbuf_get_height(icon), icon);
+          g_object_unref(icon);
+          foundIcon = true;
+        }
+      }
+    }
+  }
+
+  // leave the default icon intact if no matching icons were found
+  if (foundIcon) {
+    gtk_window_set_icon_name(GTK_WINDOW(mShell), iconName.get());
+  }
+}
+
+LayoutDeviceIntPoint nsWindow::WidgetToScreenOffset() {
+  nsIntPoint origin(0, 0);
+  GetWindowOrigin(mGdkWindow, &origin.x, &origin.y);
+
+  return GdkPointToDevicePixels({origin.x, origin.y});
+}
+
+void nsWindow::CaptureMouse(bool aCapture) {
+  LOG(("CaptureMouse %p\n", (void*)this));
+
+  if (!mGdkWindow) return;
+
+  if (!mContainer) return;
+
+  if (aCapture) {
+    gtk_grab_add(GTK_WIDGET(mContainer));
+    GrabPointer(GetLastUserInputTime());
+  } else {
+    ReleaseGrabs();
+    gtk_grab_remove(GTK_WIDGET(mContainer));
+  }
+}
+
+void nsWindow::CaptureRollupEvents(nsIRollupListener* aListener,
+                                   bool aDoCapture) {
+  if (!mGdkWindow) return;
+
+  if (!mContainer) return;
+
+  LOG(("CaptureRollupEvents %p %i\n", this, int(aDoCapture)));
+
+  if (aDoCapture) {
+    gRollupListener = aListener;
+    // Don't add a grab if a drag is in progress, or if the widget is a drag
+    // feedback popup. (panels with type="drag").
+    if (!mIsDragPopup && !nsWindow::DragInProgress()) {
+      gtk_grab_add(GTK_WIDGET(mContainer));
+      GrabPointer(GetLastUserInputTime());
+    }
+  } else {
+    if (!nsWindow::DragInProgress()) {
+      ReleaseGrabs();
+    }
+    // There may not have been a drag in process when aDoCapture was set,
+    // so make sure to remove any added grab.  This is a no-op if the grab
+    // was not added to this widget.
+    gtk_grab_remove(GTK_WIDGET(mContainer));
+    gRollupListener = nullptr;
+  }
+}
+
+nsresult nsWindow::GetAttention(int32_t aCycleCount) {
+  LOG(("nsWindow::GetAttention [%p]\n", (void*)this));
+
+  GtkWidget* top_window = GetToplevelWidget();
+  GtkWidget* top_focused_window =
+      gFocusWindow ? gFocusWindow->GetToplevelWidget() : nullptr;
+
+  // Don't get attention if the window is focused anyway.
+  if (top_window && (gtk_widget_get_visible(top_window)) &&
+      top_window != top_focused_window) {
+    SetUrgencyHint(top_window, true);
+  }
+
+  return NS_OK;
+}
+
+bool nsWindow::HasPendingInputEvent() {
+  // This sucks, but gtk/gdk has no way to answer the question we want while
+  // excluding paint events, and there's no X API that will let us peek
+  // without blocking or removing.  To prevent event reordering, peek
+  // anything except expose events.  Reordering expose and others should be
+  // ok, hopefully.
+  bool haveEvent = false;
+#ifdef MOZ_X11
+  XEvent ev;
+  if (mIsX11Display) {
+    Display* display = GDK_DISPLAY_XDISPLAY(gdk_display_get_default());
+    haveEvent = XCheckMaskEvent(
+        display,
+        KeyPressMask | KeyReleaseMask | ButtonPressMask | ButtonReleaseMask |
+            EnterWindowMask | LeaveWindowMask | PointerMotionMask |
+            PointerMotionHintMask | Button1MotionMask | Button2MotionMask |
+            Button3MotionMask | Button4MotionMask | Button5MotionMask |
+            ButtonMotionMask | KeymapStateMask | VisibilityChangeMask |
+            StructureNotifyMask | ResizeRedirectMask | SubstructureNotifyMask |
+            SubstructureRedirectMask | FocusChangeMask | PropertyChangeMask |
+            ColormapChangeMask | OwnerGrabButtonMask,
+        &ev);
+    if (haveEvent) {
+      XPutBackEvent(display, &ev);
+    }
+  }
+#endif
+  return haveEvent;
+}
+
+#if 0
+#  ifdef DEBUG
+// Paint flashing code (disabled for cairo - see below)
+
+#    define CAPS_LOCK_IS_ON \
+      (KeymapWrapper::AreModifiersCurrentlyActive(KeymapWrapper::CAPS_LOCK))
+
+#    define WANT_PAINT_FLASHING (debug_WantPaintFlashing() && CAPS_LOCK_IS_ON)
+
+#    ifdef MOZ_X11
+static void
+gdk_window_flash(GdkWindow *    aGdkWindow,
+                 unsigned int   aTimes,
+                 unsigned int   aInterval,  // Milliseconds
+                 GdkRegion *    aRegion)
+{
+  gint         x;
+  gint         y;
+  gint         width;
+  gint         height;
+  guint        i;
+  GdkGC *      gc = 0;
+  GdkColor     white;
+
+  gdk_window_get_geometry(aGdkWindow,nullptr,nullptr,&width,&height);
+
+  gdk_window_get_origin (aGdkWindow,
+                         &x,
+                         &y);
+
+  gc = gdk_gc_new(gdk_get_default_root_window());
+
+  white.pixel = WhitePixel(gdk_display,DefaultScreen(gdk_display));
+
+  gdk_gc_set_foreground(gc,&white);
+  gdk_gc_set_function(gc,GDK_XOR);
+  gdk_gc_set_subwindow(gc,GDK_INCLUDE_INFERIORS);
+
+  gdk_region_offset(aRegion, x, y);
+  gdk_gc_set_clip_region(gc, aRegion);
+
+  /*
+   * Need to do this twice so that the XOR effect can replace
+   * the original window contents.
+   */
+  for (i = 0; i < aTimes * 2; i++)
+  {
+    gdk_draw_rectangle(gdk_get_default_root_window(),
+                       gc,
+                       TRUE,
+                       x,
+                       y,
+                       width,
+                       height);
+
+    gdk_flush();
+
+    PR_Sleep(PR_MillisecondsToInterval(aInterval));
+  }
+
+  gdk_gc_destroy(gc);
+
+  gdk_region_offset(aRegion, -x, -y);
+}
+#    endif /* MOZ_X11 */
+#  endif   // DEBUG
+#endif
+
+#ifdef cairo_copy_clip_rectangle_list
+#  error "Looks like we're including Mozilla's cairo instead of system cairo"
+#endif
+static bool ExtractExposeRegion(LayoutDeviceIntRegion& aRegion, cairo_t* cr) {
+  cairo_rectangle_list_t* rects = cairo_copy_clip_rectangle_list(cr);
+  if (rects->status != CAIRO_STATUS_SUCCESS) {
+    NS_WARNING("Failed to obtain cairo rectangle list.");
+    return false;
+  }
+
+  for (int i = 0; i < rects->num_rectangles; i++) {
+    const cairo_rectangle_t& r = rects->rectangles[i];
+    aRegion.Or(aRegion,
+               LayoutDeviceIntRect::Truncate(r.x, r.y, r.width, r.height));
+    LOGDRAW(("\t%f %f %f %f\n", r.x, r.y, r.width, r.height));
+  }
+
+  cairo_rectangle_list_destroy(rects);
+  return true;
+}
+
+#ifdef MOZ_WAYLAND
+void nsWindow::MaybeResumeCompositor() {
+  MOZ_RELEASE_ASSERT(NS_IsMainThread());
+
+  if (mIsDestroyed || !mNeedsCompositorResume) {
+    return;
+  }
+
+  if (CompositorBridgeChild* remoteRenderer = GetRemoteRenderer()) {
+    MOZ_ASSERT(mCompositorWidgetDelegate);
+    if (mCompositorWidgetDelegate) {
+      mCompositorInitiallyPaused = false;
+      mNeedsCompositorResume = false;
+      remoteRenderer->SendResumeAsync();
+    }
+    remoteRenderer->SendForcePresent();
+  }
+}
+
+void nsWindow::CreateCompositorVsyncDispatcher() {
+  if (!mWaylandVsyncSource) {
+    nsBaseWidget::CreateCompositorVsyncDispatcher();
+    return;
+  }
+
+  if (XRE_IsParentProcess()) {
+    if (!mCompositorVsyncDispatcherLock) {
+      mCompositorVsyncDispatcherLock =
+          MakeUnique<Mutex>("mCompositorVsyncDispatcherLock");
+    }
+    MutexAutoLock lock(*mCompositorVsyncDispatcherLock);
+    if (!mCompositorVsyncDispatcher) {
+      mCompositorVsyncDispatcher =
+          new CompositorVsyncDispatcher(mWaylandVsyncSource);
+    }
+  }
+}
+#endif
+
+gboolean nsWindow::OnExposeEvent(cairo_t* cr) {
+  // Send any pending resize events so that layout can update.
+  // May run event loop.
+  MaybeDispatchResized();
+
+  if (mIsDestroyed) {
+    return FALSE;
+  }
+
+  // Windows that are not visible will be painted after they become visible.
+  if (!mGdkWindow || !mHasMappedToplevel) {
+    return FALSE;
+  }
+#ifdef MOZ_WAYLAND
+  if (!mIsX11Display && !moz_container_wayland_can_draw(mContainer)) {
+    return FALSE;
+  }
+#endif
+
+#ifdef MOZ_X11
+  nsIWidgetListener* listener = GetListener();
+  if (!listener) return FALSE;
+
+  LOGDRAW(("received expose event [%p] %p 0x%lx (rects follow):\n", this,
+           mGdkWindow, mIsX11Display ? gdk_x11_window_get_xid(mGdkWindow) : 0));
+  LayoutDeviceIntRegion exposeRegion;
+  if (!ExtractExposeRegion(exposeRegion, cr)) {
+    return FALSE;
+  }
+
+  gint scale = GdkScaleFactor();
+  LayoutDeviceIntRegion region = exposeRegion;
+  region.ScaleRoundOut(scale, scale);
+
+  if (GetLayerManager()->AsKnowsCompositor() && mCompositorSession) {
+    // We need to paint to the screen even if nothing changed, since if we
+    // don't have a compositing window manager, our pixels could be stale.
+    GetLayerManager()->SetNeedsComposite(true);
+    GetLayerManager()->SendInvalidRegion(region.ToUnknownRegion());
+  }
+
+  RefPtr<nsWindow> strongThis(this);
+
+  // Dispatch WillPaintWindow notification to allow scripts etc. to run
+  // before we paint
+  {
+    listener->WillPaintWindow(this);
+
+    // If the window has been destroyed during the will paint notification,
+    // there is nothing left to do.
+    if (!mGdkWindow) return TRUE;
+
+    // Re-get the listener since the will paint notification might have
+    // killed it.
+    listener = GetListener();
+    if (!listener) return FALSE;
+  }
+
+  if (GetLayerManager()->AsKnowsCompositor() &&
+      GetLayerManager()->NeedsComposite()) {
+    GetLayerManager()->ScheduleComposite();
+    GetLayerManager()->SetNeedsComposite(false);
+  }
+
+  // Our bounds may have changed after calling WillPaintWindow.  Clip
+  // to the new bounds here.  The region is relative to this
+  // window.
+  region.And(region, LayoutDeviceIntRect(0, 0, mBounds.width, mBounds.height));
+
+  bool shaped = false;
+  if (eTransparencyTransparent == GetTransparencyMode()) {
+    auto window = static_cast<nsWindow*>(GetTopLevelWidget());
+    if (mTransparencyBitmapForTitlebar) {
+      if (mSizeState == nsSizeMode_Normal) {
+        window->UpdateTitlebarTransparencyBitmap();
+      } else {
+        window->ClearTransparencyBitmap();
+      }
+    } else {
+      if (mHasAlphaVisual) {
+        // Remove possible shape mask from when window manger was not
+        // previously compositing.
+        window->ClearTransparencyBitmap();
+      } else {
+        shaped = true;
+      }
+    }
+  }
+
+  if (!shaped) {
+    GList* children = gdk_window_peek_children(mGdkWindow);
+    while (children) {
+      GdkWindow* gdkWin = GDK_WINDOW(children->data);
+      nsWindow* kid = get_window_for_gdk_window(gdkWin);
+      if (kid && gdk_window_is_visible(gdkWin)) {
+        AutoTArray<LayoutDeviceIntRect, 1> clipRects;
+        kid->GetWindowClipRegion(&clipRects);
+        LayoutDeviceIntRect bounds = kid->GetBounds();
+        for (uint32_t i = 0; i < clipRects.Length(); ++i) {
+          LayoutDeviceIntRect r = clipRects[i] + bounds.TopLeft();
+          region.Sub(region, r);
+        }
+      }
+      children = children->next;
+    }
+  }
+
+  if (region.IsEmpty()) {
+    return TRUE;
+  }
+
+  // If this widget uses OMTC...
+  if (GetLayerManager()->GetBackendType() == LayersBackend::LAYERS_CLIENT ||
+      GetLayerManager()->GetBackendType() == LayersBackend::LAYERS_WR) {
+    listener->PaintWindow(this, region);
+
+    // Re-get the listener since the will paint notification might have
+    // killed it.
+    listener = GetListener();
+    if (!listener) return TRUE;
+
+    listener->DidPaintWindow();
+    return TRUE;
+  }
+
+  BufferMode layerBuffering = BufferMode::BUFFERED;
+  RefPtr<DrawTarget> dt = StartRemoteDrawingInRegion(region, &layerBuffering);
+  if (!dt || !dt->IsValid()) {
+    return FALSE;
+  }
+  RefPtr<gfxContext> ctx;
+  IntRect boundsRect = region.GetBounds().ToUnknownRect();
+  IntPoint offset(0, 0);
+  if (dt->GetSize() == boundsRect.Size()) {
+    offset = boundsRect.TopLeft();
+    dt->SetTransform(Matrix::Translation(-offset));
+  }
+
+#ifdef MOZ_X11
+  if (shaped) {
+    // Collapse update area to the bounding box. This is so we only have to
+    // call UpdateTranslucentWindowAlpha once. After we have dropped
+    // support for non-Thebes graphics, UpdateTranslucentWindowAlpha will be
+    // our private interface so we can rework things to avoid this.
+    dt->PushClipRect(Rect(boundsRect));
+
+    // The double buffering is done here to extract the shape mask.
+    // (The shape mask won't be necessary when a visual with an alpha
+    // channel is used on compositing window managers.)
+    layerBuffering = BufferMode::BUFFER_NONE;
+    RefPtr<DrawTarget> destDT =
+        dt->CreateSimilarDrawTarget(boundsRect.Size(), SurfaceFormat::B8G8R8A8);
+    if (!destDT || !destDT->IsValid()) {
+      return FALSE;
+    }
+    destDT->SetTransform(Matrix::Translation(-boundsRect.TopLeft()));
+    ctx = gfxContext::CreatePreservingTransformOrNull(destDT);
+  } else {
+    gfxUtils::ClipToRegion(dt, region.ToUnknownRegion());
+    ctx = gfxContext::CreatePreservingTransformOrNull(dt);
+  }
+  MOZ_ASSERT(ctx);  // checked both dt and destDT valid draw target above
+
+#  if 0
+    // NOTE: Paint flashing region would be wrong for cairo, since
+    // cairo inflates the update region, etc.  So don't paint flash
+    // for cairo.
+#    ifdef DEBUG
+    // XXX aEvent->region may refer to a newly-invalid area.  FIXME
+    if (0 && WANT_PAINT_FLASHING && gtk_widget_get_window(aEvent))
+        gdk_window_flash(mGdkWindow, 1, 100, aEvent->region);
+#    endif
+#  endif
+
+#endif  // MOZ_X11
+
+  bool painted = false;
+  {
+    if (GetLayerManager()->GetBackendType() == LayersBackend::LAYERS_BASIC) {
+      if (GetTransparencyMode() == eTransparencyTransparent &&
+          layerBuffering == BufferMode::BUFFER_NONE && mHasAlphaVisual) {
+        // If our draw target is unbuffered and we use an alpha channel,
+        // clear the image beforehand to ensure we don't get artifacts from a
+        // reused SHM image. See bug 1258086.
+        dt->ClearRect(Rect(boundsRect));
+      }
+      AutoLayerManagerSetup setupLayerManager(this, ctx, layerBuffering);
+      painted = listener->PaintWindow(this, region);
+
+      // Re-get the listener since the will paint notification might have
+      // killed it.
+      listener = GetListener();
+      if (!listener) return TRUE;
+    }
+  }
+
+#ifdef MOZ_X11
+  // PaintWindow can Destroy us (bug 378273), avoid doing any paint
+  // operations below if that happened - it will lead to XError and exit().
+  if (shaped) {
+    if (MOZ_LIKELY(!mIsDestroyed)) {
+      if (painted) {
+        RefPtr<SourceSurface> surf = ctx->GetDrawTarget()->Snapshot();
+
+        UpdateAlpha(surf, boundsRect);
+
+        dt->DrawSurface(surf, Rect(boundsRect),
+                        Rect(0, 0, boundsRect.width, boundsRect.height),
+                        DrawSurfaceOptions(SamplingFilter::POINT),
+                        DrawOptions(1.0f, CompositionOp::OP_SOURCE));
+      }
+    }
+  }
+
+  ctx = nullptr;
+  dt->PopClip();
+
+#endif  // MOZ_X11
+
+  EndRemoteDrawingInRegion(dt, region);
+
+  listener->DidPaintWindow();
+
+  // Synchronously flush any new dirty areas
+  cairo_region_t* dirtyArea = gdk_window_get_update_area(mGdkWindow);
+
+  if (dirtyArea) {
+    gdk_window_invalidate_region(mGdkWindow, dirtyArea, false);
+    cairo_region_destroy(dirtyArea);
+    gdk_window_process_updates(mGdkWindow, false);
+  }
+
+  // check the return value!
+  return TRUE;
+#endif
+}
+
+void nsWindow::UpdateAlpha(SourceSurface* aSourceSurface,
+                           nsIntRect aBoundsRect) {
+  // We need to create our own buffer to force the stride to match the
+  // expected stride.
+  int32_t stride =
+      GetAlignedStride<4>(aBoundsRect.width, BytesPerPixel(SurfaceFormat::A8));
+  if (stride == 0) {
+    return;
+  }
+  int32_t bufferSize = stride * aBoundsRect.height;
+  auto imageBuffer = MakeUniqueFallible<uint8_t[]>(bufferSize);
+  {
+    RefPtr<DrawTarget> drawTarget = gfxPlatform::CreateDrawTargetForData(
+        imageBuffer.get(), aBoundsRect.Size(), stride, SurfaceFormat::A8);
+
+    if (drawTarget) {
+      drawTarget->DrawSurface(aSourceSurface,
+                              Rect(0, 0, aBoundsRect.width, aBoundsRect.height),
+                              Rect(0, 0, aSourceSurface->GetSize().width,
+                                   aSourceSurface->GetSize().height),
+                              DrawSurfaceOptions(SamplingFilter::POINT),
+                              DrawOptions(1.0f, CompositionOp::OP_SOURCE));
+    }
+  }
+  UpdateTranslucentWindowAlphaInternal(aBoundsRect, imageBuffer.get(), stride);
+}
+
+gboolean nsWindow::OnConfigureEvent(GtkWidget* aWidget,
+                                    GdkEventConfigure* aEvent) {
+  // These events are only received on toplevel windows.
+  //
+  // GDK ensures that the coordinates are the client window top-left wrt the
+  // root window.
+  //
+  //   GDK calculates the cordinates for real ConfigureNotify events on
+  //   managed windows (that would normally be relative to the parent
+  //   window).
+  //
+  //   Synthetic ConfigureNotify events are from the window manager and
+  //   already relative to the root window.  GDK creates all X windows with
+  //   border_width = 0, so synthetic events also indicate the top-left of
+  //   the client window.
+  //
+  //   Override-redirect windows are children of the root window so parent
+  //   coordinates are root coordinates.
+
+  LOG(("configure event [%p] %d %d %d %d\n", (void*)this, aEvent->x, aEvent->y,
+       aEvent->width, aEvent->height));
+
+  if (mPendingConfigures > 0) {
+    mPendingConfigures--;
+  }
+
+  LayoutDeviceIntRect screenBounds = GetScreenBounds();
+
+  if (mWindowType == eWindowType_toplevel ||
+      mWindowType == eWindowType_dialog) {
+    // This check avoids unwanted rollup on spurious configure events from
+    // Cygwin/X (bug 672103).
+    if (mBounds.x != screenBounds.x || mBounds.y != screenBounds.y) {
+      CheckForRollup(0, 0, false, true);
+    }
+  }
+
+  NS_ASSERTION(GTK_IS_WINDOW(aWidget),
+               "Configure event on widget that is not a GtkWindow");
+  if (gtk_window_get_window_type(GTK_WINDOW(aWidget)) == GTK_WINDOW_POPUP) {
+    // Override-redirect window
+    //
+    // These windows should not be moved by the window manager, and so any
+    // change in position is a result of our direction.  mBounds has
+    // already been set in std::move() or Resize(), and that is more
+    // up-to-date than the position in the ConfigureNotify event if the
+    // event is from an earlier window move.
+    //
+    // Skipping the WindowMoved call saves context menus from an infinite
+    // loop when nsXULPopupManager::PopupMoved moves the window to the new
+    // position and nsMenuPopupFrame::SetPopupPosition adds
+    // offsetForContextMenu on each iteration.
+
+    // Our back buffer might have been invalidated while we drew the last
+    // frame, and its contents might be incorrect. See bug 1280653 comment 7
+    // and comment 10. Specifically we must ensure we recomposite the frame
+    // as soon as possible to avoid the corrupted frame being displayed.
+    GetLayerManager()->FlushRendering();
+    return FALSE;
+  }
+
+  mBounds.MoveTo(screenBounds.TopLeft());
+
+  // XXX mozilla will invalidate the entire window after this move
+  // complete.  wtf?
+  NotifyWindowMoved(mBounds.x, mBounds.y);
+
+  // A GTK app would usually update its client area size in response to
+  // a "size-allocate" signal.
+  // However, we need to set mBounds in advance at Resize()
+  // as JS code expects immediate window size change.
+  // If Gecko requests a resize from GTK, but subsequently,
+  // before a corresponding "size-allocate" signal is emitted, the window is
+  // resized to its former size via other means, such as maximizing,
+  // then there is no "size-allocate" signal from which to update
+  // the value of mBounds. Similarly, if Gecko's resize request is refused
+  // by the window manager, then there will be no "size-allocate" signal.
+  // In the refused request case, the window manager is required to dispatch
+  // a ConfigureNotify event. mBounds can then be updated here.
+  // This seems to also be sufficient to update mBounds when Gecko resizes
+  // the window from maximized size and then immediately maximizes again.
+  if (!mBoundsAreValid) {
+    GtkAllocation allocation = {-1, -1, 0, 0};
+    gtk_window_get_size(GTK_WINDOW(mShell), &allocation.width,
+                        &allocation.height);
+    OnSizeAllocate(&allocation);
+  }
+
+  return FALSE;
+}
+
+void nsWindow::OnContainerUnrealize() {
+  // The GdkWindows are about to be destroyed (but not deleted), so remove
+  // their references back to their container widget while the GdkWindow
+  // hierarchy is still available.
+
+  if (mGdkWindow) {
+    DestroyChildWindows();
+
+    g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", nullptr);
+    mGdkWindow = nullptr;
+  }
+}
+
+void nsWindow::OnSizeAllocate(GtkAllocation* aAllocation) {
+  LOG(("nsWindow::OnSizeAllocate [%p] %d,%d -> %d x %d\n", (void*)this,
+       aAllocation->x, aAllocation->y, aAllocation->width,
+       aAllocation->height));
+
+  // Client offset are updated by _NET_FRAME_EXTENTS on X11 when system titlebar
+  // is enabled. In either cases (Wayland or system titlebar is off on X11)
+  // we don't get _NET_FRAME_EXTENTS X11 property notification so we derive
+  // it from mContainer position.
+  if (mCSDSupportLevel == CSD_SUPPORT_CLIENT) {
+    if (!mIsX11Display || (mIsX11Display && mDrawInTitlebar)) {
+      UpdateClientOffsetFromCSDWindow();
+    }
+  }
+
+  mBoundsAreValid = true;
+
+  LayoutDeviceIntSize size = GdkRectToDevicePixels(*aAllocation).Size();
+  if (mBounds.Size() == size) {
+    LOG(("  Already the same size"));
+    // We were already resized at nsWindow::OnConfigureEvent() so skip it.
+    return;
+  }
+
+  // Invalidate the new part of the window now for the pending paint to
+  // minimize background flashes (GDK does not do this for external resizes
+  // of toplevels.)
+  if (mBounds.width < size.width) {
+    GdkRectangle rect = DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect(
+        mBounds.width, 0, size.width - mBounds.width, size.height));
+    gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+  }
+  if (mBounds.height < size.height) {
+    GdkRectangle rect = DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect(
+        0, mBounds.height, size.width, size.height - mBounds.height));
+    gdk_window_invalidate_rect(mGdkWindow, &rect, FALSE);
+  }
+
+  mBounds.SizeTo(size);
+
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
+  // Notify the GtkCompositorWidget of a ClientSizeChange
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+  }
+#endif
+
+  // Gecko permits running nested event loops during processing of events,
+  // GtkWindow callers of gtk_widget_size_allocate expect the signal
+  // handlers to return sometime in the near future.
+  mNeedsDispatchResized = true;
+  NS_DispatchToCurrentThread(NewRunnableMethod(
+      "nsWindow::MaybeDispatchResized", this, &nsWindow::MaybeDispatchResized));
+}
+
+void nsWindow::OnDeleteEvent() {
+  if (mWidgetListener) mWidgetListener->RequestWindowClose(this);
+}
+
+void nsWindow::OnEnterNotifyEvent(GdkEventCrossing* aEvent) {
+  // This skips NotifyVirtual and NotifyNonlinearVirtual enter notify events
+  // when the pointer enters a child window.  If the destination window is a
+  // Gecko window then we'll catch the corresponding event on that window,
+  // but we won't notice when the pointer directly enters a foreign (plugin)
+  // child window without passing over a visible portion of a Gecko window.
+  if (aEvent->subwindow != nullptr) return;
+
+  // Check before is_parent_ungrab_enter() as the button state may have
+  // changed while a non-Gecko ancestor window had a pointer grab.
+  DispatchMissedButtonReleases(aEvent);
+
+  if (is_parent_ungrab_enter(aEvent)) return;
+
+  WidgetMouseEvent event(true, eMouseEnterIntoWidget, this,
+                         WidgetMouseEvent::eReal);
+
+  event.mRefPoint = GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+  LOG(("OnEnterNotify: %p\n", (void*)this));
+
+  DispatchInputEvent(&event);
+}
+
+// XXX Is this the right test for embedding cases?
+static bool is_top_level_mouse_exit(GdkWindow* aWindow,
+                                    GdkEventCrossing* aEvent) {
+  auto x = gint(aEvent->x_root);
+  auto y = gint(aEvent->y_root);
+  GdkDisplay* display = gdk_window_get_display(aWindow);
+  GdkWindow* winAtPt = gdk_display_get_window_at_pointer(display, &x, &y);
+  if (!winAtPt) return true;
+  GdkWindow* topLevelAtPt = gdk_window_get_toplevel(winAtPt);
+  GdkWindow* topLevelWidget = gdk_window_get_toplevel(aWindow);
+  return topLevelAtPt != topLevelWidget;
+}
+
+void nsWindow::OnLeaveNotifyEvent(GdkEventCrossing* aEvent) {
+  // This ignores NotifyVirtual and NotifyNonlinearVirtual leave notify
+  // events when the pointer leaves a child window.  If the destination
+  // window is a Gecko window then we'll catch the corresponding event on
+  // that window.
+  //
+  // XXXkt However, we will miss toplevel exits when the pointer directly
+  // leaves a foreign (plugin) child window without passing over a visible
+  // portion of a Gecko window.
+  if (aEvent->subwindow != nullptr) return;
+
+  WidgetMouseEvent event(true, eMouseExitFromWidget, this,
+                         WidgetMouseEvent::eReal);
+
+  event.mRefPoint = GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+  event.mExitFrom = Some(is_top_level_mouse_exit(mGdkWindow, aEvent)
+                             ? WidgetMouseEvent::eTopLevel
+                             : WidgetMouseEvent::eChild);
+
+  LOG(("OnLeaveNotify: %p\n", (void*)this));
+
+  DispatchInputEvent(&event);
+}
+
+template <typename Event>
+static LayoutDeviceIntPoint GetRefPoint(nsWindow* aWindow, Event* aEvent) {
+  if (aEvent->window == aWindow->GetGdkWindow()) {
+    // we are the window that the event happened on so no need for expensive
+    // WidgetToScreenOffset
+    return aWindow->GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  }
+  // XXX we're never quite sure which GdkWindow the event came from due to our
+  // custom bubbling in scroll_event_cb(), so use ScreenToWidget to translate
+  // the screen root coordinates into coordinates relative to this widget.
+  return aWindow->GdkEventCoordsToDevicePixels(aEvent->x_root, aEvent->y_root) -
+         aWindow->WidgetToScreenOffset();
+}
+
+void nsWindow::OnMotionNotifyEvent(GdkEventMotion* aEvent) {
+  if (mWindowShouldStartDragging) {
+    mWindowShouldStartDragging = false;
+    // find the top-level window
+    GdkWindow* gdk_window = gdk_window_get_toplevel(mGdkWindow);
+    MOZ_ASSERT(gdk_window, "gdk_window_get_toplevel should not return null");
+
+    bool canDrag = true;
+#ifdef MOZ_X11
+    if (mIsX11Display) {
+      // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
+      // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
+      // See _should_perform_ewmh_drag() at gdkwindow-x11.c
+      GdkScreen* screen = gdk_window_get_screen(gdk_window);
+      GdkAtom atom = gdk_atom_intern("_NET_WM_MOVERESIZE", FALSE);
+      if (!gdk_x11_screen_supports_net_wm_hint(screen, atom)) {
+        canDrag = false;
+      }
+    }
+#endif
+
+    if (canDrag) {
+      gdk_window_begin_move_drag(gdk_window, 1, aEvent->x_root, aEvent->y_root,
+                                 aEvent->time);
+      return;
+    }
+  }
+
+  // see if we can compress this event
+  // XXXldb Why skip every other motion event when we have multiple,
+  // but not more than that?
+  bool synthEvent = false;
+#ifdef MOZ_X11
+  XEvent xevent;
+
+  if (mIsX11Display) {
+    while (XPending(GDK_WINDOW_XDISPLAY(aEvent->window))) {
+      XEvent peeked;
+      XPeekEvent(GDK_WINDOW_XDISPLAY(aEvent->window), &peeked);
+      if (peeked.xany.window != gdk_x11_window_get_xid(aEvent->window) ||
+          peeked.type != MotionNotify)
+        break;
+
+      synthEvent = true;
+      XNextEvent(GDK_WINDOW_XDISPLAY(aEvent->window), &xevent);
+    }
+  }
+#endif /* MOZ_X11 */
+
+  WidgetMouseEvent event(true, eMouseMove, this, WidgetMouseEvent::eReal);
+
+  gdouble pressure = 0;
+  gdk_event_get_axis((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+  // Sometime gdk generate 0 pressure value between normal values
+  // We have to ignore that and use last valid value
+  if (pressure) mLastMotionPressure = pressure;
+  event.mPressure = mLastMotionPressure;
+
+  guint modifierState;
+  if (synthEvent) {
+#ifdef MOZ_X11
+    event.mRefPoint.x = nscoord(xevent.xmotion.x);
+    event.mRefPoint.y = nscoord(xevent.xmotion.y);
+
+    modifierState = xevent.xmotion.state;
+
+    event.AssignEventTime(GetWidgetEventTime(xevent.xmotion.time));
+#else
+    event.mRefPoint = GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+
+    modifierState = aEvent->state;
+
+    event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+#endif /* MOZ_X11 */
+  } else {
+    event.mRefPoint = GetRefPoint(this, aEvent);
+
+    modifierState = aEvent->state;
+
+    event.AssignEventTime(GetWidgetEventTime(aEvent->time));
+  }
+
+  KeymapWrapper::InitInputEvent(event, modifierState);
+
+  DispatchInputEvent(&event);
+}
+
+// If the automatic pointer grab on ButtonPress has deactivated before
+// ButtonRelease, and the mouse button is released while the pointer is not
+// over any a Gecko window, then the ButtonRelease event will not be received.
+// (A similar situation exists when the pointer is grabbed with owner_events
+// True as the ButtonRelease may be received on a foreign [plugin] window).
+// Use this method to check for released buttons when the pointer returns to a
+// Gecko window.
+void nsWindow::DispatchMissedButtonReleases(GdkEventCrossing* aGdkEvent) {
+  guint changed = aGdkEvent->state ^ gButtonState;
+  // Only consider button releases.
+  // (Ignore button presses that occurred outside Gecko.)
+  guint released = changed & gButtonState;
+  gButtonState = aGdkEvent->state;
+
+  // Loop over each button, excluding mouse wheel buttons 4 and 5 for which
+  // GDK ignores releases.
+  for (guint buttonMask = GDK_BUTTON1_MASK; buttonMask <= GDK_BUTTON3_MASK;
+       buttonMask <<= 1) {
+    if (released & buttonMask) {
+      int16_t buttonType;
+      switch (buttonMask) {
+        case GDK_BUTTON1_MASK:
+          buttonType = MouseButton::ePrimary;
+          break;
+        case GDK_BUTTON2_MASK:
+          buttonType = MouseButton::eMiddle;
+          break;
+        default:
+          NS_ASSERTION(buttonMask == GDK_BUTTON3_MASK,
+                       "Unexpected button mask");
+          buttonType = MouseButton::eSecondary;
+      }
+
+      LOG(("Synthesized button %u release on %p\n", guint(buttonType + 1),
+           (void*)this));
+
+      // Dispatch a synthesized button up event to tell Gecko about the
+      // change in state.  This event is marked as synthesized so that
+      // it is not dispatched as a DOM event, because we don't know the
+      // position, widget, modifiers, or time/order.
+      WidgetMouseEvent synthEvent(true, eMouseUp, this,
+                                  WidgetMouseEvent::eSynthesized);
+      synthEvent.mButton = buttonType;
+      DispatchInputEvent(&synthEvent);
+    }
+  }
+}
+
+void nsWindow::InitButtonEvent(WidgetMouseEvent& aEvent,
+                               GdkEventButton* aGdkEvent) {
+  aEvent.mRefPoint = GetRefPoint(this, aGdkEvent);
+
+  guint modifierState = aGdkEvent->state;
+  // aEvent's state includes the button state from immediately before this
+  // event.  If aEvent is a mousedown or mouseup event, we need to update
+  // the button state.
+  guint buttonMask = 0;
+  switch (aGdkEvent->button) {
+    case 1:
+      buttonMask = GDK_BUTTON1_MASK;
+      break;
+    case 2:
+      buttonMask = GDK_BUTTON2_MASK;
+      break;
+    case 3:
+      buttonMask = GDK_BUTTON3_MASK;
+      break;
+  }
+  if (aGdkEvent->type == GDK_BUTTON_RELEASE) {
+    modifierState &= ~buttonMask;
+  } else {
+    modifierState |= buttonMask;
+  }
+
+  KeymapWrapper::InitInputEvent(aEvent, modifierState);
+
+  aEvent.AssignEventTime(GetWidgetEventTime(aGdkEvent->time));
+
+  switch (aGdkEvent->type) {
+    case GDK_2BUTTON_PRESS:
+      aEvent.mClickCount = 2;
+      break;
+    case GDK_3BUTTON_PRESS:
+      aEvent.mClickCount = 3;
+      break;
+      // default is one click
+    default:
+      aEvent.mClickCount = 1;
+  }
+}
+
+static guint ButtonMaskFromGDKButton(guint button) {
+  return GDK_BUTTON1_MASK << (button - 1);
+}
+
+void nsWindow::DispatchContextMenuEventFromMouseEvent(uint16_t domButton,
+                                                      GdkEventButton* aEvent) {
+  if (domButton == MouseButton::eSecondary && MOZ_LIKELY(!mIsDestroyed)) {
+    WidgetMouseEvent contextMenuEvent(true, eContextMenu, this,
+                                      WidgetMouseEvent::eReal);
+    InitButtonEvent(contextMenuEvent, aEvent);
+    contextMenuEvent.mPressure = mLastMotionPressure;
+    DispatchInputEvent(&contextMenuEvent);
+  }
+}
+
+void nsWindow::OnButtonPressEvent(GdkEventButton* aEvent) {
+  LOG(("Button %u press on %p\n", aEvent->button, (void*)this));
+
+  // If you double click in GDK, it will actually generate a second
+  // GDK_BUTTON_PRESS before sending the GDK_2BUTTON_PRESS, and this is
+  // different than the DOM spec.  GDK puts this in the queue
+  // programatically, so it's safe to assume that if there's a
+  // double click in the queue, it was generated so we can just drop
+  // this click.
+  GdkEvent* peekedEvent = gdk_event_peek();
+  if (peekedEvent) {
+    GdkEventType type = peekedEvent->any.type;
+    gdk_event_free(peekedEvent);
+    if (type == GDK_2BUTTON_PRESS || type == GDK_3BUTTON_PRESS) return;
+  }
+
+  nsWindow* containerWindow = GetContainerWindow();
+  if (!gFocusWindow && containerWindow) {
+    containerWindow->DispatchActivateEvent();
+  }
+
+  // check to see if we should rollup
+  if (CheckForRollup(aEvent->x_root, aEvent->y_root, false, false)) return;
+
+  gdouble pressure = 0;
+  gdk_event_get_axis((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+  mLastMotionPressure = pressure;
+
+  uint16_t domButton;
+  switch (aEvent->button) {
+    case 1:
+      domButton = MouseButton::ePrimary;
+      break;
+    case 2:
+      domButton = MouseButton::eMiddle;
+      break;
+    case 3:
+      domButton = MouseButton::eSecondary;
+      break;
+    // These are mapped to horizontal scroll
+    case 6:
+    case 7:
+      NS_WARNING("We're not supporting legacy horizontal scroll event");
+      return;
+    // Map buttons 8-9 to back/forward
+    case 8:
+      if (!Preferences::GetBool("mousebutton.4th.enabled", true)) {
+        return;
+      }
+      DispatchCommandEvent(nsGkAtoms::Back);
+      return;
+    case 9:
+      if (!Preferences::GetBool("mousebutton.5th.enabled", true)) {
+        return;
+      }
+      DispatchCommandEvent(nsGkAtoms::Forward);
+      return;
+    default:
+      return;
+  }
+
+  gButtonState |= ButtonMaskFromGDKButton(aEvent->button);
+
+  WidgetMouseEvent event(true, eMouseDown, this, WidgetMouseEvent::eReal);
+  event.mButton = domButton;
+  InitButtonEvent(event, aEvent);
+  event.mPressure = mLastMotionPressure;
+
+  nsEventStatus eventStatus = DispatchInputEvent(&event);
+
+  LayoutDeviceIntPoint refPoint =
+      GdkEventCoordsToDevicePixels(aEvent->x, aEvent->y);
+  if (mDraggableRegion.Contains(refPoint.x, refPoint.y) &&
+      domButton == MouseButton::ePrimary &&
+      eventStatus != nsEventStatus_eConsumeNoDefault) {
+    mWindowShouldStartDragging = true;
+  }
+
+  // right menu click on linux should also pop up a context menu
+  if (!StaticPrefs::ui_context_menus_after_mouseup()) {
+    DispatchContextMenuEventFromMouseEvent(domButton, aEvent);
+  }
+}
+
+void nsWindow::OnButtonReleaseEvent(GdkEventButton* aEvent) {
+  LOG(("Button %u release on %p\n", aEvent->button, (void*)this));
+
+  if (mWindowShouldStartDragging) {
+    mWindowShouldStartDragging = false;
+  }
+
+  uint16_t domButton;
+  switch (aEvent->button) {
+    case 1:
+      domButton = MouseButton::ePrimary;
+      break;
+    case 2:
+      domButton = MouseButton::eMiddle;
+      break;
+    case 3:
+      domButton = MouseButton::eSecondary;
+      break;
+    default:
+      return;
+  }
+
+  gButtonState &= ~ButtonMaskFromGDKButton(aEvent->button);
+
+  WidgetMouseEvent event(true, eMouseUp, this, WidgetMouseEvent::eReal);
+  event.mButton = domButton;
+  InitButtonEvent(event, aEvent);
+  gdouble pressure = 0;
+  gdk_event_get_axis((GdkEvent*)aEvent, GDK_AXIS_PRESSURE, &pressure);
+  event.mPressure = pressure ? pressure : mLastMotionPressure;
+
+  // The mRefPoint is manipulated in DispatchInputEvent, we're saving it
+  // to use it for the doubleclick position check.
+  LayoutDeviceIntPoint pos = event.mRefPoint;
+
+  nsEventStatus eventStatus = DispatchInputEvent(&event);
+
+  bool defaultPrevented = (eventStatus == nsEventStatus_eConsumeNoDefault);
+  // Check if mouse position in titlebar and doubleclick happened to
+  // trigger restore/maximize.
+  if (!defaultPrevented && mDrawInTitlebar &&
+      event.mButton == MouseButton::ePrimary && event.mClickCount == 2 &&
+      mDraggableRegion.Contains(pos.x, pos.y)) {
+    if (mSizeState == nsSizeMode_Maximized) {
+      SetSizeMode(nsSizeMode_Normal);
+    } else {
+      SetSizeMode(nsSizeMode_Maximized);
+    }
+  }
+  mLastMotionPressure = pressure;
+
+  // right menu click on linux should also pop up a context menu
+  if (StaticPrefs::ui_context_menus_after_mouseup()) {
+    DispatchContextMenuEventFromMouseEvent(domButton, aEvent);
+  }
+
+  // Open window manager menu on PIP window to allow user
+  // to place it on top / all workspaces.
+  if (mIsPIPWindow && aEvent->button == 3) {
+    static auto sGdkWindowShowWindowMenu =
+        (gboolean(*)(GdkWindow * window, GdkEvent*))
+            dlsym(RTLD_DEFAULT, "gdk_window_show_window_menu");
+    if (sGdkWindowShowWindowMenu) {
+      sGdkWindowShowWindowMenu(mGdkWindow, (GdkEvent*)aEvent);
+    }
+  }
+}
+
+void nsWindow::OnContainerFocusInEvent(GdkEventFocus* aEvent) {
+  LOGFOCUS(("OnContainerFocusInEvent [%p]\n", (void*)this));
+
+  // Unset the urgency hint, if possible
+  GtkWidget* top_window = GetToplevelWidget();
+  if (top_window && (gtk_widget_get_visible(top_window)))
+    SetUrgencyHint(top_window, false);
+
+  // Return if being called within SetFocus because the focus manager
+  // already knows that the window is active.
+  if (gBlockActivateEvent) {
+    LOGFOCUS(("activated notification is blocked [%p]\n", (void*)this));
+    return;
+  }
+
+  // If keyboard input will be accepted, the focus manager will call
+  // SetFocus to set the correct window.
+  gFocusWindow = nullptr;
+
+  DispatchActivateEvent();
+
+  if (!gFocusWindow) {
+    // We don't really have a window for dispatching key events, but
+    // setting a non-nullptr value here prevents OnButtonPressEvent() from
+    // dispatching an activation notification if the widget is already
+    // active.
+    gFocusWindow = this;
+  }
+
+  LOGFOCUS(("Events sent from focus in event [%p]\n", (void*)this));
+}
+
+void nsWindow::OnContainerFocusOutEvent(GdkEventFocus* aEvent) {
+  LOGFOCUS(("OnContainerFocusOutEvent [%p]\n", (void*)this));
+
+  if (mWindowType == eWindowType_toplevel ||
+      mWindowType == eWindowType_dialog) {
+    nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
+    nsCOMPtr<nsIDragSession> dragSession;
+    dragService->GetCurrentSession(getter_AddRefs(dragSession));
+
+    // Rollup popups when a window is focused out unless a drag is occurring.
+    // This check is because drags grab the keyboard and cause a focus out on
+    // versions of GTK before 2.18.
+    bool shouldRollup = !dragSession;
+    if (!shouldRollup) {
+      // we also roll up when a drag is from a different application
+      nsCOMPtr<nsINode> sourceNode;
+      dragSession->GetSourceNode(getter_AddRefs(sourceNode));
+      shouldRollup = (sourceNode == nullptr);
+    }
+
+    if (shouldRollup) {
+      CheckForRollup(0, 0, false, true);
+    }
+  }
+
+  if (gFocusWindow) {
+    RefPtr<nsWindow> kungFuDeathGrip = gFocusWindow;
+    if (gFocusWindow->mIMContext) {
+      gFocusWindow->mIMContext->OnBlurWindow(gFocusWindow);
+    }
+    gFocusWindow = nullptr;
+  }
+
+  DispatchDeactivateEvent();
+
+  if (IsChromeWindowTitlebar()) {
+    // DispatchDeactivateEvent() ultimately results in a call to
+    // BrowsingContext::SetIsActiveBrowserWindow(), which resets
+    // the state.  We call UpdateMozWindowActive() to keep it in
+    // sync with GDK_WINDOW_STATE_FOCUSED.
+    UpdateMozWindowActive();
+  }
+
+  LOGFOCUS(("Done with container focus out [%p]\n", (void*)this));
+}
+
+bool nsWindow::DispatchCommandEvent(nsAtom* aCommand) {
+  nsEventStatus status;
+  WidgetCommandEvent appCommandEvent(true, aCommand, this);
+  DispatchEvent(&appCommandEvent, status);
+  return TRUE;
+}
+
+bool nsWindow::DispatchContentCommandEvent(EventMessage aMsg) {
+  nsEventStatus status;
+  WidgetContentCommandEvent event(true, aMsg, this);
+  DispatchEvent(&event, status);
+  return TRUE;
+}
+
+WidgetEventTime nsWindow::GetWidgetEventTime(guint32 aEventTime) {
+  return WidgetEventTime(aEventTime, GetEventTimeStamp(aEventTime));
+}
+
+TimeStamp nsWindow::GetEventTimeStamp(guint32 aEventTime) {
+  if (MOZ_UNLIKELY(!mGdkWindow)) {
+    // nsWindow has been Destroy()ed.
+    return TimeStamp::Now();
+  }
+  if (aEventTime == 0) {
+    // Some X11 and GDK events may be received with a time of 0 to indicate
+    // that they are synthetic events. Some input method editors do this.
+    // In this case too, just return the current timestamp.
+    return TimeStamp::Now();
+  }
+
+  TimeStamp eventTimeStamp;
+
+  if (!mIsX11Display) {
+    // Wayland compositors use monotonic time to set timestamps.
+    int64_t timestampTime = g_get_monotonic_time() / 1000;
+    guint32 refTimeTruncated = guint32(timestampTime);
+
+    timestampTime -= refTimeTruncated - aEventTime;
+    int64_t tick =
+        BaseTimeDurationPlatformUtils::TicksFromMilliseconds(timestampTime);
+    eventTimeStamp = TimeStamp::FromSystemTime(tick);
+  } else {
+#ifdef MOZ_X11
+    CurrentX11TimeGetter* getCurrentTime = GetCurrentTimeGetter();
+    MOZ_ASSERT(getCurrentTime,
+               "Null current time getter despite having a window");
+    eventTimeStamp =
+        TimeConverter().GetTimeStampFromSystemTime(aEventTime, *getCurrentTime);
+#endif
+  }
+  return eventTimeStamp;
+}
+
+#ifdef MOZ_X11
+mozilla::CurrentX11TimeGetter* nsWindow::GetCurrentTimeGetter() {
+  MOZ_ASSERT(mGdkWindow, "Expected mGdkWindow to be set");
+  if (MOZ_UNLIKELY(!mCurrentTimeGetter)) {
+    mCurrentTimeGetter = MakeUnique<CurrentX11TimeGetter>(mGdkWindow);
+  }
+  return mCurrentTimeGetter.get();
+}
+#endif
+
+gboolean nsWindow::OnKeyPressEvent(GdkEventKey* aEvent) {
+  LOGFOCUS(("OnKeyPressEvent [%p]\n", (void*)this));
+
+  RefPtr<nsWindow> self(this);
+  KeymapWrapper::HandleKeyPressEvent(self, aEvent);
+  return TRUE;
+}
+
+gboolean nsWindow::OnKeyReleaseEvent(GdkEventKey* aEvent) {
+  LOGFOCUS(("OnKeyReleaseEvent [%p]\n", (void*)this));
+
+  RefPtr<nsWindow> self(this);
+  if (NS_WARN_IF(!KeymapWrapper::HandleKeyReleaseEvent(self, aEvent))) {
+    return FALSE;
+  }
+  return TRUE;
+}
+
+void nsWindow::OnScrollEvent(GdkEventScroll* aEvent) {
+  // check to see if we should rollup
+  if (CheckForRollup(aEvent->x_root, aEvent->y_root, true, false)) return;
+  // check for duplicate legacy scroll event, see GNOME bug 726878
+  if (aEvent->direction != GDK_SCROLL_SMOOTH &&
+      mLastScrollEventTime == aEvent->time) {
+    LOG(("[%d] duplicate legacy scroll event %d\n", aEvent->time,
+         aEvent->direction));
+    return;
+  }
+  WidgetWheelEvent wheelEvent(true, eWheel, this);
+  wheelEvent.mDeltaMode = dom::WheelEvent_Binding::DOM_DELTA_LINE;
+  switch (aEvent->direction) {
+    case GDK_SCROLL_SMOOTH: {
+      // As of GTK 3.4, all directional scroll events are provided by
+      // the GDK_SCROLL_SMOOTH direction on XInput2 and Wayland devices.
+      mLastScrollEventTime = aEvent->time;
+
+      // Special handling for touchpads to support flings
+      // (also known as kinetic/inertial/momentum scrolling)
+      GdkDevice* device = gdk_event_get_source_device((GdkEvent*)aEvent);
+      GdkInputSource source = gdk_device_get_source(device);
+      if (source == GDK_SOURCE_TOUCHSCREEN || source == GDK_SOURCE_TOUCHPAD) {
+        if (StaticPrefs::apz_gtk_kinetic_scroll_enabled() &&
+            gtk_check_version(3, 20, 0) == nullptr) {
+          static auto sGdkEventIsScrollStopEvent =
+              (gboolean(*)(const GdkEvent*))dlsym(
+                  RTLD_DEFAULT, "gdk_event_is_scroll_stop_event");
+
+          LOG(("[%d] pan smooth event dx=%f dy=%f inprogress=%d\n",
+               aEvent->time, aEvent->delta_x, aEvent->delta_y, mPanInProgress));
+          PanGestureInput::PanGestureType eventType =
+              PanGestureInput::PANGESTURE_PAN;
+          if (sGdkEventIsScrollStopEvent((GdkEvent*)aEvent)) {
+            eventType = PanGestureInput::PANGESTURE_END;
+            mPanInProgress = false;
+          } else if (!mPanInProgress) {
+            eventType = PanGestureInput::PANGESTURE_START;
+            mPanInProgress = true;
+          }
+
+          LayoutDeviceIntPoint touchPoint = GetRefPoint(this, aEvent);
+          PanGestureInput panEvent(
+              eventType, aEvent->time, GetEventTimeStamp(aEvent->time),
+              ScreenPoint(touchPoint.x, touchPoint.y),
+              ScreenPoint(aEvent->delta_x, aEvent->delta_y),
+              KeymapWrapper::ComputeKeyModifiers(aEvent->state));
+          panEvent.mDeltaType = PanGestureInput::PANDELTA_PAGE;
+          panEvent.mSimulateMomentum = true;
+
+          DispatchPanGestureInput(panEvent);
+
+          return;
+        }
+
+        // Older GTK doesn't support stop events, so we can't support fling
+        wheelEvent.mScrollType = WidgetWheelEvent::SCROLL_ASYNCHRONOUSELY;
+      }
+
+      // TODO - use a more appropriate scrolling unit than lines.
+      // Multiply event deltas by 3 to emulate legacy behaviour.
+      wheelEvent.mDeltaX = aEvent->delta_x * 3;
+      wheelEvent.mDeltaY = aEvent->delta_y * 3;
+      wheelEvent.mIsNoLineOrPageDelta = true;
+
+      break;
+    }
+    case GDK_SCROLL_UP:
+      wheelEvent.mDeltaY = wheelEvent.mLineOrPageDeltaY = -3;
+      break;
+    case GDK_SCROLL_DOWN:
+      wheelEvent.mDeltaY = wheelEvent.mLineOrPageDeltaY = 3;
+      break;
+    case GDK_SCROLL_LEFT:
+      wheelEvent.mDeltaX = wheelEvent.mLineOrPageDeltaX = -1;
+      break;
+    case GDK_SCROLL_RIGHT:
+      wheelEvent.mDeltaX = wheelEvent.mLineOrPageDeltaX = 1;
+      break;
+  }
+
+  wheelEvent.mRefPoint = GetRefPoint(this, aEvent);
+
+  KeymapWrapper::InitInputEvent(wheelEvent, aEvent->state);
+
+  wheelEvent.AssignEventTime(GetWidgetEventTime(aEvent->time));
+
+  DispatchInputEvent(&wheelEvent);
+}
+
+void nsWindow::OnWindowStateEvent(GtkWidget* aWidget,
+                                  GdkEventWindowState* aEvent) {
+  LOG(
+      ("nsWindow::OnWindowStateEvent [%p] for %p changed 0x%x new_window_state "
+       "0x%x\n",
+       (void*)this, aWidget, aEvent->changed_mask, aEvent->new_window_state));
+
+  if (IS_MOZ_CONTAINER(aWidget)) {
+    // This event is notifying the container widget of changes to the
+    // toplevel window.  Just detect changes affecting whether windows are
+    // viewable.
+    //
+    // (A visibility notify event is sent to each window that becomes
+    // viewable when the toplevel is mapped, but we can't rely on that for
+    // setting mHasMappedToplevel because these toplevel window state
+    // events are asynchronous.  The windows in the hierarchy now may not
+    // be the same windows as when the toplevel was mapped, so they may
+    // not get VisibilityNotify events.)
+    bool mapped = !(aEvent->new_window_state &
+                    (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_WITHDRAWN));
+    if (mHasMappedToplevel != mapped) {
+      SetHasMappedToplevel(mapped);
+    }
+    LOG(("\tquick return because IS_MOZ_CONTAINER(aWidget) is true\n"));
+    return;
+  }
+  // else the widget is a shell widget.
+
+  // The block below is a bit evil.
+  //
+  // When a window is resized before it is shown, gtk_window_resize() delays
+  // resizes until the window is shown.  If gtk_window_state_event() sees a
+  // GDK_WINDOW_STATE_MAXIMIZED change [1] before the window is shown, then
+  // gtk_window_compute_configure_request_size() ignores the values from the
+  // resize [2].  See bug 1449166 for an example of how this could happen.
+  //
+  // [1] https://gitlab.gnome.org/GNOME/gtk/blob/3.22.30/gtk/gtkwindow.c#L7967
+  // [2] https://gitlab.gnome.org/GNOME/gtk/blob/3.22.30/gtk/gtkwindow.c#L9377
+  //
+  // In order to provide a sensible size for the window when the user exits
+  // maximized state, we hide the GDK_WINDOW_STATE_MAXIMIZED change from
+  // gtk_window_state_event() so as to trick GTK into using the values from
+  // gtk_window_resize() in its configure request.
+  //
+  // We instead notify gtk_window_state_event() of the maximized state change
+  // once the window is shown.
+  //
+  // See https://gitlab.gnome.org/GNOME/gtk/issues/1044
+  //
+  // This may be fixed in Gtk 3.24+ but some DE still have this issue
+  // (Bug 1624199) so let's remove it for Wayland only.
+#ifdef MOZ_X11
+  if (mIsX11Display) {
+    if (!mIsShown) {
+      aEvent->changed_mask = static_cast<GdkWindowState>(
+          aEvent->changed_mask & ~GDK_WINDOW_STATE_MAXIMIZED);
+    } else if (aEvent->changed_mask & GDK_WINDOW_STATE_WITHDRAWN &&
+               aEvent->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
+      aEvent->changed_mask = static_cast<GdkWindowState>(
+          aEvent->changed_mask | GDK_WINDOW_STATE_MAXIMIZED);
+    }
+  }
+#endif
+
+  // This is a workaround for https://gitlab.gnome.org/GNOME/gtk/issues/1395
+  // Gtk+ controls window active appearance by window-state-event signal.
+  if (IsChromeWindowTitlebar() &&
+      (aEvent->changed_mask & GDK_WINDOW_STATE_FOCUSED)) {
+    // Emulate what Gtk+ does at gtk_window_state_event().
+    // We can't check GTK_STATE_FLAG_BACKDROP directly as it's set by Gtk+
+    // *after* this window-state-event handler.
+    mTitlebarBackdropState =
+        !(aEvent->new_window_state & GDK_WINDOW_STATE_FOCUSED);
+
+    // keep IsActiveBrowserWindow in sync with GDK_WINDOW_STATE_FOCUSED
+    UpdateMozWindowActive();
+
+    ForceTitlebarRedraw();
+  }
+
+  // We don't care about anything but changes in the maximized/icon/fullscreen
+  // states but we need a workaround for bug in Wayland:
+  // https://gitlab.gnome.org/GNOME/gtk/issues/67
+  // Under wayland the gtk_window_iconify implementation does NOT synthetize
+  // window_state_event where the GDK_WINDOW_STATE_ICONIFIED is set.
+  // During restore we  won't get aEvent->changed_mask with
+  // the GDK_WINDOW_STATE_ICONIFIED so to detect that change we use the stored
+  // mSizeState and obtaining a focus.
+  bool waylandWasIconified =
+      (!mIsX11Display && aEvent->changed_mask & GDK_WINDOW_STATE_FOCUSED &&
+       aEvent->new_window_state & GDK_WINDOW_STATE_FOCUSED &&
+       mSizeState == nsSizeMode_Minimized);
+  if (!waylandWasIconified &&
+      (aEvent->changed_mask &
+       (GDK_WINDOW_STATE_ICONIFIED | GDK_WINDOW_STATE_MAXIMIZED |
+        GDK_WINDOW_STATE_TILED | GDK_WINDOW_STATE_FULLSCREEN)) == 0) {
+    LOG(("\tearly return because no interesting bits changed\n"));
+    return;
+  }
+
+  if (aEvent->new_window_state & GDK_WINDOW_STATE_ICONIFIED) {
+    LOG(("\tIconified\n"));
+    mSizeState = nsSizeMode_Minimized;
+#ifdef ACCESSIBILITY
+    DispatchMinimizeEventAccessible();
+#endif  // ACCESSIBILITY
+  } else if (aEvent->new_window_state & GDK_WINDOW_STATE_FULLSCREEN) {
+    LOG(("\tFullscreen\n"));
+    mSizeState = nsSizeMode_Fullscreen;
+  } else if (aEvent->new_window_state & GDK_WINDOW_STATE_MAXIMIZED) {
+    LOG(("\tMaximized\n"));
+    mSizeState = nsSizeMode_Maximized;
+#ifdef ACCESSIBILITY
+    DispatchMaximizeEventAccessible();
+#endif  // ACCESSIBILITY
+  } else {
+    LOG(("\tNormal\n"));
+    mSizeState = nsSizeMode_Normal;
+#ifdef ACCESSIBILITY
+    DispatchRestoreEventAccessible();
+#endif  // ACCESSIBILITY
+  }
+
+  if (aEvent->new_window_state & GDK_WINDOW_STATE_TILED) {
+    LOG(("\tTiled\n"));
+    mIsTiled = true;
+  } else {
+    LOG(("\tNot tiled\n"));
+    mIsTiled = false;
+  }
+
+  if (mWidgetListener) {
+    mWidgetListener->SizeModeChanged(mSizeState);
+    if (aEvent->changed_mask & GDK_WINDOW_STATE_FULLSCREEN) {
+      mWidgetListener->FullscreenChanged(aEvent->new_window_state &
+                                         GDK_WINDOW_STATE_FULLSCREEN);
+    }
+  }
+
+  if (mDrawInTitlebar && mTransparencyBitmapForTitlebar) {
+    if (mSizeState == nsSizeMode_Normal && !mIsTiled) {
+      UpdateTitlebarTransparencyBitmap();
+    } else {
+      ClearTransparencyBitmap();
+    }
+  }
+}
+
+void nsWindow::ThemeChanged() {
+  // Everything could've changed.
+  NotifyThemeChanged(ThemeChangeKind::StyleAndLayout);
+
+  if (!mGdkWindow || MOZ_UNLIKELY(mIsDestroyed)) return;
+
+  // Dispatch theme change notification to all child windows
+  GList* children = gdk_window_peek_children(mGdkWindow);
+  while (children) {
+    GdkWindow* gdkWin = GDK_WINDOW(children->data);
+
+    auto* win = (nsWindow*)g_object_get_data(G_OBJECT(gdkWin), "nsWindow");
+
+    if (win && win != this) {  // guard against infinite recursion
+      RefPtr<nsWindow> kungFuDeathGrip = win;
+      win->ThemeChanged();
+    }
+
+    children = children->next;
+  }
+
+  IMContextWrapper::OnThemeChanged();
+}
+
+void nsWindow::OnDPIChanged() {
+  if (mWidgetListener) {
+    if (PresShell* presShell = mWidgetListener->GetPresShell()) {
+      presShell->BackingScaleFactorChanged();
+      // Update menu's font size etc.
+      // This affects style / layout because it affects system font sizes.
+      presShell->ThemeChanged(ThemeChangeKind::StyleAndLayout);
+    }
+    mWidgetListener->UIResolutionChanged();
+  }
+}
+
+void nsWindow::OnCheckResize() { mPendingConfigures++; }
+
+void nsWindow::OnCompositedChanged() {
+  // Update CSD after the change in alpha visibility. This only affects
+  // system metrics, not other theme shenanigans.
+  NotifyThemeChanged(ThemeChangeKind::MediaQueriesOnly);
+  mCompositedScreen = gdk_screen_is_composited(gdk_screen_get_default());
+}
+
+void nsWindow::OnScaleChanged(GtkAllocation* aAllocation) {
+  LOG(("nsWindow::OnScaleChanged [%p] %d,%d -> %d x %d\n", (void*)this,
+       aAllocation->x, aAllocation->y, aAllocation->width,
+       aAllocation->height));
+
+  // Force scale factor recalculation
+  mWindowScaleFactorChanged = true;
+
+  // This eventually propagate new scale to the PuppetWidgets
+  OnDPIChanged();
+
+  // configure_event is already fired before scale-factor signal,
+  // but size-allocate isn't fired by changing scale
+  OnSizeAllocate(aAllocation);
+
+  // Client offset are updated by _NET_FRAME_EXTENTS on X11 when system titlebar
+  // is enabled. In ither cases (Wayland or system titlebar is off on X11)
+  // we don't get _NET_FRAME_EXTENTS X11 property notification so we derive
+  // it from mContainer position.
+  if (mCSDSupportLevel == CSD_SUPPORT_CLIENT) {
+    if (!mIsX11Display || (mIsX11Display && mDrawInTitlebar)) {
+      UpdateClientOffsetFromCSDWindow();
+    }
+  }
+
+#ifdef MOZ_WAYLAND
+  // We need to update scale when scale of egl window is changed.
+  if (mContainer && moz_container_wayland_has_egl_window(mContainer)) {
+    moz_container_wayland_set_scale_factor(mContainer);
+  }
+#endif
+}
+
+void nsWindow::DispatchDragEvent(EventMessage aMsg,
+                                 const LayoutDeviceIntPoint& aRefPoint,
+                                 guint aTime) {
+  WidgetDragEvent event(true, aMsg, this);
+
+  InitDragEvent(event);
+
+  event.mRefPoint = aRefPoint;
+  event.AssignEventTime(GetWidgetEventTime(aTime));
+
+  DispatchInputEvent(&event);
+}
+
+void nsWindow::OnDragDataReceivedEvent(GtkWidget* aWidget,
+                                       GdkDragContext* aDragContext, gint aX,
+                                       gint aY,
+                                       GtkSelectionData* aSelectionData,
+                                       guint aInfo, guint aTime,
+                                       gpointer aData) {
+  LOGDRAG(("nsWindow::OnDragDataReceived(%p)\n", (void*)this));
+
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  dragService->TargetDataReceived(aWidget, aDragContext, aX, aY, aSelectionData,
+                                  aInfo, aTime);
+}
+
+nsWindow* nsWindow::GetTransientForWindowIfPopup() {
+  if (mWindowType != eWindowType_popup) {
+    return nullptr;
+  }
+  GtkWindow* toplevel = gtk_window_get_transient_for(GTK_WINDOW(mShell));
+  if (toplevel) {
+    return get_window_for_gtk_widget(GTK_WIDGET(toplevel));
+  }
+  return nullptr;
+}
+
+bool nsWindow::IsHandlingTouchSequence(GdkEventSequence* aSequence) {
+  return mHandleTouchEvent && mTouches.Contains(aSequence);
+}
+
+gboolean nsWindow::OnTouchEvent(GdkEventTouch* aEvent) {
+  if (!mHandleTouchEvent) {
+    // If a popup window was spawned (e.g. as the result of a long-press)
+    // and touch events got diverted to that window within a touch sequence,
+    // ensure the touch event gets sent to the original window instead. We
+    // keep the checks here very conservative so that we only redirect
+    // events in this specific scenario.
+    nsWindow* targetWindow = GetTransientForWindowIfPopup();
+    if (targetWindow &&
+        targetWindow->IsHandlingTouchSequence(aEvent->sequence)) {
+      return targetWindow->OnTouchEvent(aEvent);
+    }
+
+    return FALSE;
+  }
+
+  EventMessage msg;
+  switch (aEvent->type) {
+    case GDK_TOUCH_BEGIN:
+      msg = eTouchStart;
+      break;
+    case GDK_TOUCH_UPDATE:
+      msg = eTouchMove;
+      break;
+    case GDK_TOUCH_END:
+      msg = eTouchEnd;
+      break;
+    case GDK_TOUCH_CANCEL:
+      msg = eTouchCancel;
+      break;
+    default:
+      return FALSE;
+  }
+
+  LayoutDeviceIntPoint touchPoint = GetRefPoint(this, aEvent);
+
+  int32_t id;
+  RefPtr<dom::Touch> touch;
+  if (mTouches.Remove(aEvent->sequence, getter_AddRefs(touch))) {
+    id = touch->mIdentifier;
+  } else {
+    id = ++gLastTouchID & 0x7FFFFFFF;
+  }
+
+  touch =
+      new dom::Touch(id, touchPoint, LayoutDeviceIntPoint(1, 1), 0.0f, 0.0f);
+
+  WidgetTouchEvent event(true, msg, this);
+  KeymapWrapper::InitInputEvent(event, aEvent->state);
+  event.mTime = aEvent->time;
+
+  if (aEvent->type == GDK_TOUCH_BEGIN || aEvent->type == GDK_TOUCH_UPDATE) {
+    mTouches.Put(aEvent->sequence, std::move(touch));
+    // add all touch points to event object
+    for (auto iter = mTouches.Iter(); !iter.Done(); iter.Next()) {
+      event.mTouches.AppendElement(new dom::Touch(*iter.UserData()));
+    }
+  } else if (aEvent->type == GDK_TOUCH_END ||
+             aEvent->type == GDK_TOUCH_CANCEL) {
+    *event.mTouches.AppendElement() = std::move(touch);
+  }
+
+  DispatchInputEvent(&event);
+  return TRUE;
+}
+
+// Return true if toplevel window is transparent.
+// It's transparent when we're running on composited screens
+// and we can draw main window without system titlebar.
+bool nsWindow::IsToplevelWindowTransparent() {
+  static bool transparencyConfigured = false;
+
+  if (!transparencyConfigured) {
+    if (gdk_screen_is_composited(gdk_screen_get_default())) {
+      // Some Gtk+ themes use non-rectangular toplevel windows. To fully
+      // support such themes we need to make toplevel window transparent
+      // with ARGB visual.
+      // It may cause performanance issue so make it configurable
+      // and enable it by default for selected window managers.
+      if (Preferences::HasUserValue("mozilla.widget.use-argb-visuals")) {
+        // argb visual is explicitly required so use it
+        sTransparentMainWindow =
+            Preferences::GetBool("mozilla.widget.use-argb-visuals");
+      } else {
+        // Enable transparent toplevel window if we can draw main window
+        // without system titlebar as Gtk+ themes use titlebar round corners.
+        sTransparentMainWindow = GetSystemCSDSupportLevel() != CSD_SUPPORT_NONE;
+      }
+    }
+    transparencyConfigured = true;
+  }
+
+  return sTransparentMainWindow;
+}
+
+static GdkWindow* CreateGdkWindow(GdkWindow* parent, GtkWidget* widget) {
+  GdkWindowAttr attributes;
+  gint attributes_mask = GDK_WA_VISUAL;
+
+  attributes.event_mask = kEvents;
+
+  attributes.width = 1;
+  attributes.height = 1;
+  attributes.wclass = GDK_INPUT_OUTPUT;
+  attributes.visual = gtk_widget_get_visual(widget);
+  attributes.window_type = GDK_WINDOW_CHILD;
+
+  GdkWindow* window = gdk_window_new(parent, &attributes, attributes_mask);
+  gdk_window_set_user_data(window, widget);
+
+  return window;
+}
+
+#ifdef MOZ_X11
+// Configure GL visual on X11. We add alpha silently
+// if we use WebRender to workaround NVIDIA specific Bug 1663273.
+bool nsWindow::ConfigureX11GLVisual(bool aUseAlpha) {
+  if (!mIsX11Display) {
+    return false;
+  }
+
+  // If using WebRender on X11, we need to select a visual with a depth
+  // buffer, as well as an alpha channel if transparency is requested. This
+  // must be done before the widget is realized.
+  bool useWebRender = gfx::gfxVars::UseWebRender();
+  auto* screen = gtk_widget_get_screen(mShell);
+  int visualId = 0;
+  bool haveVisual;
+
+  // See https://bugzilla.mozilla.org/show_bug.cgi?id=1663003
+  // We need to use GLX to get visual even on EGL until
+  // EGL can provide compositable visual:
+  // https://gitlab.freedesktop.org/mesa/mesa/-/issues/149
+  if ((true /* !gfx::gfxVars::UseEGL() */)) {
+    auto* display = GDK_DISPLAY_XDISPLAY(gtk_widget_get_display(mShell));
+    int screenNumber = GDK_SCREEN_XNUMBER(screen);
+    haveVisual = GLContextGLX::FindVisual(display, screenNumber, useWebRender,
+                                          aUseAlpha || useWebRender, &visualId);
+  } else {
+    haveVisual = GLContextEGL::FindVisual(useWebRender,
+                                          aUseAlpha || useWebRender, &visualId);
+  }
+
+  GdkVisual* gdkVisual = nullptr;
+  if (haveVisual) {
+    // If we're using CSD, rendering will go through mContainer, but
+    // it will inherit this visual as it is a child of mShell.
+    gdkVisual = gdk_x11_screen_lookup_visual(screen, visualId);
+  }
+  if (!gdkVisual) {
+    NS_WARNING("We're missing X11 Visual!");
+    if (aUseAlpha || useWebRender) {
+      // We try to use a fallback alpha visual
+      GdkScreen* screen = gtk_widget_get_screen(mShell);
+      gdkVisual = gdk_screen_get_rgba_visual(screen);
+    }
+  }
+  if (gdkVisual) {
+    // TODO: We use alpha visual even on non-compositing screens (Bug 1479135).
+    gtk_widget_set_visual(mShell, gdkVisual);
+    mHasAlphaVisual = aUseAlpha;
+  }
+
+  return true;
+}
+#endif
+
+nsresult nsWindow::Create(nsIWidget* aParent, nsNativeWidget aNativeParent,
+                          const LayoutDeviceIntRect& aRect,
+                          nsWidgetInitData* aInitData) {
+#ifdef MOZ_LOGGING
+  if (this->GetFrame() && this->GetFrame()->GetContent()) {
+    nsCString nodeName =
+        NS_ConvertUTF16toUTF8(this->GetFrame()->GetContent()->NodeName());
+    LOG(("nsWindow::Create: creating [%p]: nodename %s\n", this,
+         nodeName.get()));
+  }
+#endif
+  // only set the base parent if we're going to be a dialog or a
+  // toplevel
+  nsIWidget* baseParent =
+      aInitData && (aInitData->mWindowType == eWindowType_dialog ||
+                    aInitData->mWindowType == eWindowType_toplevel ||
+                    aInitData->mWindowType == eWindowType_invisible)
+          ? nullptr
+          : aParent;
+
+#ifdef ACCESSIBILITY
+  // Send a DBus message to check whether a11y is enabled
+  a11y::PreInit();
+#endif
+
+  // Ensure that the toolkit is created.
+  nsGTKToolkit::GetToolkit();
+
+  // initialize all the common bits of this class
+  BaseCreate(baseParent, aInitData);
+
+  // Do we need to listen for resizes?
+  bool listenForResizes = false;
+  ;
+  if (aNativeParent || (aInitData && aInitData->mListenForResizes))
+    listenForResizes = true;
+
+  // and do our common creation
+  CommonCreate(aParent, listenForResizes);
+
+  // save our bounds
+  mBounds = aRect;
+  LOG(("  mBounds: x:%d y:%d w:%d h:%d\n", mBounds.x, mBounds.y, mBounds.width,
+       mBounds.height));
+
+  mPreferredPopupRectFlushed = false;
+
+  ConstrainSize(&mBounds.width, &mBounds.height);
+
+  GtkWidget* eventWidget = nullptr;
+  bool popupNeedsAlphaVisual = (mWindowType == eWindowType_popup &&
+                                (aInitData && aInitData->mSupportTranslucency));
+
+  // Figure out our parent window - only used for eWindowType_child
+  GtkWidget* parentMozContainer = nullptr;
+  GtkContainer* parentGtkContainer = nullptr;
+  GdkWindow* parentGdkWindow = nullptr;
+  nsWindow* parentnsWindow = nullptr;
+
+  if (aParent) {
+    parentnsWindow = static_cast<nsWindow*>(aParent);
+    parentGdkWindow = parentnsWindow->mGdkWindow;
+  } else if (aNativeParent && GDK_IS_WINDOW(aNativeParent)) {
+    parentGdkWindow = GDK_WINDOW(aNativeParent);
+    parentnsWindow = get_window_for_gdk_window(parentGdkWindow);
+    if (!parentnsWindow) return NS_ERROR_FAILURE;
+
+  } else if (aNativeParent && GTK_IS_CONTAINER(aNativeParent)) {
+    parentGtkContainer = GTK_CONTAINER(aNativeParent);
+  }
+
+  if (parentGdkWindow) {
+    // get the widget for the window - it should be a moz container
+    parentMozContainer = parentnsWindow->GetMozContainerWidget();
+    if (!parentMozContainer) return NS_ERROR_FAILURE;
+  }
+  // ^^ only used for eWindowType_child
+
+  if (!mIsX11Display) {
+    if (mWindowType == eWindowType_child) {
+      // eWindowType_child is not supported on Wayland. Just switch to toplevel
+      // as a workaround.
+      mWindowType = eWindowType_toplevel;
+    } else if (mWindowType == eWindowType_popup && !aNativeParent && !aParent) {
+      // Workaround for Wayland where the popup windows always need to have
+      // parent window. For example webrtc ui is a popup window without parent.
+      mWindowType = eWindowType_toplevel;
+    }
+  }
+
+  mAlwaysOnTop = aInitData && aInitData->mAlwaysOnTop;
+  mIsPIPWindow = aInitData && aInitData->mPIPWindow;
+
+  // ok, create our windows
+  switch (mWindowType) {
+    case eWindowType_dialog:
+    case eWindowType_popup:
+    case eWindowType_toplevel:
+    case eWindowType_invisible: {
+      mIsTopLevel = true;
+
+      // Popups that are not noautohide are only temporary. The are used
+      // for menus and the like and disappear when another window is used.
+      // For most popups, use the standard GtkWindowType GTK_WINDOW_POPUP,
+      // which will use a Window with the override-redirect attribute
+      // (for temporary windows).
+      // For long-lived windows, their stacking order is managed by the
+      // window manager, as indicated by GTK_WINDOW_TOPLEVEL.
+      // For Wayland we have to always use GTK_WINDOW_POPUP to control
+      // popup window position.
+      GtkWindowType type = GTK_WINDOW_TOPLEVEL;
+      if (mWindowType == eWindowType_popup) {
+        type = (mIsX11Display && aInitData->mNoAutoHide) ? GTK_WINDOW_TOPLEVEL
+                                                         : GTK_WINDOW_POPUP;
+      }
+      mShell = gtk_window_new(type);
+
+      // Ensure gfxPlatform is initialized, since that is what initializes
+      // gfxVars, used below.
+      Unused << gfxPlatform::GetPlatform();
+
+      if (mWindowType == eWindowType_toplevel ||
+          mWindowType == eWindowType_dialog) {
+        bool isPopup = mIsPIPWindow || mWindowType == eWindowType_dialog;
+        mCSDSupportLevel = GetSystemCSDSupportLevel(isPopup);
+      }
+
+      // Don't use transparency for PictureInPicture windows.
+      bool toplevelNeedsAlphaVisual = false;
+      if (mWindowType == eWindowType_toplevel && !mIsPIPWindow) {
+        toplevelNeedsAlphaVisual = IsToplevelWindowTransparent();
+      }
+
+      bool isGLVisualSet = false;
+      bool isAccelerated = ComputeShouldAccelerate();
+#ifdef MOZ_X11
+      if (isAccelerated) {
+        isGLVisualSet = ConfigureX11GLVisual(popupNeedsAlphaVisual ||
+                                             toplevelNeedsAlphaVisual);
+      }
+#endif
+      if (!isGLVisualSet &&
+          (popupNeedsAlphaVisual || toplevelNeedsAlphaVisual)) {
+        // We're running on composited screen so we can use alpha visual
+        // for both toplevel and popups.
+        if (mCompositedScreen) {
+          GdkVisual* visual =
+              gdk_screen_get_rgba_visual(gtk_widget_get_screen(mShell));
+          if (visual) {
+            gtk_widget_set_visual(mShell, visual);
+            mHasAlphaVisual = true;
+          }
+        }
+      }
+
+      // Use X shape mask to draw round corners of Firefox titlebar.
+      // We don't use shape masks any more as we switched to ARGB visual
+      // by default and non-compositing screens use solid-csd decorations
+      // without round corners.
+      // Leave the shape mask code here as it can be used to draw round
+      // corners on EGL (https://gitlab.freedesktop.org/mesa/mesa/-/issues/149)
+      // or when custom titlebar theme is used.
+      mTransparencyBitmapForTitlebar = TitlebarUseShapeMask();
+
+      // We have a toplevel window with transparency.
+      // Calls to UpdateTitlebarTransparencyBitmap() from OnExposeEvent()
+      // occur before SetTransparencyMode() receives eTransparencyTransparent
+      // from layout, so set mIsTransparent here.
+      if (mWindowType == eWindowType_toplevel &&
+          (mHasAlphaVisual || mTransparencyBitmapForTitlebar)) {
+        mIsTransparent = true;
+      }
+
+      // We only move a general managed toplevel window if someone has
+      // actually placed the window somewhere.  If no placement has taken
+      // place, we just let the window manager Do The Right Thing.
+      NativeResize();
+
+      if (mWindowType == eWindowType_dialog) {
+        mGtkWindowRoleName = "Dialog";
+
+        SetDefaultIcon();
+        gtk_window_set_type_hint(GTK_WINDOW(mShell),
+                                 GDK_WINDOW_TYPE_HINT_DIALOG);
+
+        if (parentnsWindow) {
+          gtk_window_set_transient_for(
+              GTK_WINDOW(mShell), GTK_WINDOW(parentnsWindow->GetGtkWidget()));
+          LOG((
+              "nsWindow::Create(): dialog [%p], parent window %p [GdkWindow]\n",
+              this, aNativeParent));
+        }
+
+      } else if (mWindowType == eWindowType_popup) {
+        mGtkWindowRoleName = "Popup";
+
+        if (aInitData->mNoAutoHide) {
+          // ... but the window manager does not decorate this window,
+          // nor provide a separate taskbar icon.
+          if (mBorderStyle == eBorderStyle_default) {
+            gtk_window_set_decorated(GTK_WINDOW(mShell), FALSE);
+          } else {
+            bool decorate = mBorderStyle & eBorderStyle_title;
+            gtk_window_set_decorated(GTK_WINDOW(mShell), decorate);
+            if (decorate) {
+              gtk_window_set_deletable(GTK_WINDOW(mShell),
+                                       mBorderStyle & eBorderStyle_close);
+            }
+          }
+          gtk_window_set_skip_taskbar_hint(GTK_WINDOW(mShell), TRUE);
+          // Element focus is managed by the parent window so the
+          // WM_HINTS input field is set to False to tell the window
+          // manager not to set input focus to this window ...
+          gtk_window_set_accept_focus(GTK_WINDOW(mShell), FALSE);
+#ifdef MOZ_X11
+          // ... but when the window manager offers focus through
+          // WM_TAKE_FOCUS, focus is requested on the parent window.
+          if (mIsX11Display) {
+            gtk_widget_realize(mShell);
+            gdk_window_add_filter(gtk_widget_get_window(mShell),
+                                  popup_take_focus_filter, nullptr);
+          }
+#endif
+        }
+
+        GdkWindowTypeHint gtkTypeHint;
+        if (aInitData->mIsDragPopup) {
+          gtkTypeHint = GDK_WINDOW_TYPE_HINT_DND;
+          mIsDragPopup = true;
+        } else {
+          switch (aInitData->mPopupHint) {
+            case ePopupTypeMenu:
+              gtkTypeHint = GDK_WINDOW_TYPE_HINT_POPUP_MENU;
+              break;
+            case ePopupTypeTooltip:
+              gtkTypeHint = GDK_WINDOW_TYPE_HINT_TOOLTIP;
+              break;
+            default:
+              gtkTypeHint = GDK_WINDOW_TYPE_HINT_UTILITY;
+              break;
+          }
+        }
+        gtk_window_set_type_hint(GTK_WINDOW(mShell), gtkTypeHint);
+        if (parentnsWindow) {
+          LOG(("nsWindow::Create() [%p]: parent window for popup: %p\n", this,
+               parentnsWindow));
+          gtk_window_set_transient_for(
+              GTK_WINDOW(mShell), GTK_WINDOW(parentnsWindow->GetGtkWidget()));
+        }
+
+        // We need realized mShell at NativeMove().
+        gtk_widget_realize(mShell);
+
+        // With popup windows, we want to control their position, so don't
+        // wait for the window manager to place them (which wouldn't
+        // happen with override-redirect windows anyway).
+        NativeMove();
+      } else {  // must be eWindowType_toplevel
+        mGtkWindowRoleName = "Toplevel";
+        SetDefaultIcon();
+
+        if (mIsPIPWindow) {
+          gtk_window_set_type_hint(GTK_WINDOW(mShell),
+                                   GDK_WINDOW_TYPE_HINT_UTILITY);
+        }
+
+        // each toplevel window gets its own window group
+        GtkWindowGroup* group = gtk_window_group_new();
+        gtk_window_group_add_window(group, GTK_WINDOW(mShell));
+        g_object_unref(group);
+      }
+
+      if (mAlwaysOnTop) {
+        gtk_window_set_keep_above(GTK_WINDOW(mShell), TRUE);
+      }
+
+      // Create a container to hold child windows and child GtkWidgets.
+      GtkWidget* container = moz_container_new();
+      mContainer = MOZ_CONTAINER(container);
+#ifdef MOZ_WAYLAND
+      if (!mIsX11Display && isAccelerated) {
+        mCompositorInitiallyPaused = true;
+        RefPtr<nsWindow> self(this);
+        moz_container_wayland_add_initial_draw_callback(
+            mContainer, [self]() -> void {
+              self->mNeedsCompositorResume = true;
+              self->MaybeResumeCompositor();
+            });
+      }
+#endif
+
+      // "csd" style is set when widget is realized so we need to call
+      // it explicitly now.
+      gtk_widget_realize(mShell);
+
+      /* There are several cases here:
+       *
+       * 1) We're running on Gtk+ without client side decorations.
+       *    Content is rendered to mShell window and we listen
+       *    to the Gtk+ events on mShell
+       * 2) We're running on Gtk+ and client side decorations
+       *    are drawn by Gtk+ to mShell. Content is rendered to mContainer
+       *    and we listen to the Gtk+ events on mContainer.
+       * 3) We're running on Wayland. All gecko content is rendered
+       *    to mContainer and we listen to the Gtk+ events on mContainer.
+       */
+      GtkStyleContext* style = gtk_widget_get_style_context(mShell);
+      mDrawToContainer = !mIsX11Display ||
+                         (mCSDSupportLevel == CSD_SUPPORT_CLIENT) ||
+                         gtk_style_context_has_class(style, "csd");
+      eventWidget = (mDrawToContainer) ? container : mShell;
+
+      // Prevent GtkWindow from painting a background to avoid flickering.
+      gtk_widget_set_app_paintable(eventWidget, TRUE);
+
+      gtk_widget_add_events(eventWidget, kEvents);
+      if (mDrawToContainer) {
+        gtk_widget_add_events(mShell, GDK_PROPERTY_CHANGE_MASK);
+        gtk_widget_set_app_paintable(mShell, TRUE);
+      }
+      if (mTransparencyBitmapForTitlebar) {
+        moz_container_force_default_visual(mContainer);
+      }
+
+      // If we draw to mContainer window then configure it now because
+      // gtk_container_add() realizes the child widget.
+      gtk_widget_set_has_window(container, mDrawToContainer);
+
+      gtk_container_add(GTK_CONTAINER(mShell), container);
+
+      // alwaysontop windows are generally used for peripheral indicators,
+      // so we don't focus them by default.
+      if (mAlwaysOnTop) {
+        gtk_window_set_focus_on_map(GTK_WINDOW(mShell), FALSE);
+      }
+
+      gtk_widget_realize(container);
+
+      // make sure this is the focus widget in the container
+      gtk_widget_show(container);
+
+      if (!mAlwaysOnTop) {
+        gtk_widget_grab_focus(container);
+      }
+
+      // the drawing window
+      mGdkWindow = gtk_widget_get_window(eventWidget);
+
+      if (mWindowType == eWindowType_popup) {
+        // gdk does not automatically set the cursor for "temporary"
+        // windows, which are what gtk uses for popups.
+
+        mCursor = eCursor_wait;  // force SetCursor to actually set the
+                                 // cursor, even though our internal state
+                                 // indicates that we already have the
+                                 // standard cursor.
+        SetCursor(eCursor_standard, nullptr, 0, 0);
+
+        if (aInitData->mNoAutoHide) {
+          gint wmd = ConvertBorderStyles(mBorderStyle);
+          if (wmd != -1)
+            gdk_window_set_decorations(mGdkWindow, (GdkWMDecoration)wmd);
+        }
+
+        // If the popup ignores mouse events, set an empty input shape.
+        SetWindowMouseTransparent(aInitData->mMouseTransparent);
+      }
+    } break;
+
+    case eWindowType_plugin:
+    case eWindowType_plugin_ipc_chrome:
+    case eWindowType_plugin_ipc_content:
+      MOZ_ASSERT_UNREACHABLE("Unexpected eWindowType_plugin*");
+      return NS_ERROR_FAILURE;
+
+    case eWindowType_child: {
+      if (parentMozContainer) {
+        mGdkWindow = CreateGdkWindow(parentGdkWindow, parentMozContainer);
+        mHasMappedToplevel = parentnsWindow->mHasMappedToplevel;
+      } else if (parentGtkContainer) {
+        // This MozContainer has its own window for drawing and receives
+        // events because there is no mShell widget (corresponding to this
+        // nsWindow).
+        GtkWidget* container = moz_container_new();
+        mContainer = MOZ_CONTAINER(container);
+        eventWidget = container;
+        gtk_widget_add_events(eventWidget, kEvents);
+        gtk_container_add(parentGtkContainer, container);
+        gtk_widget_realize(container);
+
+        mGdkWindow = gtk_widget_get_window(container);
+      } else {
+        NS_WARNING(
+            "Warning: tried to create a new child widget with no parent!");
+        return NS_ERROR_FAILURE;
+      }
+    } break;
+    default:
+      break;
+  }
+
+  // label the drawing window with this object so we can find our way home
+  g_object_set_data(G_OBJECT(mGdkWindow), "nsWindow", this);
+  if (mDrawToContainer) {
+    // Also label mShell toplevel window,
+    // property_notify_event_cb callback also needs to find its way home
+    g_object_set_data(G_OBJECT(gtk_widget_get_window(mShell)), "nsWindow",
+                      this);
+  }
+
+  if (mContainer) g_object_set_data(G_OBJECT(mContainer), "nsWindow", this);
+
+  if (mShell) g_object_set_data(G_OBJECT(mShell), "nsWindow", this);
+
+  // attach listeners for events
+  if (mShell) {
+    g_signal_connect(mShell, "configure_event", G_CALLBACK(configure_event_cb),
+                     nullptr);
+    g_signal_connect(mShell, "delete_event", G_CALLBACK(delete_event_cb),
+                     nullptr);
+    g_signal_connect(mShell, "window_state_event",
+                     G_CALLBACK(window_state_event_cb), nullptr);
+    g_signal_connect(mShell, "check-resize", G_CALLBACK(check_resize_cb),
+                     nullptr);
+    g_signal_connect(mShell, "composited-changed",
+                     G_CALLBACK(widget_composited_changed_cb), nullptr);
+    g_signal_connect(mShell, "property-notify-event",
+                     G_CALLBACK(property_notify_event_cb), nullptr);
+
+    if (mWindowType == eWindowType_toplevel) {
+      g_signal_connect_after(mShell, "size_allocate",
+                             G_CALLBACK(toplevel_window_size_allocate_cb),
+                             nullptr);
+    }
+
+    GdkScreen* screen = gtk_widget_get_screen(mShell);
+    if (!g_signal_handler_find(screen, G_SIGNAL_MATCH_FUNC, 0, 0, nullptr,
+                               FuncToGpointer(screen_composited_changed_cb),
+                               0)) {
+      g_signal_connect(screen, "composited-changed",
+                       G_CALLBACK(screen_composited_changed_cb), nullptr);
+    }
+
+    GtkSettings* default_settings = gtk_settings_get_default();
+    g_signal_connect_after(default_settings, "notify::gtk-theme-name",
+                           G_CALLBACK(settings_changed_cb), this);
+    g_signal_connect_after(default_settings, "notify::gtk-font-name",
+                           G_CALLBACK(settings_changed_cb), this);
+    g_signal_connect_after(default_settings, "notify::gtk-enable-animations",
+                           G_CALLBACK(settings_changed_cb), this);
+    g_signal_connect_after(default_settings, "notify::gtk-decoration-layout",
+                           G_CALLBACK(settings_changed_cb), this);
+    g_signal_connect_after(default_settings, "notify::gtk-xft-dpi",
+                           G_CALLBACK(settings_xft_dpi_changed_cb), this);
+  }
+
+  if (mContainer) {
+    // Widget signals
+    g_signal_connect(mContainer, "unrealize",
+                     G_CALLBACK(container_unrealize_cb), nullptr);
+    g_signal_connect_after(mContainer, "size_allocate",
+                           G_CALLBACK(size_allocate_cb), nullptr);
+    g_signal_connect(mContainer, "hierarchy-changed",
+                     G_CALLBACK(hierarchy_changed_cb), nullptr);
+    g_signal_connect(mContainer, "notify::scale-factor",
+                     G_CALLBACK(scale_changed_cb), nullptr);
+    // Initialize mHasMappedToplevel.
+    hierarchy_changed_cb(GTK_WIDGET(mContainer), nullptr);
+    // Expose, focus, key, and drag events are sent even to GTK_NO_WINDOW
+    // widgets.
+    g_signal_connect(G_OBJECT(mContainer), "draw", G_CALLBACK(expose_event_cb),
+                     nullptr);
+    g_signal_connect(mContainer, "focus_in_event",
+                     G_CALLBACK(focus_in_event_cb), nullptr);
+    g_signal_connect(mContainer, "focus_out_event",
+                     G_CALLBACK(focus_out_event_cb), nullptr);
+    g_signal_connect(mContainer, "key_press_event",
+                     G_CALLBACK(key_press_event_cb), nullptr);
+    g_signal_connect(mContainer, "key_release_event",
+                     G_CALLBACK(key_release_event_cb), nullptr);
+
+    gtk_drag_dest_set((GtkWidget*)mContainer, (GtkDestDefaults)0, nullptr, 0,
+                      (GdkDragAction)0);
+
+    g_signal_connect(mContainer, "drag_motion",
+                     G_CALLBACK(drag_motion_event_cb), nullptr);
+    g_signal_connect(mContainer, "drag_leave", G_CALLBACK(drag_leave_event_cb),
+                     nullptr);
+    g_signal_connect(mContainer, "drag_drop", G_CALLBACK(drag_drop_event_cb),
+                     nullptr);
+    g_signal_connect(mContainer, "drag_data_received",
+                     G_CALLBACK(drag_data_received_event_cb), nullptr);
+
+#ifdef MOZ_X11
+    if (mIsX11Display) {
+      GtkWidget* widgets[] = {GTK_WIDGET(mContainer),
+                              !mDrawToContainer ? mShell : nullptr};
+      for (size_t i = 0; i < ArrayLength(widgets) && widgets[i]; ++i) {
+        // Double buffering is controlled by the window's owning
+        // widget. Disable double buffering for painting directly to the
+        // X Window.
+        gtk_widget_set_double_buffered(widgets[i], FALSE);
+      }
+    }
+#endif
+
+    // We create input contexts for all containers, except for
+    // toplevel popup windows
+    if (mWindowType != eWindowType_popup) {
+      mIMContext = new IMContextWrapper(this);
+    }
+  } else if (!mIMContext) {
+    nsWindow* container = GetContainerWindow();
+    if (container) {
+      mIMContext = container->mIMContext;
+    }
+  }
+
+  if (eventWidget) {
+    // These events are sent to the owning widget of the relevant window
+    // and propagate up to the first widget that handles the events, so we
+    // need only connect on mShell, if it exists, to catch events on its
+    // window and windows of mContainer.
+    g_signal_connect(eventWidget, "enter-notify-event",
+                     G_CALLBACK(enter_notify_event_cb), nullptr);
+    g_signal_connect(eventWidget, "leave-notify-event",
+                     G_CALLBACK(leave_notify_event_cb), nullptr);
+    g_signal_connect(eventWidget, "motion-notify-event",
+                     G_CALLBACK(motion_notify_event_cb), nullptr);
+    g_signal_connect(eventWidget, "button-press-event",
+                     G_CALLBACK(button_press_event_cb), nullptr);
+    g_signal_connect(eventWidget, "button-release-event",
+                     G_CALLBACK(button_release_event_cb), nullptr);
+    g_signal_connect(eventWidget, "scroll-event", G_CALLBACK(scroll_event_cb),
+                     nullptr);
+    g_signal_connect(eventWidget, "touch-event", G_CALLBACK(touch_event_cb),
+                     nullptr);
+  }
+
+  LOG(("nsWindow [%p] %s %s\n", (void*)this,
+       mWindowType == eWindowType_toplevel ? "Toplevel" : "Popup",
+       mIsPIPWindow ? "PIP window" : ""));
+  if (mShell) {
+#ifdef MOZ_X11
+    LOG(("\tmShell %p mContainer %p mGdkWindow %p 0x%lx\n", mShell, mContainer,
+         mGdkWindow, mIsX11Display ? gdk_x11_window_get_xid(mGdkWindow) : 0));
+#else
+    LOG(("\tmShell %p mContainer %p mGdkWindow %p 0x%lx\n", mShell, mContainer,
+         mGdkWindow, 0));
+#endif
+  } else if (mContainer) {
+    LOG(("\tmContainer %p mGdkWindow %p\n", mContainer, mGdkWindow));
+  } else if (mGdkWindow) {
+    LOG(("\tmGdkWindow %p parent %p\n", mGdkWindow,
+         gdk_window_get_parent(mGdkWindow)));
+  }
+
+  // resize so that everything is set to the right dimensions
+  if (!mIsTopLevel)
+    Resize(mBounds.x, mBounds.y, mBounds.width, mBounds.height, false);
+
+#ifdef MOZ_X11
+  if (mIsX11Display && mGdkWindow) {
+    mXDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+    mXWindow = gdk_x11_window_get_xid(mGdkWindow);
+
+    GdkVisual* gdkVisual = gdk_window_get_visual(mGdkWindow);
+    mXVisual = gdk_x11_visual_get_xvisual(gdkVisual);
+    mXDepth = gdk_visual_get_depth(gdkVisual);
+    bool shaped = popupNeedsAlphaVisual && !mHasAlphaVisual;
+
+    mSurfaceProvider.Initialize(mXDisplay, mXWindow, mXVisual, mXDepth, shaped);
+
+    if (mIsTopLevel) {
+      // Set window manager hint to keep fullscreen windows composited.
+      //
+      // If the window were to get unredirected, there could be visible
+      // tearing because Gecko does not align its framebuffer updates with
+      // vblank.
+      SetCompositorHint(GTK_WIDGET_COMPOSIDED_ENABLED);
+    }
+  }
+#  ifdef MOZ_WAYLAND
+  if (!mIsX11Display) {
+    mSurfaceProvider.Initialize(this);
+    WaylandStartVsync();
+  }
+#  endif
+#endif
+
+  // Set default application name when it's empty.
+  if (mGtkWindowAppName.IsEmpty()) {
+    mGtkWindowAppName = gAppData->name;
+  }
+  RefreshWindowClass();
+
+  return NS_OK;
+}
+
+void nsWindow::RefreshWindowClass(void) {
+  GdkWindow* gdkWindow = gtk_widget_get_window(mShell);
+  if (!gdkWindow) {
+    return;
+  }
+
+  if (!mGtkWindowRoleName.IsEmpty()) {
+    gdk_window_set_role(gdkWindow, mGtkWindowRoleName.get());
+  }
+
+#ifdef MOZ_X11
+  if (!mGtkWindowAppName.IsEmpty() && mIsX11Display) {
+    XClassHint* class_hint = XAllocClassHint();
+    if (!class_hint) {
+      return;
+    }
+    const char* res_class = gdk_get_program_class();
+    if (!res_class) return;
+
+    class_hint->res_name = const_cast<char*>(mGtkWindowAppName.get());
+    class_hint->res_class = const_cast<char*>(res_class);
+
+    // Can't use gtk_window_set_wmclass() for this; it prints
+    // a warning & refuses to make the change.
+    GdkDisplay* display = gdk_display_get_default();
+    XSetClassHint(GDK_DISPLAY_XDISPLAY(display),
+                  gdk_x11_window_get_xid(gdkWindow), class_hint);
+    XFree(class_hint);
+  }
+#endif /* MOZ_X11 */
+}
+
+void nsWindow::SetWindowClass(const nsAString& xulWinType) {
+  if (!mShell) return;
+
+  char* res_name = ToNewCString(xulWinType, mozilla::fallible);
+  if (!res_name) return;
+
+  const char* role = nullptr;
+
+  // Parse res_name into a name and role. Characters other than
+  // [A-Za-z0-9_-] are converted to '_'. Anything after the first
+  // colon is assigned to role; if there's no colon, assign the
+  // whole thing to both role and res_name.
+  for (char* c = res_name; *c; c++) {
+    if (':' == *c) {
+      *c = 0;
+      role = c + 1;
+    } else if (!isascii(*c) || (!isalnum(*c) && ('_' != *c) && ('-' != *c)))
+      *c = '_';
+  }
+  res_name[0] = toupper(res_name[0]);
+  if (!role) role = res_name;
+
+  mGtkWindowAppName = res_name;
+  mGtkWindowRoleName = role;
+  free(res_name);
+
+  RefreshWindowClass();
+}
+
+void nsWindow::NativeResize() {
+  if (!AreBoundsSane()) {
+    // If someone has set this so that the needs show flag is false
+    // and it needs to be hidden, update the flag and hide the
+    // window.  This flag will be cleared the next time someone
+    // hides the window or shows it.  It also prevents us from
+    // calling NativeShow(false) excessively on the window which
+    // causes unneeded X traffic.
+    if (!mNeedsShow && mIsShown) {
+      mNeedsShow = true;
+      NativeShow(false);
+    }
+    return;
+  }
+
+  GdkRectangle size = DevicePixelsToGdkSizeRoundUp(mBounds.Size());
+
+  LOG(("nsWindow::NativeResize [%p] %d %d\n", (void*)this, size.width,
+       size.height));
+
+  if (mIsTopLevel) {
+    MOZ_ASSERT(size.width > 0 && size.height > 0,
+               "Can't resize window smaller than 1x1.");
+    gtk_window_resize(GTK_WINDOW(mShell), size.width, size.height);
+    if (mWaitingForMoveToRectCB) {
+      LOG(("Waiting for move to rect, schedulling "));
+      mPendingSizeRect = mBounds;
+    }
+  } else if (mContainer) {
+    GtkWidget* widget = GTK_WIDGET(mContainer);
+    GtkAllocation allocation, prev_allocation;
+    gtk_widget_get_allocation(widget, &prev_allocation);
+    allocation.x = prev_allocation.x;
+    allocation.y = prev_allocation.y;
+    allocation.width = size.width;
+    allocation.height = size.height;
+    gtk_widget_size_allocate(widget, &allocation);
+  } else if (mGdkWindow) {
+    gdk_window_resize(mGdkWindow, size.width, size.height);
+  }
+
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
+  // Notify the GtkCompositorWidget of a ClientSizeChange
+  // This is different than OnSizeAllocate to catch initial sizing
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+  }
+#endif
+
+  // Does it need to be shown because bounds were previously insane?
+  if (mNeedsShow && mIsShown) {
+    NativeShow(true);
+  }
+}
+
+void nsWindow::NativeMoveResize() {
+  if (!AreBoundsSane()) {
+    // If someone has set this so that the needs show flag is false
+    // and it needs to be hidden, update the flag and hide the
+    // window.  This flag will be cleared the next time someone
+    // hides the window or shows it.  It also prevents us from
+    // calling NativeShow(false) excessively on the window which
+    // causes unneeded X traffic.
+    if (!mNeedsShow && mIsShown) {
+      mNeedsShow = true;
+      NativeShow(false);
+    }
+    NativeMove();
+
+    return;
+  }
+
+  GdkRectangle size = DevicePixelsToGdkSizeRoundUp(mBounds.Size());
+  GdkPoint topLeft = DevicePixelsToGdkPointRoundDown(mBounds.TopLeft());
+
+  LOG(("nsWindow::NativeMoveResize [%p] %d %d %d %d\n", (void*)this, topLeft.x,
+       topLeft.y, size.width, size.height));
+
+  if (IsWaylandPopup()) {
+    NativeMoveResizeWaylandPopup(&topLeft, &size);
+  } else {
+    if (mIsTopLevel) {
+      // x and y give the position of the window manager frame top-left.
+      gtk_window_move(GTK_WINDOW(mShell), topLeft.x, topLeft.y);
+      // This sets the client window size.
+      MOZ_ASSERT(size.width > 0 && size.height > 0,
+                 "Can't resize window smaller than 1x1.");
+      gtk_window_resize(GTK_WINDOW(mShell), size.width, size.height);
+    } else if (mContainer) {
+      GtkAllocation allocation;
+      allocation.x = topLeft.x;
+      allocation.y = topLeft.y;
+      allocation.width = size.width;
+      allocation.height = size.height;
+      gtk_widget_size_allocate(GTK_WIDGET(mContainer), &allocation);
+    } else if (mGdkWindow) {
+      gdk_window_move_resize(mGdkWindow, topLeft.x, topLeft.y, size.width,
+                             size.height);
+    }
+  }
+
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
+  // Notify the GtkCompositorWidget of a ClientSizeChange
+  // This is different than OnSizeAllocate to catch initial sizing
+  if (mCompositorWidgetDelegate) {
+    mCompositorWidgetDelegate->NotifyClientSizeChanged(GetClientSize());
+  }
+#endif
+
+  // Does it need to be shown because bounds were previously insane?
+  if (mNeedsShow && mIsShown) {
+    NativeShow(true);
+  }
+}
+
+void nsWindow::PauseRemoteRenderer() {
+#ifdef MOZ_WAYLAND
+  if (!mIsDestroyed) {
+    if (mContainer && moz_container_wayland_has_egl_window(mContainer)) {
+      // Because wl_egl_window is destroyed on moz_container_unmap(),
+      // the current compositor cannot use it anymore. To avoid crash,
+      // pause the compositor and destroy EGLSurface & resume the compositor
+      // and re-create EGLSurface on next expose event.
+      MOZ_ASSERT(GetRemoteRenderer());
+      if (CompositorBridgeChild* remoteRenderer = GetRemoteRenderer()) {
+        // XXX slow sync IPC
+        remoteRenderer->SendPause();
+        // Re-request initial draw callback
+        RefPtr<nsWindow> self(this);
+        moz_container_wayland_add_initial_draw_callback(
+            mContainer, [self]() -> void {
+              self->mNeedsCompositorResume = true;
+              self->MaybeResumeCompositor();
+            });
+      } else {
+        DestroyLayerManager();
+      }
+    }
+  }
+#endif
+}
+
+void nsWindow::HideWaylandWindow() {
+  if (mWindowType == eWindowType_popup) {
+    LOG(("nsWindow::HideWaylandWindow: popup [%p]\n", this));
+    GList* foundWindow = g_list_find(gVisibleWaylandPopupWindows, this);
+    if (foundWindow) {
+      gVisibleWaylandPopupWindows =
+          g_list_delete_link(gVisibleWaylandPopupWindows, foundWindow);
+    }
+  }
+  PauseRemoteRenderer();
+  gtk_widget_hide(mShell);
+}
+
+void nsWindow::WaylandStartVsync() {
+#ifdef MOZ_WAYLAND
+  // only use for toplevel windows for now - see bug 1619246
+  if (!gUseWaylandVsync || mWindowType != eWindowType_toplevel) {
+    return;
+  }
+
+  if (!mWaylandVsyncSource) {
+    mWaylandVsyncSource = new mozilla::WaylandVsyncSource(mContainer);
+  }
+  WaylandVsyncSource::WaylandDisplay& display =
+      static_cast<WaylandVsyncSource::WaylandDisplay&>(
+          mWaylandVsyncSource->GetGlobalDisplay());
+  display.EnableMonitor();
+#endif
+}
+
+void nsWindow::WaylandStopVsync() {
+#ifdef MOZ_WAYLAND
+  if (mWaylandVsyncSource) {
+    // The widget is going to be hidden, so clear the surface of our
+    // vsync source.
+    WaylandVsyncSource::WaylandDisplay& display =
+        static_cast<WaylandVsyncSource::WaylandDisplay&>(
+            mWaylandVsyncSource->GetGlobalDisplay());
+    display.DisableMonitor();
+  }
+#endif
+}
+
+void nsWindow::NativeShow(bool aAction) {
+  if (aAction) {
+    // unset our flag now that our window has been shown
+    mNeedsShow = false;
+
+    if (mIsTopLevel) {
+      // Set up usertime/startupID metadata for the created window.
+      if (mWindowType != eWindowType_invisible) {
+        SetUserTimeAndStartupIDForActivatedWindow(mShell);
+      }
+      // Update popup window hierarchy run-time on Wayland.
+      if (IsWaylandPopup()) {
+        if (!ConfigureWaylandPopupWindows()) {
+          mNeedsShow = true;
+          return;
+        }
+      }
+
+      LOG(("  calling gtk_widget_show(mShell)\n"));
+      gtk_widget_show(mShell);
+      if (!mIsX11Display) {
+        WaylandStartVsync();
+      }
+    } else if (mContainer) {
+      LOG(("  calling gtk_widget_show(mContainer)\n"));
+      gtk_widget_show(GTK_WIDGET(mContainer));
+    } else if (mGdkWindow) {
+      LOG(("  calling gdk_window_show_unraised\n"));
+      gdk_window_show_unraised(mGdkWindow);
+    }
+  } else {
+    // There's a chance that when the popup will be shown again it might be
+    // resized because parent could be moved meanwhile.
+    mPreferredPopupRect = nsRect(0, 0, 0, 0);
+    mPreferredPopupRectFlushed = false;
+    if (!mIsX11Display) {
+      WaylandStopVsync();
+      if (IsWaylandPopup() && IsMainMenuWindow()) {
+        CleanupWaylandPopups();
+      }
+      HideWaylandWindow();
+    } else if (mIsTopLevel) {
+      // Workaround window freezes on GTK versions before 3.21.2 by
+      // ensuring that configure events get dispatched to windows before
+      // they are unmapped. See bug 1225044.
+      if (gtk_check_version(3, 21, 2) != nullptr && mPendingConfigures > 0) {
+        GtkAllocation allocation;
+        gtk_widget_get_allocation(GTK_WIDGET(mShell), &allocation);
+
+        GdkEventConfigure event;
+        PodZero(&event);
+        event.type = GDK_CONFIGURE;
+        event.window = mGdkWindow;
+        event.send_event = TRUE;
+        event.x = allocation.x;
+        event.y = allocation.y;
+        event.width = allocation.width;
+        event.height = allocation.height;
+
+        auto shellClass = GTK_WIDGET_GET_CLASS(mShell);
+        for (unsigned int i = 0; i < mPendingConfigures; i++) {
+          Unused << shellClass->configure_event(mShell, &event);
+        }
+        mPendingConfigures = 0;
+      }
+      gtk_widget_hide(mShell);
+
+      ClearTransparencyBitmap();  // Release some resources
+    } else if (mContainer) {
+      gtk_widget_hide(GTK_WIDGET(mContainer));
+    } else if (mGdkWindow) {
+      gdk_window_hide(mGdkWindow);
+    }
+  }
+}
+
+void nsWindow::SetHasMappedToplevel(bool aState) {
+  // Even when aState == mHasMappedToplevel (as when this method is called
+  // from Show()), child windows need to have their state checked, so don't
+  // return early.
+  bool oldState = mHasMappedToplevel;
+  mHasMappedToplevel = aState;
+
+  // mHasMappedToplevel is not updated for children of windows that are
+  // hidden; GDK knows not to send expose events for these windows.  The
+  // state is recorded on the hidden window itself, but, for child trees of
+  // hidden windows, their state essentially becomes disconnected from their
+  // hidden parent.  When the hidden parent gets shown, the child trees are
+  // reconnected, and the state of the window being shown can be easily
+  // propagated.
+  if (!mIsShown || !mGdkWindow) return;
+
+  if (aState && !oldState) {
+    // Check that a grab didn't fail due to the window not being
+    // viewable.
+    EnsureGrabs();
+  }
+
+  for (GList* children = gdk_window_peek_children(mGdkWindow); children;
+       children = children->next) {
+    GdkWindow* gdkWin = GDK_WINDOW(children->data);
+    nsWindow* child = get_window_for_gdk_window(gdkWin);
+
+    if (child && child->mHasMappedToplevel != aState) {
+      child->SetHasMappedToplevel(aState);
+    }
+  }
+}
+
+LayoutDeviceIntSize nsWindow::GetSafeWindowSize(LayoutDeviceIntSize aSize) {
+  // The X protocol uses CARD32 for window sizes, but the server (1.11.3)
+  // reads it as CARD16.  Sizes of pixmaps, used for drawing, are (unsigned)
+  // CARD16 in the protocol, but the server's ProcCreatePixmap returns
+  // BadAlloc if dimensions cannot be represented by signed shorts.
+  // Because we are creating Cairo surfaces to represent window buffers,
+  // we also must ensure that the window can fit in a Cairo surface.
+  LayoutDeviceIntSize result = aSize;
+  int32_t maxSize = 32767;
+  if (mLayerManager && mLayerManager->AsKnowsCompositor()) {
+    maxSize = std::min(maxSize,
+                       mLayerManager->AsKnowsCompositor()->GetMaxTextureSize());
+  }
+  if (result.width > maxSize) {
+    result.width = maxSize;
+  }
+  if (result.height > maxSize) {
+    result.height = maxSize;
+  }
+  return result;
+}
+
+void nsWindow::EnsureGrabs(void) {
+  if (mRetryPointerGrab) GrabPointer(sRetryGrabTime);
+}
+
+void nsWindow::CleanLayerManagerRecursive(void) {
+  if (mLayerManager) {
+    mLayerManager->Destroy();
+    mLayerManager = nullptr;
+  }
+
+  DestroyCompositor();
+
+  GList* children = gdk_window_peek_children(mGdkWindow);
+  for (GList* list = children; list; list = list->next) {
+    nsWindow* window = get_window_for_gdk_window(GDK_WINDOW(list->data));
+    if (window) {
+      window->CleanLayerManagerRecursive();
+    }
+  }
+}
+
+void nsWindow::SetTransparencyMode(nsTransparencyMode aMode) {
+  if (!mShell) {
+    // Pass the request to the toplevel window
+    GtkWidget* topWidget = GetToplevelWidget();
+    if (!topWidget) return;
+
+    nsWindow* topWindow = get_window_for_gtk_widget(topWidget);
+    if (!topWindow) return;
+
+    topWindow->SetTransparencyMode(aMode);
+    return;
+  }
+
+  bool isTransparent = aMode == eTransparencyTransparent;
+
+  if (mIsTransparent == isTransparent) {
+    return;
+  }
+
+  if (mWindowType != eWindowType_popup) {
+    // https://bugzilla.mozilla.org/show_bug.cgi?id=1344839 reported
+    // problems cleaning the layer manager for toplevel windows.
+    // Ignore the request so as to workaround that.
+    // mIsTransparent is set in Create() if transparency may be required.
+    if (isTransparent) {
+      NS_WARNING("Transparent mode not supported on non-popup windows.");
+    }
+    return;
+  }
+
+  if (!isTransparent) {
+    ClearTransparencyBitmap();
+  }  // else the new default alpha values are "all 1", so we don't
+  // need to change anything yet
+
+  mIsTransparent = isTransparent;
+
+  if (!mHasAlphaVisual) {
+    // The choice of layer manager depends on
+    // GtkCompositorWidgetInitData::Shaped(), which will need to change, so
+    // clean out the old layer manager.
+    CleanLayerManagerRecursive();
+  }
+}
+
+nsTransparencyMode nsWindow::GetTransparencyMode() {
+  if (!mShell) {
+    // Pass the request to the toplevel window
+    GtkWidget* topWidget = GetToplevelWidget();
+    if (!topWidget) {
+      return eTransparencyOpaque;
+    }
+
+    nsWindow* topWindow = get_window_for_gtk_widget(topWidget);
+    if (!topWindow) {
+      return eTransparencyOpaque;
+    }
+
+    return topWindow->GetTransparencyMode();
+  }
+
+  return mIsTransparent ? eTransparencyTransparent : eTransparencyOpaque;
+}
+
+void nsWindow::SetWindowMouseTransparent(bool aIsTransparent) {
+  if (!mGdkWindow) {
+    return;
+  }
+
+  cairo_rectangle_int_t emptyRect = {0, 0, 0, 0};
+  cairo_region_t* region =
+      aIsTransparent ? cairo_region_create_rectangle(&emptyRect) : nullptr;
+
+  gdk_window_input_shape_combine_region(mGdkWindow, region, 0, 0);
+  if (region) {
+    cairo_region_destroy(region);
+  }
+}
+
+// For setting the draggable titlebar region from CSS
+// with -moz-window-dragging: drag.
+void nsWindow::UpdateWindowDraggingRegion(
+    const LayoutDeviceIntRegion& aRegion) {
+  if (mDraggableRegion != aRegion) {
+    mDraggableRegion = aRegion;
+  }
+}
+
+// See subtract_corners_from_region() at gtk/gtkwindow.c
+// We need to subtract corners from toplevel window opaque region
+// to draw transparent corners of default Gtk titlebar.
+// Both implementations (cairo_region_t and wl_region) needs to be synced.
+static void SubtractTitlebarCorners(cairo_region_t* aRegion, int aX, int aY,
+                                    int aWindowWidth) {
+  cairo_rectangle_int_t rect = {aX, aY, TITLEBAR_SHAPE_MASK_HEIGHT,
+                                TITLEBAR_SHAPE_MASK_HEIGHT};
+  cairo_region_subtract_rectangle(aRegion, &rect);
+  rect = {
+      aX + aWindowWidth - TITLEBAR_SHAPE_MASK_HEIGHT,
+      aY,
+      TITLEBAR_SHAPE_MASK_HEIGHT,
+      TITLEBAR_SHAPE_MASK_HEIGHT,
+  };
+  cairo_region_subtract_rectangle(aRegion, &rect);
+}
+
+void nsWindow::UpdateTopLevelOpaqueRegion(void) {
+  if (!mCompositedScreen) {
+    return;
+  }
+
+  GdkWindow* window =
+      (mDrawToContainer) ? gtk_widget_get_window(mShell) : mGdkWindow;
+  if (!window) {
+    return;
+  }
+  MOZ_ASSERT(gdk_window_get_window_type(window) == GDK_WINDOW_TOPLEVEL);
+
+  int x = 0;
+  int y = 0;
+
+  if (mDrawToContainer) {
+    gdk_window_get_position(mGdkWindow, &x, &y);
+  }
+
+  int width = DevicePixelsToGdkCoordRoundDown(mBounds.width);
+  int height = DevicePixelsToGdkCoordRoundDown(mBounds.height);
+
+  cairo_region_t* region = cairo_region_create();
+  cairo_rectangle_int_t rect = {x, y, width, height};
+  cairo_region_union_rectangle(region, &rect);
+
+  bool subtractCorners = DoDrawTilebarCorners();
+  if (subtractCorners) {
+    SubtractTitlebarCorners(region, x, y, width);
+  }
+
+  gdk_window_set_opaque_region(window, region);
+
+  cairo_region_destroy(region);
+
+#ifdef MOZ_WAYLAND
+  // We don't set opaque region to mozContainer by default due to Bug 1615098.
+  if (!mIsX11Display && gUseWaylandUseOpaqueRegion) {
+    moz_container_wayland_update_opaque_region(mContainer, subtractCorners);
+  }
+#endif
+}
+
+bool nsWindow::IsChromeWindowTitlebar() {
+  return mDrawInTitlebar && !mIsPIPWindow &&
+         mWindowType == eWindowType_toplevel;
+}
+
+bool nsWindow::DoDrawTilebarCorners() {
+  return IsChromeWindowTitlebar() && mSizeState == nsSizeMode_Normal &&
+         !mIsTiled;
+}
+
+nsresult nsWindow::ConfigureChildren(
+    const nsTArray<Configuration>& aConfigurations) {
+  // If this is a remotely updated widget we receive clipping, position, and
+  // size information from a source other than our owner. Don't let our parent
+  // update this information.
+  if (mWindowType == eWindowType_plugin_ipc_chrome) {
+    return NS_OK;
+  }
+
+  for (uint32_t i = 0; i < aConfigurations.Length(); ++i) {
+    const Configuration& configuration = aConfigurations[i];
+    auto* w = static_cast<nsWindow*>(configuration.mChild.get());
+    NS_ASSERTION(w->GetParent() == this, "Configured widget is not a child");
+    w->SetWindowClipRegion(configuration.mClipRegion, true);
+    if (w->mBounds.Size() != configuration.mBounds.Size()) {
+      w->Resize(configuration.mBounds.x, configuration.mBounds.y,
+                configuration.mBounds.width, configuration.mBounds.height,
+                true);
+    } else if (w->mBounds.TopLeft() != configuration.mBounds.TopLeft()) {
+      w->Move(configuration.mBounds.x, configuration.mBounds.y);
+    }
+    w->SetWindowClipRegion(configuration.mClipRegion, false);
+  }
+  return NS_OK;
+}
+
+nsresult nsWindow::SetWindowClipRegion(
+    const nsTArray<LayoutDeviceIntRect>& aRects, bool aIntersectWithExisting) {
+  const nsTArray<LayoutDeviceIntRect>* newRects = &aRects;
+
+  AutoTArray<LayoutDeviceIntRect, 1> intersectRects;
+  if (aIntersectWithExisting) {
+    AutoTArray<LayoutDeviceIntRect, 1> existingRects;
+    GetWindowClipRegion(&existingRects);
+
+    LayoutDeviceIntRegion existingRegion = RegionFromArray(existingRects);
+    LayoutDeviceIntRegion newRegion = RegionFromArray(aRects);
+    LayoutDeviceIntRegion intersectRegion;
+    intersectRegion.And(newRegion, existingRegion);
+
+    // If mClipRects is null we haven't set a clip rect yet, so we
+    // need to set the clip even if it is equal.
+    if (mClipRects && intersectRegion.IsEqual(existingRegion)) {
+      return NS_OK;
+    }
+
+    if (!intersectRegion.IsEqual(newRegion)) {
+      ArrayFromRegion(intersectRegion, intersectRects);
+      newRects = &intersectRects;
+    }
+  }
+
+  if (IsWindowClipRegionEqual(*newRects)) return NS_OK;
+
+  StoreWindowClipRegion(*newRects);
+
+  if (!mGdkWindow) return NS_OK;
+
+  cairo_region_t* region = cairo_region_create();
+  for (uint32_t i = 0; i < newRects->Length(); ++i) {
+    const LayoutDeviceIntRect& r = newRects->ElementAt(i);
+    cairo_rectangle_int_t rect = {r.x, r.y, r.width, r.height};
+    cairo_region_union_rectangle(region, &rect);
+  }
+
+  gdk_window_shape_combine_region(mGdkWindow, region, 0, 0);
+  cairo_region_destroy(region);
+
+  return NS_OK;
+}
+
+void nsWindow::ResizeTransparencyBitmap() {
+  if (!mTransparencyBitmap) return;
+
+  if (mBounds.width == mTransparencyBitmapWidth &&
+      mBounds.height == mTransparencyBitmapHeight)
+    return;
+
+  int32_t newRowBytes = GetBitmapStride(mBounds.width);
+  int32_t newSize = newRowBytes * mBounds.height;
+  auto* newBits = new gchar[newSize];
+  // fill new mask with "transparent", first
+  memset(newBits, 0, newSize);
+
+  // Now copy the intersection of the old and new areas into the new mask
+  int32_t copyWidth = std::min(mBounds.width, mTransparencyBitmapWidth);
+  int32_t copyHeight = std::min(mBounds.height, mTransparencyBitmapHeight);
+  int32_t oldRowBytes = GetBitmapStride(mTransparencyBitmapWidth);
+  int32_t copyBytes = GetBitmapStride(copyWidth);
+
+  int32_t i;
+  gchar* fromPtr = mTransparencyBitmap;
+  gchar* toPtr = newBits;
+  for (i = 0; i < copyHeight; i++) {
+    memcpy(toPtr, fromPtr, copyBytes);
+    fromPtr += oldRowBytes;
+    toPtr += newRowBytes;
+  }
+
+  delete[] mTransparencyBitmap;
+  mTransparencyBitmap = newBits;
+  mTransparencyBitmapWidth = mBounds.width;
+  mTransparencyBitmapHeight = mBounds.height;
+}
+
+static bool ChangedMaskBits(gchar* aMaskBits, int32_t aMaskWidth,
+                            int32_t aMaskHeight, const nsIntRect& aRect,
+                            uint8_t* aAlphas, int32_t aStride) {
+  int32_t x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
+  int32_t maskBytesPerRow = GetBitmapStride(aMaskWidth);
+  for (y = aRect.y; y < yMax; y++) {
+    gchar* maskBytes = aMaskBits + y * maskBytesPerRow;
+    uint8_t* alphas = aAlphas;
+    for (x = aRect.x; x < xMax; x++) {
+      bool newBit = *alphas > 0x7f;
+      alphas++;
+
+      gchar maskByte = maskBytes[x >> 3];
+      bool maskBit = (maskByte & (1 << (x & 7))) != 0;
+
+      if (maskBit != newBit) {
+        return true;
+      }
+    }
+    aAlphas += aStride;
+  }
+
+  return false;
+}
+
+static void UpdateMaskBits(gchar* aMaskBits, int32_t aMaskWidth,
+                           int32_t aMaskHeight, const nsIntRect& aRect,
+                           uint8_t* aAlphas, int32_t aStride) {
+  int32_t x, y, xMax = aRect.XMost(), yMax = aRect.YMost();
+  int32_t maskBytesPerRow = GetBitmapStride(aMaskWidth);
+  for (y = aRect.y; y < yMax; y++) {
+    gchar* maskBytes = aMaskBits + y * maskBytesPerRow;
+    uint8_t* alphas = aAlphas;
+    for (x = aRect.x; x < xMax; x++) {
+      bool newBit = *alphas > 0x7f;
+      alphas++;
+
+      gchar mask = 1 << (x & 7);
+      gchar maskByte = maskBytes[x >> 3];
+      // Note: '-newBit' turns 0 into 00...00 and 1 into 11...11
+      maskBytes[x >> 3] = (maskByte & ~mask) | (-newBit & mask);
+    }
+    aAlphas += aStride;
+  }
+}
+
+void nsWindow::ApplyTransparencyBitmap() {
+#ifdef MOZ_X11
+  // We use X11 calls where possible, because GDK handles expose events
+  // for shaped windows in a way that's incompatible with us (Bug 635903).
+  // It doesn't occur when the shapes are set through X.
+  Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+  Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
+  Pixmap maskPixmap = XCreateBitmapFromData(
+      xDisplay, xDrawable, mTransparencyBitmap, mTransparencyBitmapWidth,
+      mTransparencyBitmapHeight);
+  XShapeCombineMask(xDisplay, xDrawable, ShapeBounding, 0, 0, maskPixmap,
+                    ShapeSet);
+  XFreePixmap(xDisplay, maskPixmap);
+#else
+#  if 0 //Not working
+  cairo_surface_t* maskBitmap;
+  maskBitmap = cairo_image_surface_create_for_data(
+      (unsigned char*)mTransparencyBitmap, CAIRO_FORMAT_A1,
+      mTransparencyBitmapWidth, mTransparencyBitmapHeight,
+      GetBitmapStride(mTransparencyBitmapWidth));
+  if (!maskBitmap) return;
+
+  cairo_region_t* maskRegion = gdk_cairo_region_create_from_surface(maskBitmap);
+  gtk_widget_shape_combine_region(mShell, maskRegion);
+  cairo_region_destroy(maskRegion);
+  cairo_surface_destroy(maskBitmap);
+#  endif
+#endif  // MOZ_X11
+}
+
+void nsWindow::ClearTransparencyBitmap() {
+  if (!mTransparencyBitmap) return;
+
+  delete[] mTransparencyBitmap;
+  mTransparencyBitmap = nullptr;
+  mTransparencyBitmapWidth = 0;
+  mTransparencyBitmapHeight = 0;
+
+  if (!mShell) return;
+
+#ifdef MOZ_X11
+  if (!mGdkWindow) return;
+
+  Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+  Window xWindow = gdk_x11_window_get_xid(mGdkWindow);
+
+  XShapeCombineMask(xDisplay, xWindow, ShapeBounding, 0, 0, X11None, ShapeSet);
+#endif
+}
+
+nsresult nsWindow::UpdateTranslucentWindowAlphaInternal(const nsIntRect& aRect,
+                                                        uint8_t* aAlphas,
+                                                        int32_t aStride) {
+  if (!mShell) {
+    // Pass the request to the toplevel window
+    GtkWidget* topWidget = GetToplevelWidget();
+    if (!topWidget) return NS_ERROR_FAILURE;
+
+    nsWindow* topWindow = get_window_for_gtk_widget(topWidget);
+    if (!topWindow) return NS_ERROR_FAILURE;
+
+    return topWindow->UpdateTranslucentWindowAlphaInternal(aRect, aAlphas,
+                                                           aStride);
+  }
+
+  NS_ASSERTION(mIsTransparent, "Window is not transparent");
+  NS_ASSERTION(!mTransparencyBitmapForTitlebar,
+               "Transparency bitmap is already used for titlebar rendering");
+
+  if (mTransparencyBitmap == nullptr) {
+    int32_t size = GetBitmapStride(mBounds.width) * mBounds.height;
+    mTransparencyBitmap = new gchar[size];
+    memset(mTransparencyBitmap, 255, size);
+    mTransparencyBitmapWidth = mBounds.width;
+    mTransparencyBitmapHeight = mBounds.height;
+  } else {
+    ResizeTransparencyBitmap();
+  }
+
+  nsIntRect rect;
+  rect.IntersectRect(aRect, nsIntRect(0, 0, mBounds.width, mBounds.height));
+
+  if (!ChangedMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height, rect,
+                       aAlphas, aStride))
+    // skip the expensive stuff if the mask bits haven't changed; hopefully
+    // this is the common case
+    return NS_OK;
+
+  UpdateMaskBits(mTransparencyBitmap, mBounds.width, mBounds.height, rect,
+                 aAlphas, aStride);
+
+  if (!mNeedsShow) {
+    ApplyTransparencyBitmap();
+  }
+  return NS_OK;
+}
+
+void nsWindow::UpdateTitlebarTransparencyBitmap() {
+  NS_ASSERTION(mTransparencyBitmapForTitlebar,
+               "Transparency bitmap is already used to draw window shape");
+
+  if (!mGdkWindow || !mDrawInTitlebar ||
+      (mBounds.width == mTransparencyBitmapWidth &&
+       mBounds.height == mTransparencyBitmapHeight)) {
+    return;
+  }
+
+  bool maskCreate =
+      !mTransparencyBitmap || mBounds.width > mTransparencyBitmapWidth;
+
+  bool maskUpdate =
+      !mTransparencyBitmap || mBounds.width != mTransparencyBitmapWidth;
+
+  if (maskCreate) {
+    if (mTransparencyBitmap) {
+      delete[] mTransparencyBitmap;
+    }
+    int32_t size = GetBitmapStride(mBounds.width) * TITLEBAR_SHAPE_MASK_HEIGHT;
+    mTransparencyBitmap = new gchar[size];
+    mTransparencyBitmapWidth = mBounds.width;
+  } else {
+    mTransparencyBitmapWidth = mBounds.width;
+  }
+  mTransparencyBitmapHeight = mBounds.height;
+
+  if (maskUpdate) {
+    cairo_surface_t* surface = cairo_image_surface_create(
+        CAIRO_FORMAT_A8, mTransparencyBitmapWidth, TITLEBAR_SHAPE_MASK_HEIGHT);
+    if (!surface) return;
+
+    cairo_t* cr = cairo_create(surface);
+
+    GtkWidgetState state;
+    memset((void*)&state, 0, sizeof(state));
+    GdkRectangle rect = {0, 0, mTransparencyBitmapWidth,
+                         TITLEBAR_SHAPE_MASK_HEIGHT};
+
+    moz_gtk_widget_paint(MOZ_GTK_HEADER_BAR, cr, &rect, &state, 0,
+                         GTK_TEXT_DIR_NONE);
+
+    cairo_destroy(cr);
+    cairo_surface_mark_dirty(surface);
+    cairo_surface_flush(surface);
+
+    UpdateMaskBits(
+        mTransparencyBitmap, mTransparencyBitmapWidth,
+        TITLEBAR_SHAPE_MASK_HEIGHT,
+        nsIntRect(0, 0, mTransparencyBitmapWidth, TITLEBAR_SHAPE_MASK_HEIGHT),
+        cairo_image_surface_get_data(surface),
+        cairo_format_stride_for_width(CAIRO_FORMAT_A8,
+                                      mTransparencyBitmapWidth));
+
+    cairo_surface_destroy(surface);
+  }
+
+#ifdef MOZ_X11
+  if (!mNeedsShow) {
+    Display* xDisplay = GDK_WINDOW_XDISPLAY(mGdkWindow);
+    Window xDrawable = GDK_WINDOW_XID(mGdkWindow);
+
+    Pixmap maskPixmap = XCreateBitmapFromData(
+        xDisplay, xDrawable, mTransparencyBitmap, mTransparencyBitmapWidth,
+        TITLEBAR_SHAPE_MASK_HEIGHT);
+
+    XShapeCombineMask(xDisplay, xDrawable, ShapeBounding, 0, 0, maskPixmap,
+                      ShapeSet);
+
+    if (mTransparencyBitmapHeight > TITLEBAR_SHAPE_MASK_HEIGHT) {
+      XRectangle rect = {0, 0, (unsigned short)mTransparencyBitmapWidth,
+                         (unsigned short)(mTransparencyBitmapHeight -
+                                          TITLEBAR_SHAPE_MASK_HEIGHT)};
+      XShapeCombineRectangles(xDisplay, xDrawable, ShapeBounding, 0,
+                              TITLEBAR_SHAPE_MASK_HEIGHT, &rect, 1, ShapeUnion,
+                              0);
+    }
+
+    XFreePixmap(xDisplay, maskPixmap);
+  }
+#endif
+}
+
+void nsWindow::GrabPointer(guint32 aTime) {
+  LOG(("GrabPointer time=0x%08x retry=%d\n", (unsigned int)aTime,
+       mRetryPointerGrab));
+
+  mRetryPointerGrab = false;
+  sRetryGrabTime = aTime;
+
+  // If the window isn't visible, just set the flag to retry the
+  // grab.  When this window becomes visible, the grab will be
+  // retried.
+  if (!mHasMappedToplevel) {
+    LOG(("GrabPointer: window not visible\n"));
+    mRetryPointerGrab = true;
+    return;
+  }
+
+  if (!mGdkWindow) return;
+
+  if (!mIsX11Display) {
+    // Don't to the grab on Wayland as it causes a regression
+    // from Bug 1377084.
+    return;
+  }
+
+#ifdef MOZ_X11
+  gint retval;
+  // Note that we need GDK_TOUCH_MASK below to work around a GDK/X11 bug that
+  // causes touch events that would normally be received by this client on
+  // other windows to be discarded during the grab.
+  retval = gdk_pointer_grab(
+      mGdkWindow, TRUE,
+      (GdkEventMask)(GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK |
+                     GDK_ENTER_NOTIFY_MASK | GDK_LEAVE_NOTIFY_MASK |
+                     GDK_POINTER_MOTION_MASK | GDK_TOUCH_MASK),
+      (GdkWindow*)nullptr, nullptr, aTime);
+
+  if (retval == GDK_GRAB_NOT_VIEWABLE) {
+    LOG(("GrabPointer: window not viewable; will retry\n"));
+    mRetryPointerGrab = true;
+  } else if (retval != GDK_GRAB_SUCCESS) {
+    LOG(("GrabPointer: pointer grab failed: %i\n", retval));
+    // A failed grab indicates that another app has grabbed the pointer.
+    // Check for rollup now, because, without the grab, we likely won't
+    // get subsequent button press events. Do this with an event so that
+    // popups don't rollup while potentially adjusting the grab for
+    // this popup.
+    nsCOMPtr<nsIRunnable> event =
+        NewRunnableMethod("nsWindow::CheckForRollupDuringGrab", this,
+                          &nsWindow::CheckForRollupDuringGrab);
+    NS_DispatchToCurrentThread(event.forget());
+  }
+#endif
+}
+
+void nsWindow::ReleaseGrabs(void) {
+  LOG(("ReleaseGrabs\n"));
+
+  mRetryPointerGrab = false;
+
+  if (!mIsX11Display) {
+    // Don't to the ungrab on Wayland as it causes a regression
+    // from Bug 1377084.
+    return;
+  }
+
+#ifdef MOZ_X11
+  gdk_pointer_ungrab(GDK_CURRENT_TIME);
+#endif
+}
+
+GtkWidget* nsWindow::GetToplevelWidget() {
+  if (mShell) {
+    return mShell;
+  }
+
+  GtkWidget* widget = GetMozContainerWidget();
+  if (!widget) return nullptr;
+
+  return gtk_widget_get_toplevel(widget);
+}
+
+GtkWidget* nsWindow::GetMozContainerWidget() {
+  if (!mGdkWindow) return nullptr;
+
+  if (mContainer) return GTK_WIDGET(mContainer);
+
+  GtkWidget* owningWidget = get_gtk_widget_for_gdk_window(mGdkWindow);
+  return owningWidget;
+}
+
+nsWindow* nsWindow::GetContainerWindow() {
+  GtkWidget* owningWidget = GetMozContainerWidget();
+  if (!owningWidget) return nullptr;
+
+  nsWindow* window = get_window_for_gtk_widget(owningWidget);
+  NS_ASSERTION(window, "No nsWindow for container widget");
+  return window;
+}
+
+void nsWindow::SetUrgencyHint(GtkWidget* top_window, bool state) {
+  if (!top_window) return;
+
+  gdk_window_set_urgency_hint(gtk_widget_get_window(top_window), state);
+}
+
+void nsWindow::SetDefaultIcon(void) { SetIcon(u"default"_ns); }
+
+gint nsWindow::ConvertBorderStyles(nsBorderStyle aStyle) {
+  gint w = 0;
+
+  if (aStyle == eBorderStyle_default) return -1;
+
+  // note that we don't handle eBorderStyle_close yet
+  if (aStyle & eBorderStyle_all) w |= GDK_DECOR_ALL;
+  if (aStyle & eBorderStyle_border) w |= GDK_DECOR_BORDER;
+  if (aStyle & eBorderStyle_resizeh) w |= GDK_DECOR_RESIZEH;
+  if (aStyle & eBorderStyle_title) w |= GDK_DECOR_TITLE;
+  if (aStyle & eBorderStyle_menu) w |= GDK_DECOR_MENU;
+  if (aStyle & eBorderStyle_minimize) w |= GDK_DECOR_MINIMIZE;
+  if (aStyle & eBorderStyle_maximize) w |= GDK_DECOR_MAXIMIZE;
+
+  return w;
+}
+
+class FullscreenTransitionWindow final : public nsISupports {
+ public:
+  NS_DECL_ISUPPORTS
+
+  explicit FullscreenTransitionWindow(GtkWidget* aWidget);
+
+  GtkWidget* mWindow;
+
+ private:
+  ~FullscreenTransitionWindow();
+};
+
+NS_IMPL_ISUPPORTS0(FullscreenTransitionWindow)
+
+FullscreenTransitionWindow::FullscreenTransitionWindow(GtkWidget* aWidget) {
+  mWindow = gtk_window_new(GTK_WINDOW_POPUP);
+  GtkWindow* gtkWin = GTK_WINDOW(mWindow);
+
+  gtk_window_set_type_hint(gtkWin, GDK_WINDOW_TYPE_HINT_SPLASHSCREEN);
+  gtk_window_set_transient_for(gtkWin, GTK_WINDOW(aWidget));
+  gtk_window_set_decorated(gtkWin, false);
+
+  GdkWindow* gdkWin = gtk_widget_get_window(aWidget);
+  GdkScreen* screen = gtk_widget_get_screen(aWidget);
+  gint monitorNum = gdk_screen_get_monitor_at_window(screen, gdkWin);
+  GdkRectangle monitorRect;
+  gdk_screen_get_monitor_geometry(screen, monitorNum, &monitorRect);
+  gtk_window_set_screen(gtkWin, screen);
+  gtk_window_move(gtkWin, monitorRect.x, monitorRect.y);
+  MOZ_ASSERT(monitorRect.width > 0 && monitorRect.height > 0,
+             "Can't resize window smaller than 1x1.");
+  gtk_window_resize(gtkWin, monitorRect.width, monitorRect.height);
+
+  GdkColor bgColor;
+  bgColor.red = bgColor.green = bgColor.blue = 0;
+  gtk_widget_modify_bg(mWindow, GTK_STATE_NORMAL, &bgColor);
+
+  gtk_window_set_opacity(gtkWin, 0.0);
+  gtk_widget_show(mWindow);
+}
+
+FullscreenTransitionWindow::~FullscreenTransitionWindow() {
+  gtk_widget_destroy(mWindow);
+}
+
+class FullscreenTransitionData {
+ public:
+  FullscreenTransitionData(nsIWidget::FullscreenTransitionStage aStage,
+                           uint16_t aDuration, nsIRunnable* aCallback,
+                           FullscreenTransitionWindow* aWindow)
+      : mStage(aStage),
+        mStartTime(TimeStamp::Now()),
+        mDuration(TimeDuration::FromMilliseconds(aDuration)),
+        mCallback(aCallback),
+        mWindow(aWindow) {}
+
+  static const guint sInterval = 1000 / 30;  // 30fps
+  static gboolean TimeoutCallback(gpointer aData);
+
+ private:
+  nsIWidget::FullscreenTransitionStage mStage;
+  TimeStamp mStartTime;
+  TimeDuration mDuration;
+  nsCOMPtr<nsIRunnable> mCallback;
+  RefPtr<FullscreenTransitionWindow> mWindow;
+};
+
+/* static */
+gboolean FullscreenTransitionData::TimeoutCallback(gpointer aData) {
+  bool finishing = false;
+  auto data = static_cast<FullscreenTransitionData*>(aData);
+  gdouble opacity = (TimeStamp::Now() - data->mStartTime) / data->mDuration;
+  if (opacity >= 1.0) {
+    opacity = 1.0;
+    finishing = true;
+  }
+  if (data->mStage == nsIWidget::eAfterFullscreenToggle) {
+    opacity = 1.0 - opacity;
+  }
+  gtk_window_set_opacity(GTK_WINDOW(data->mWindow->mWindow), opacity);
+
+  if (!finishing) {
+    return TRUE;
+  }
+  NS_DispatchToMainThread(data->mCallback.forget());
+  delete data;
+  return FALSE;
+}
+
+/* virtual */
+bool nsWindow::PrepareForFullscreenTransition(nsISupports** aData) {
+  if (!mCompositedScreen) {
+    return false;
+  }
+  *aData = do_AddRef(new FullscreenTransitionWindow(mShell)).take();
+  return true;
+}
+
+/* virtual */
+void nsWindow::PerformFullscreenTransition(FullscreenTransitionStage aStage,
+                                           uint16_t aDuration,
+                                           nsISupports* aData,
+                                           nsIRunnable* aCallback) {
+  auto data = static_cast<FullscreenTransitionWindow*>(aData);
+  // This will be released at the end of the last timeout callback for it.
+  auto transitionData =
+      new FullscreenTransitionData(aStage, aDuration, aCallback, data);
+  g_timeout_add_full(G_PRIORITY_HIGH, FullscreenTransitionData::sInterval,
+                     FullscreenTransitionData::TimeoutCallback, transitionData,
+                     nullptr);
+}
+
+already_AddRefed<nsIScreen> nsWindow::GetWidgetScreen() {
+  nsCOMPtr<nsIScreenManager> screenManager;
+  screenManager = do_GetService("@mozilla.org/gfx/screenmanager;1");
+  if (!screenManager) {
+    return nullptr;
+  }
+
+  // GetScreenBounds() is slow for the GTK port so we override and use
+  // mBounds directly.
+  LayoutDeviceIntRect bounds = mBounds;
+  if (!mIsTopLevel) {
+    bounds.MoveTo(WidgetToScreenOffset());
+  }
+
+  DesktopIntRect deskBounds = RoundedToInt(bounds / GetDesktopToDeviceScale());
+  nsCOMPtr<nsIScreen> screen;
+  screenManager->ScreenForRect(deskBounds.x, deskBounds.y, deskBounds.width,
+                               deskBounds.height, getter_AddRefs(screen));
+  return screen.forget();
+}
+
+RefPtr<VsyncSource> nsWindow::GetVsyncSource() {
+#ifdef MOZ_WAYLAND
+  if (mWaylandVsyncSource) {
+    return mWaylandVsyncSource;
+  }
+#endif
+
+  return nullptr;
+}
+
+static bool IsFullscreenSupported(GtkWidget* aShell) {
+#ifdef MOZ_X11
+  GdkScreen* screen = gtk_widget_get_screen(aShell);
+  GdkAtom atom = gdk_atom_intern("_NET_WM_STATE_FULLSCREEN", FALSE);
+  if (!gdk_x11_screen_supports_net_wm_hint(screen, atom)) {
+    return false;
+  }
+#endif
+  return true;
+}
+
+nsresult nsWindow::MakeFullScreen(bool aFullScreen, nsIScreen* aTargetScreen) {
+  LOG(("nsWindow::MakeFullScreen [%p] aFullScreen %d\n", (void*)this,
+       aFullScreen));
+
+  if (mIsX11Display && !IsFullscreenSupported(mShell)) {
+    return NS_ERROR_NOT_AVAILABLE;
+  }
+
+  bool wasFullscreen = mSizeState == nsSizeMode_Fullscreen;
+  if (aFullScreen != wasFullscreen && mWidgetListener) {
+    mWidgetListener->FullscreenWillChange(aFullScreen);
+  }
+
+  if (aFullScreen) {
+    if (mSizeMode != nsSizeMode_Fullscreen) mLastSizeMode = mSizeMode;
+
+    mSizeMode = nsSizeMode_Fullscreen;
+
+    if (mIsPIPWindow) {
+      gtk_window_set_type_hint(GTK_WINDOW(mShell), GDK_WINDOW_TYPE_HINT_NORMAL);
+      if (gUseAspectRatio) {
+        mAspectRatioSaved = mAspectRatio;
+        mAspectRatio = 0.0f;
+        ApplySizeConstraints();
+      }
+    }
+
+    gtk_window_fullscreen(GTK_WINDOW(mShell));
+  } else {
+    mSizeMode = mLastSizeMode;
+    gtk_window_unfullscreen(GTK_WINDOW(mShell));
+
+    if (mIsPIPWindow) {
+      gtk_window_set_type_hint(GTK_WINDOW(mShell),
+                               GDK_WINDOW_TYPE_HINT_UTILITY);
+      if (gUseAspectRatio) {
+        mAspectRatio = mAspectRatioSaved;
+        // ApplySizeConstraints();
+      }
+    }
+  }
+
+  NS_ASSERTION(mLastSizeMode != nsSizeMode_Fullscreen,
+               "mLastSizeMode should never be fullscreen");
+  return NS_OK;
+}
+
+void nsWindow::SetWindowDecoration(nsBorderStyle aStyle) {
+  LOG(("nsWindow::SetWindowDecoration() [%p] Border style %x\n", (void*)this,
+       aStyle));
+
+  if (!mShell) {
+    // Pass the request to the toplevel window
+    GtkWidget* topWidget = GetToplevelWidget();
+    if (!topWidget) return;
+
+    nsWindow* topWindow = get_window_for_gtk_widget(topWidget);
+    if (!topWindow) return;
+
+    topWindow->SetWindowDecoration(aStyle);
+    return;
+  }
+
+  // We can't use mGdkWindow directly here as it can be
+  // derived from mContainer which is not a top-level GdkWindow.
+  GdkWindow* window = gtk_widget_get_window(mShell);
+
+  // Sawfish, metacity, and presumably other window managers get
+  // confused if we change the window decorations while the window
+  // is visible.
+  bool wasVisible = false;
+  if (gdk_window_is_visible(window)) {
+    gdk_window_hide(window);
+    wasVisible = true;
+  }
+
+  gint wmd = ConvertBorderStyles(aStyle);
+  if (wmd != -1) gdk_window_set_decorations(window, (GdkWMDecoration)wmd);
+
+  if (wasVisible) gdk_window_show(window);
+
+    // For some window managers, adding or removing window decorations
+    // requires unmapping and remapping our toplevel window.  Go ahead
+    // and flush the queue here so that we don't end up with a BadWindow
+    // error later when this happens (when the persistence timer fires
+    // and GetWindowPos is called)
+#ifdef MOZ_X11
+  if (mIsX11Display) {
+    XSync(GDK_DISPLAY_XDISPLAY(gdk_display_get_default()), X11False);
+  } else
+#endif /* MOZ_X11 */
+  {
+    gdk_flush();
+  }
+}
+
+void nsWindow::HideWindowChrome(bool aShouldHide) {
+  SetWindowDecoration(aShouldHide ? eBorderStyle_none : mBorderStyle);
+}
+
+bool nsWindow::CheckForRollup(gdouble aMouseX, gdouble aMouseY, bool aIsWheel,
+                              bool aAlwaysRollup) {
+  nsIRollupListener* rollupListener = GetActiveRollupListener();
+  nsCOMPtr<nsIWidget> rollupWidget;
+  if (rollupListener) {
+    rollupWidget = rollupListener->GetRollupWidget();
+  }
+  if (!rollupWidget) {
+    nsBaseWidget::gRollupListener = nullptr;
+    return false;
+  }
+
+  bool retVal = false;
+  auto* currentPopup =
+      (GdkWindow*)rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
+  if (aAlwaysRollup || !is_mouse_in_window(currentPopup, aMouseX, aMouseY)) {
+    bool rollup = true;
+    if (aIsWheel) {
+      rollup = rollupListener->ShouldRollupOnMouseWheelEvent();
+      retVal = rollupListener->ShouldConsumeOnMouseWheelEvent();
+    }
+    // if we're dealing with menus, we probably have submenus and
+    // we don't want to rollup if the click is in a parent menu of
+    // the current submenu
+    uint32_t popupsToRollup = UINT32_MAX;
+    if (!aAlwaysRollup) {
+      AutoTArray<nsIWidget*, 5> widgetChain;
+      uint32_t sameTypeCount =
+          rollupListener->GetSubmenuWidgetChain(&widgetChain);
+      for (unsigned long i = 0; i < widgetChain.Length(); ++i) {
+        nsIWidget* widget = widgetChain[i];
+        auto* currWindow = (GdkWindow*)widget->GetNativeData(NS_NATIVE_WINDOW);
+        if (is_mouse_in_window(currWindow, aMouseX, aMouseY)) {
+          // don't roll up if the mouse event occurred within a
+          // menu of the same type. If the mouse event occurred
+          // in a menu higher than that, roll up, but pass the
+          // number of popups to Rollup so that only those of the
+          // same type close up.
+          if (i < sameTypeCount) {
+            rollup = false;
+          } else {
+            popupsToRollup = sameTypeCount;
+          }
+          break;
+        }
+      }  // foreach parent menu widget
+    }    // if rollup listener knows about menus
+
+    // if we've determined that we should still rollup, do it.
+    bool usePoint = !aIsWheel && !aAlwaysRollup;
+    IntPoint point;
+    if (usePoint) {
+      LayoutDeviceIntPoint p = GdkEventCoordsToDevicePixels(aMouseX, aMouseY);
+      point = p.ToUnknownPoint();
+    }
+    if (rollup &&
+        rollupListener->Rollup(popupsToRollup, true,
+                               usePoint ? &point : nullptr, nullptr)) {
+      retVal = true;
+    }
+  }
+  return retVal;
+}
+
+/* static */
+bool nsWindow::DragInProgress(void) {
+  nsCOMPtr<nsIDragService> dragService = do_GetService(kCDragServiceCID);
+
+  if (!dragService) return false;
+
+  nsCOMPtr<nsIDragSession> currentDragSession;
+  dragService->GetCurrentSession(getter_AddRefs(currentDragSession));
+
+  return currentDragSession != nullptr;
+}
+
+static bool is_mouse_in_window(GdkWindow* aWindow, gdouble aMouseX,
+                               gdouble aMouseY) {
+  gint x = 0;
+  gint y = 0;
+  gint w, h;
+
+  gint offsetX = 0;
+  gint offsetY = 0;
+
+  GdkWindow* window = aWindow;
+
+  while (window) {
+    gint tmpX = 0;
+    gint tmpY = 0;
+
+    gdk_window_get_position(window, &tmpX, &tmpY);
+    GtkWidget* widget = get_gtk_widget_for_gdk_window(window);
+
+    // if this is a window, compute x and y given its origin and our
+    // offset
+    if (GTK_IS_WINDOW(widget)) {
+      x = tmpX + offsetX;
+      y = tmpY + offsetY;
+      break;
+    }
+
+    offsetX += tmpX;
+    offsetY += tmpY;
+    window = gdk_window_get_parent(window);
+  }
+
+  w = gdk_window_get_width(aWindow);
+  h = gdk_window_get_height(aWindow);
+
+  if (aMouseX > x && aMouseX < x + w && aMouseY > y && aMouseY < y + h)
+    return true;
+
+  return false;
+}
+
+static nsWindow* get_window_for_gtk_widget(GtkWidget* widget) {
+  gpointer user_data = g_object_get_data(G_OBJECT(widget), "nsWindow");
+
+  return static_cast<nsWindow*>(user_data);
+}
+
+static nsWindow* get_window_for_gdk_window(GdkWindow* window) {
+  gpointer user_data = g_object_get_data(G_OBJECT(window), "nsWindow");
+
+  return static_cast<nsWindow*>(user_data);
+}
+
+static GtkWidget* get_gtk_widget_for_gdk_window(GdkWindow* window) {
+  gpointer user_data = nullptr;
+  gdk_window_get_user_data(window, &user_data);
+
+  return GTK_WIDGET(user_data);
+}
+
+static GdkCursor* get_gtk_cursor(nsCursor aCursor) {
+  GdkCursor* gdkcursor = nullptr;
+  uint8_t newType = 0xff;
+
+  if ((gdkcursor = gCursorCache[aCursor])) {
+    return gdkcursor;
+  }
+
+  GdkDisplay* defaultDisplay = gdk_display_get_default();
+
+  // The strategy here is to use standard GDK cursors, and, if not available,
+  // load by standard name with gdk_cursor_new_from_name.
+  // Spec is here: http://www.freedesktop.org/wiki/Specifications/cursor-spec/
+  switch (aCursor) {
+    case eCursor_standard:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_PTR);
+      break;
+    case eCursor_wait:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_WATCH);
+      break;
+    case eCursor_select:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_XTERM);
+      break;
+    case eCursor_hyperlink:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_HAND2);
+      break;
+    case eCursor_n_resize:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_TOP_SIDE);
+      break;
+    case eCursor_s_resize:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_BOTTOM_SIDE);
+      break;
+    case eCursor_w_resize:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_SIDE);
+      break;
+    case eCursor_e_resize:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_RIGHT_SIDE);
+      break;
+    case eCursor_nw_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_TOP_LEFT_CORNER);
+      break;
+    case eCursor_se_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_BOTTOM_RIGHT_CORNER);
+      break;
+    case eCursor_ne_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_TOP_RIGHT_CORNER);
+      break;
+    case eCursor_sw_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_BOTTOM_LEFT_CORNER);
+      break;
+    case eCursor_crosshair:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_CROSSHAIR);
+      break;
+    case eCursor_move:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_FLEUR);
+      break;
+    case eCursor_help:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_QUESTION_ARROW);
+      break;
+    case eCursor_copy:  // CSS3
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "copy");
+      if (!gdkcursor) newType = MOZ_CURSOR_COPY;
+      break;
+    case eCursor_alias:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "alias");
+      if (!gdkcursor) newType = MOZ_CURSOR_ALIAS;
+      break;
+    case eCursor_context_menu:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "context-menu");
+      if (!gdkcursor) newType = MOZ_CURSOR_CONTEXT_MENU;
+      break;
+    case eCursor_cell:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_PLUS);
+      break;
+    // Those two arent standardized. Trying both KDEs and GNOMEs names
+    case eCursor_grab:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "openhand");
+      if (!gdkcursor) newType = MOZ_CURSOR_HAND_GRAB;
+      break;
+    case eCursor_grabbing:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "closedhand");
+      if (!gdkcursor)
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "grabbing");
+      if (!gdkcursor) newType = MOZ_CURSOR_HAND_GRABBING;
+      break;
+    case eCursor_spinning:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "progress");
+      if (!gdkcursor) newType = MOZ_CURSOR_SPINNING;
+      break;
+    case eCursor_zoom_in:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "zoom-in");
+      if (!gdkcursor) newType = MOZ_CURSOR_ZOOM_IN;
+      break;
+    case eCursor_zoom_out:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "zoom-out");
+      if (!gdkcursor) newType = MOZ_CURSOR_ZOOM_OUT;
+      break;
+    case eCursor_not_allowed:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "not-allowed");
+      if (!gdkcursor)  // nonstandard, yet common
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "crossed_circle");
+      if (!gdkcursor) newType = MOZ_CURSOR_NOT_ALLOWED;
+      break;
+    case eCursor_no_drop:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "no-drop");
+      if (!gdkcursor)  // this nonstandard sequence makes it work on KDE and
+                       // GNOME
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "forbidden");
+      if (!gdkcursor)
+        gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "circle");
+      if (!gdkcursor) newType = MOZ_CURSOR_NOT_ALLOWED;
+      break;
+    case eCursor_vertical_text:
+      newType = MOZ_CURSOR_VERTICAL_TEXT;
+      break;
+    case eCursor_all_scroll:
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_FLEUR);
+      break;
+    case eCursor_nesw_resize:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "size_bdiag");
+      if (!gdkcursor) newType = MOZ_CURSOR_NESW_RESIZE;
+      break;
+    case eCursor_nwse_resize:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "size_fdiag");
+      if (!gdkcursor) newType = MOZ_CURSOR_NWSE_RESIZE;
+      break;
+    case eCursor_ns_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_SB_V_DOUBLE_ARROW);
+      break;
+    case eCursor_ew_resize:
+      gdkcursor =
+          gdk_cursor_new_for_display(defaultDisplay, GDK_SB_H_DOUBLE_ARROW);
+      break;
+    // Here, two better fitting cursors exist in some cursor themes. Try those
+    // first
+    case eCursor_row_resize:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "split_v");
+      if (!gdkcursor)
+        gdkcursor =
+            gdk_cursor_new_for_display(defaultDisplay, GDK_SB_V_DOUBLE_ARROW);
+      break;
+    case eCursor_col_resize:
+      gdkcursor = gdk_cursor_new_from_name(defaultDisplay, "split_h");
+      if (!gdkcursor)
+        gdkcursor =
+            gdk_cursor_new_for_display(defaultDisplay, GDK_SB_H_DOUBLE_ARROW);
+      break;
+    case eCursor_none:
+      newType = MOZ_CURSOR_NONE;
+      break;
+    default:
+      NS_ASSERTION(aCursor, "Invalid cursor type");
+      gdkcursor = gdk_cursor_new_for_display(defaultDisplay, GDK_LEFT_PTR);
+      break;
+  }
+
+  // If by now we don't have a xcursor, this means we have to make a custom
+  // one. First, we try creating a named cursor based on the hash of our
+  // custom bitmap, as libXcursor has some magic to convert bitmapped cursors
+  // to themed cursors
+  if (newType != 0xFF && GtkCursors[newType].hash) {
+    gdkcursor =
+        gdk_cursor_new_from_name(defaultDisplay, GtkCursors[newType].hash);
+  }
+
+  // If we still don't have a xcursor, we now really create a bitmap cursor
+  if (newType != 0xff && !gdkcursor) {
+    GdkPixbuf* cursor_pixbuf =
+        gdk_pixbuf_new(GDK_COLORSPACE_RGB, TRUE, 8, 32, 32);
+    if (!cursor_pixbuf) return nullptr;
+
+    guchar* data = gdk_pixbuf_get_pixels(cursor_pixbuf);
+
+    // Read data from GtkCursors and compose RGBA surface from 1bit bitmap and
+    // mask GtkCursors bits and mask are 32x32 monochrome bitmaps (1 bit for
+    // each pixel) so it's 128 byte array (4 bytes for are one bitmap row and
+    // there are 32 rows here).
+    const unsigned char* bits = GtkCursors[newType].bits;
+    const unsigned char* mask_bits = GtkCursors[newType].mask_bits;
+
+    for (int i = 0; i < 128; i++) {
+      char bit = *bits++;
+      char mask = *mask_bits++;
+      for (int j = 0; j < 8; j++) {
+        unsigned char pix = ~(((bit >> j) & 0x01) * 0xff);
+        *data++ = pix;
+        *data++ = pix;
+        *data++ = pix;
+        *data++ = (((mask >> j) & 0x01) * 0xff);
+      }
+    }
+
+    gdkcursor = gdk_cursor_new_from_pixbuf(
+        gdk_display_get_default(), cursor_pixbuf, GtkCursors[newType].hot_x,
+        GtkCursors[newType].hot_y);
+
+    g_object_unref(cursor_pixbuf);
+  }
+
+  gCursorCache[aCursor] = gdkcursor;
+
+  return gdkcursor;
+}
+
+// gtk callbacks
+
+void draw_window_of_widget(GtkWidget* widget, GdkWindow* aWindow, cairo_t* cr) {
+  if (gtk_cairo_should_draw_window(cr, aWindow)) {
+    RefPtr<nsWindow> window = get_window_for_gdk_window(aWindow);
+    if (!window) {
+      NS_WARNING("Cannot get nsWindow from GtkWidget");
+    } else {
+      cairo_save(cr);
+      gtk_cairo_transform_to_window(cr, widget, aWindow);
+      // TODO - window->OnExposeEvent() can destroy this or other windows,
+      // do we need to handle it somehow?
+      window->OnExposeEvent(cr);
+      cairo_restore(cr);
+    }
+  }
+
+  GList* children = gdk_window_get_children(aWindow);
+  GList* child = children;
+  while (child) {
+    GdkWindow* window = GDK_WINDOW(child->data);
+    gpointer windowWidget;
+    gdk_window_get_user_data(window, &windowWidget);
+    if (windowWidget == widget) {
+      draw_window_of_widget(widget, window, cr);
+    }
+    child = g_list_next(child);
+  }
+  g_list_free(children);
+}
+
+/* static */
+gboolean expose_event_cb(GtkWidget* widget, cairo_t* cr) {
+  draw_window_of_widget(widget, gtk_widget_get_window(widget), cr);
+
+  // A strong reference is already held during "draw" signal emission,
+  // but GTK+ 3.4 wants the object to live a little longer than that
+  // (bug 1225970).
+  g_object_ref(widget);
+  g_idle_add(
+      [](gpointer data) -> gboolean {
+        g_object_unref(data);
+        return G_SOURCE_REMOVE;
+      },
+      widget);
+
+  return FALSE;
+}
+
+static gboolean configure_event_cb(GtkWidget* widget,
+                                   GdkEventConfigure* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return FALSE;
+  }
+
+  return window->OnConfigureEvent(widget, event);
+}
+
+static void container_unrealize_cb(GtkWidget* widget) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+
+  window->OnContainerUnrealize();
+}
+
+static void size_allocate_cb(GtkWidget* widget, GtkAllocation* allocation) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+
+  window->OnSizeAllocate(allocation);
+}
+
+static void toplevel_window_size_allocate_cb(GtkWidget* widget,
+                                             GtkAllocation* allocation) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+
+  window->UpdateTopLevelOpaqueRegion();
+}
+
+static gboolean delete_event_cb(GtkWidget* widget, GdkEventAny* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return FALSE;
+  }
+
+  window->OnDeleteEvent();
+
+  return TRUE;
+}
+
+static gboolean enter_notify_event_cb(GtkWidget* widget,
+                                      GdkEventCrossing* event) {
+  RefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
+  if (!window) {
+    return TRUE;
+  }
+
+  window->OnEnterNotifyEvent(event);
+
+  return TRUE;
+}
+
+static gboolean leave_notify_event_cb(GtkWidget* widget,
+                                      GdkEventCrossing* event) {
+  if (is_parent_grab_leave(event)) {
+    return TRUE;
+  }
+
+  // bug 369599: Suppress LeaveNotify events caused by pointer grabs to
+  // avoid generating spurious mouse exit events.
+  auto x = gint(event->x_root);
+  auto y = gint(event->y_root);
+  GdkDisplay* display = gtk_widget_get_display(widget);
+  GdkWindow* winAtPt = gdk_display_get_window_at_pointer(display, &x, &y);
+  if (winAtPt == event->window) {
+    return TRUE;
+  }
+
+  RefPtr<nsWindow> window = get_window_for_gdk_window(event->window);
+  if (!window) return TRUE;
+
+  window->OnLeaveNotifyEvent(event);
+
+  return TRUE;
+}
+
+static nsWindow* GetFirstNSWindowForGDKWindow(GdkWindow* aGdkWindow) {
+  nsWindow* window;
+  while (!(window = get_window_for_gdk_window(aGdkWindow))) {
+    // The event has bubbled to the moz_container widget as passed into each
+    // caller's *widget parameter, but its corresponding nsWindow is an ancestor
+    // of the window that we need.  Instead, look at event->window and find the
+    // first ancestor nsWindow of it because event->window may be in a plugin.
+    aGdkWindow = gdk_window_get_parent(aGdkWindow);
+    if (!aGdkWindow) {
+      window = nullptr;
+      break;
+    }
+  }
+  return window;
+}
+
+static gboolean motion_notify_event_cb(GtkWidget* widget,
+                                       GdkEventMotion* event) {
+  UpdateLastInputEventTime(event);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+  if (!window) return FALSE;
+
+  window->OnMotionNotifyEvent(event);
+
+  return TRUE;
+}
+
+static gboolean button_press_event_cb(GtkWidget* widget,
+                                      GdkEventButton* event) {
+  UpdateLastInputEventTime(event);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+  if (!window) return FALSE;
+
+  window->OnButtonPressEvent(event);
+
+  return TRUE;
+}
+
+static gboolean button_release_event_cb(GtkWidget* widget,
+                                        GdkEventButton* event) {
+  UpdateLastInputEventTime(event);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+  if (!window) return FALSE;
+
+  window->OnButtonReleaseEvent(event);
+
+  return TRUE;
+}
+
+static gboolean focus_in_event_cb(GtkWidget* widget, GdkEventFocus* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  window->OnContainerFocusInEvent(event);
+
+  return FALSE;
+}
+
+static gboolean focus_out_event_cb(GtkWidget* widget, GdkEventFocus* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  window->OnContainerFocusOutEvent(event);
+
+  return FALSE;
+}
+
+#ifdef MOZ_X11
+// For long-lived popup windows that don't really take focus themselves but
+// may have elements that accept keyboard input when the parent window is
+// active, focus is handled specially.  These windows include noautohide
+// panels.  (This special handling is not necessary for temporary popups where
+// the keyboard is grabbed.)
+//
+// Mousing over or clicking on these windows should not cause them to steal
+// focus from their parent windows, so, the input field of WM_HINTS is set to
+// False to request that the window manager not set the input focus to this
+// window.  http://tronche.com/gui/x/icccm/sec-4.html#s-4.1.7
+//
+// However, these windows can still receive WM_TAKE_FOCUS messages from the
+// window manager, so they can still detect when the user has indicated that
+// they wish to direct keyboard input at these windows.  When the window
+// manager offers focus to these windows (after a mouse over or click, for
+// example), a request to make the parent window active is issued.  When the
+// parent window becomes active, keyboard events will be received.
+
+static GdkFilterReturn popup_take_focus_filter(GdkXEvent* gdk_xevent,
+                                               GdkEvent* event, gpointer data) {
+  auto* xevent = static_cast<XEvent*>(gdk_xevent);
+  if (xevent->type != ClientMessage) return GDK_FILTER_CONTINUE;
+
+  XClientMessageEvent& xclient = xevent->xclient;
+  if (xclient.message_type != gdk_x11_get_xatom_by_name("WM_PROTOCOLS"))
+    return GDK_FILTER_CONTINUE;
+
+  Atom atom = xclient.data.l[0];
+  if (atom != gdk_x11_get_xatom_by_name("WM_TAKE_FOCUS"))
+    return GDK_FILTER_CONTINUE;
+
+  guint32 timestamp = xclient.data.l[1];
+
+  GtkWidget* widget = get_gtk_widget_for_gdk_window(event->any.window);
+  if (!widget) return GDK_FILTER_CONTINUE;
+
+  GtkWindow* parent = gtk_window_get_transient_for(GTK_WINDOW(widget));
+  if (!parent) return GDK_FILTER_CONTINUE;
+
+  if (gtk_window_is_active(parent))
+    return GDK_FILTER_REMOVE;  // leave input focus on the parent
+
+  GdkWindow* parent_window = gtk_widget_get_window(GTK_WIDGET(parent));
+  if (!parent_window) return GDK_FILTER_CONTINUE;
+
+  // In case the parent has not been deconified.
+  gdk_window_show_unraised(parent_window);
+
+  // Request focus on the parent window.
+  // Use gdk_window_focus rather than gtk_window_present to avoid
+  // raising the parent window.
+  gdk_window_focus(parent_window, timestamp);
+  return GDK_FILTER_REMOVE;
+}
+#endif /* MOZ_X11 */
+
+static gboolean key_press_event_cb(GtkWidget* widget, GdkEventKey* event) {
+  LOG(("key_press_event_cb\n"));
+
+  UpdateLastInputEventTime(event);
+
+  // find the window with focus and dispatch this event to that widget
+  nsWindow* window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  RefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
+
+#ifdef MOZ_X11
+  // Keyboard repeat can cause key press events to queue up when there are
+  // slow event handlers (bug 301029).  Throttle these events by removing
+  // consecutive pending duplicate KeyPress events to the same window.
+  // We use the event time of the last one.
+  // Note: GDK calls XkbSetDetectableAutorepeat so that KeyRelease events
+  // are generated only when the key is physically released.
+#  define NS_GDKEVENT_MATCH_MASK 0x1FFF  // GDK_SHIFT_MASK .. GDK_BUTTON5_MASK
+  // Our headers undefine X11 KeyPress - let's redefine it here.
+#  ifndef KeyPress
+#    define KeyPress 2
+#  endif
+  GdkDisplay* gdkDisplay = gtk_widget_get_display(widget);
+  if (GDK_IS_X11_DISPLAY(gdkDisplay)) {
+    Display* dpy = GDK_DISPLAY_XDISPLAY(gdkDisplay);
+    while (XPending(dpy)) {
+      XEvent next_event;
+      XPeekEvent(dpy, &next_event);
+      GdkWindow* nextGdkWindow =
+          gdk_x11_window_lookup_for_display(gdkDisplay, next_event.xany.window);
+      if (nextGdkWindow != event->window || next_event.type != KeyPress ||
+          next_event.xkey.keycode != event->hardware_keycode ||
+          next_event.xkey.state != (event->state & NS_GDKEVENT_MATCH_MASK)) {
+        break;
+      }
+      XNextEvent(dpy, &next_event);
+      event->time = next_event.xkey.time;
+    }
+  }
+#endif
+
+  return focusWindow->OnKeyPressEvent(event);
+}
+
+static gboolean key_release_event_cb(GtkWidget* widget, GdkEventKey* event) {
+  LOG(("key_release_event_cb\n"));
+
+  UpdateLastInputEventTime(event);
+
+  // find the window with focus and dispatch this event to that widget
+  nsWindow* window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  RefPtr<nsWindow> focusWindow = gFocusWindow ? gFocusWindow : window;
+
+  return focusWindow->OnKeyReleaseEvent(event);
+}
+
+static gboolean property_notify_event_cb(GtkWidget* aWidget,
+                                         GdkEventProperty* aEvent) {
+  RefPtr<nsWindow> window = get_window_for_gdk_window(aEvent->window);
+  if (!window) return FALSE;
+
+  return window->OnPropertyNotifyEvent(aWidget, aEvent);
+}
+
+static gboolean scroll_event_cb(GtkWidget* widget, GdkEventScroll* event) {
+  nsWindow* window = GetFirstNSWindowForGDKWindow(event->window);
+  if (!window) return FALSE;
+
+  window->OnScrollEvent(event);
+
+  return TRUE;
+}
+
+static void hierarchy_changed_cb(GtkWidget* widget,
+                                 GtkWidget* previous_toplevel) {
+  GtkWidget* toplevel = gtk_widget_get_toplevel(widget);
+  GdkWindowState old_window_state = GDK_WINDOW_STATE_WITHDRAWN;
+  GdkEventWindowState event;
+
+  event.new_window_state = GDK_WINDOW_STATE_WITHDRAWN;
+
+  if (GTK_IS_WINDOW(previous_toplevel)) {
+    g_signal_handlers_disconnect_by_func(
+        previous_toplevel, FuncToGpointer(window_state_event_cb), widget);
+    GdkWindow* win = gtk_widget_get_window(previous_toplevel);
+    if (win) {
+      old_window_state = gdk_window_get_state(win);
+    }
+  }
+
+  if (GTK_IS_WINDOW(toplevel)) {
+    g_signal_connect_swapped(toplevel, "window-state-event",
+                             G_CALLBACK(window_state_event_cb), widget);
+    GdkWindow* win = gtk_widget_get_window(toplevel);
+    if (win) {
+      event.new_window_state = gdk_window_get_state(win);
+    }
+  }
+
+  event.changed_mask =
+      static_cast<GdkWindowState>(old_window_state ^ event.new_window_state);
+
+  if (event.changed_mask) {
+    event.type = GDK_WINDOW_STATE;
+    event.window = nullptr;
+    event.send_event = TRUE;
+    window_state_event_cb(widget, &event);
+  }
+}
+
+static gboolean window_state_event_cb(GtkWidget* widget,
+                                      GdkEventWindowState* event) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) return FALSE;
+
+  window->OnWindowStateEvent(widget, event);
+
+  return FALSE;
+}
+
+static void settings_changed_cb(GtkSettings* settings, GParamSpec* pspec,
+                                nsWindow* data) {
+  RefPtr<nsWindow> window = data;
+  window->ThemeChanged();
+}
+
+static void settings_xft_dpi_changed_cb(GtkSettings* gtk_settings,
+                                        GParamSpec* pspec, nsWindow* data) {
+  RefPtr<nsWindow> window = data;
+  window->OnDPIChanged();
+  // Even though the window size in screen pixels has not changed,
+  // nsViewManager stores the dimensions in app units.
+  // DispatchResized() updates those.
+  window->DispatchResized();
+}
+
+static void check_resize_cb(GtkContainer* container, gpointer user_data) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(GTK_WIDGET(container));
+  if (!window) {
+    return;
+  }
+  window->OnCheckResize();
+}
+
+static void screen_composited_changed_cb(GdkScreen* screen,
+                                         gpointer user_data) {
+  // This callback can run before gfxPlatform::Init() in rare
+  // cases involving the profile manager. When this happens,
+  // we have no reason to reset any compositors as graphics
+  // hasn't been initialized yet.
+  if (GPUProcessManager::Get()) {
+    GPUProcessManager::Get()->ResetCompositors();
+  }
+}
+
+static void widget_composited_changed_cb(GtkWidget* widget,
+                                         gpointer user_data) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+  window->OnCompositedChanged();
+}
+
+static void scale_changed_cb(GtkWidget* widget, GParamSpec* aPSpec,
+                             gpointer aPointer) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(widget);
+  if (!window) {
+    return;
+  }
+
+  GtkAllocation allocation;
+  gtk_widget_get_allocation(widget, &allocation);
+  window->OnScaleChanged(&allocation);
+}
+
+static gboolean touch_event_cb(GtkWidget* aWidget, GdkEventTouch* aEvent) {
+  UpdateLastInputEventTime(aEvent);
+
+  nsWindow* window = GetFirstNSWindowForGDKWindow(aEvent->window);
+  if (!window) {
+    return FALSE;
+  }
+
+  return window->OnTouchEvent(aEvent);
+}
+
+//////////////////////////////////////////////////////////////////////
+// These are all of our drag and drop operations
+
+void nsWindow::InitDragEvent(WidgetDragEvent& aEvent) {
+  // set the keyboard modifiers
+  guint modifierState = KeymapWrapper::GetCurrentModifierState();
+  KeymapWrapper::InitInputEvent(aEvent, modifierState);
+}
+
+gboolean WindowDragMotionHandler(GtkWidget* aWidget,
+                                 GdkDragContext* aDragContext,
+                                 nsWaylandDragContext* aWaylandDragContext,
+                                 gint aX, gint aY, guint aTime) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+  if (!window) return FALSE;
+
+  // figure out which internal widget this drag motion actually happened on
+  nscoord retx = 0;
+  nscoord rety = 0;
+
+  GdkWindow* innerWindow = get_inner_gdk_window(gtk_widget_get_window(aWidget),
+                                                aX, aY, &retx, &rety);
+  RefPtr<nsWindow> innerMostWindow = get_window_for_gdk_window(innerWindow);
+
+  if (!innerMostWindow) {
+    innerMostWindow = window;
+  }
+
+  LOGDRAG(("nsWindow drag-motion signal for %p\n", (void*)innerMostWindow));
+
+  LayoutDeviceIntPoint point = window->GdkPointToDevicePixels({retx, rety});
+
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  return dragService->ScheduleMotionEvent(innerMostWindow, aDragContext,
+                                          aWaylandDragContext, point, aTime);
+}
+
+static gboolean drag_motion_event_cb(GtkWidget* aWidget,
+                                     GdkDragContext* aDragContext, gint aX,
+                                     gint aY, guint aTime, gpointer aData) {
+  return WindowDragMotionHandler(aWidget, aDragContext, nullptr, aX, aY, aTime);
+}
+
+void WindowDragLeaveHandler(GtkWidget* aWidget) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+  if (!window) return;
+
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+
+  nsWindow* mostRecentDragWindow = dragService->GetMostRecentDestWindow();
+  if (!mostRecentDragWindow) {
+    // This can happen when the target will not accept a drop.  A GTK drag
+    // source sends the leave message to the destination before the
+    // drag-failed signal on the source widget, but the leave message goes
+    // via the X server, and so doesn't get processed at least until the
+    // event loop runs again.
+    return;
+  }
+
+  GtkWidget* mozContainer = mostRecentDragWindow->GetMozContainerWidget();
+  if (aWidget != mozContainer) {
+    // When the drag moves between widgets, GTK can send leave signal for
+    // the old widget after the motion or drop signal for the new widget.
+    // We'll send the leave event when the motion or drop event is run.
+    return;
+  }
+
+  LOGDRAG(("nsWindow drag-leave signal for %p\n", (void*)mostRecentDragWindow));
+
+  dragService->ScheduleLeaveEvent();
+}
+
+static void drag_leave_event_cb(GtkWidget* aWidget,
+                                GdkDragContext* aDragContext, guint aTime,
+                                gpointer aData) {
+  WindowDragLeaveHandler(aWidget);
+}
+
+gboolean WindowDragDropHandler(GtkWidget* aWidget, GdkDragContext* aDragContext,
+                               nsWaylandDragContext* aWaylandDragContext,
+                               gint aX, gint aY, guint aTime) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+  if (!window) return FALSE;
+
+  // figure out which internal widget this drag motion actually happened on
+  nscoord retx = 0;
+  nscoord rety = 0;
+
+  GdkWindow* innerWindow = get_inner_gdk_window(gtk_widget_get_window(aWidget),
+                                                aX, aY, &retx, &rety);
+  RefPtr<nsWindow> innerMostWindow = get_window_for_gdk_window(innerWindow);
+
+  if (!innerMostWindow) {
+    innerMostWindow = window;
+  }
+
+  LOGDRAG(("nsWindow drag-drop signal for %p\n", (void*)innerMostWindow));
+
+  LayoutDeviceIntPoint point = window->GdkPointToDevicePixels({retx, rety});
+
+  RefPtr<nsDragService> dragService = nsDragService::GetInstance();
+  return dragService->ScheduleDropEvent(innerMostWindow, aDragContext,
+                                        aWaylandDragContext, point, aTime);
+}
+
+static gboolean drag_drop_event_cb(GtkWidget* aWidget,
+                                   GdkDragContext* aDragContext, gint aX,
+                                   gint aY, guint aTime, gpointer aData) {
+  return WindowDragDropHandler(aWidget, aDragContext, nullptr, aX, aY, aTime);
+}
+
+static void drag_data_received_event_cb(GtkWidget* aWidget,
+                                        GdkDragContext* aDragContext, gint aX,
+                                        gint aY,
+                                        GtkSelectionData* aSelectionData,
+                                        guint aInfo, guint aTime,
+                                        gpointer aData) {
+  RefPtr<nsWindow> window = get_window_for_gtk_widget(aWidget);
+  if (!window) return;
+
+  window->OnDragDataReceivedEvent(aWidget, aDragContext, aX, aY, aSelectionData,
+                                  aInfo, aTime, aData);
+}
+
+static nsresult initialize_prefs(void) {
+  gRaiseWindows =
+      Preferences::GetBool("mozilla.widget.raise-on-setfocus", true);
+  gUseWaylandVsync =
+      Preferences::GetBool("widget.wayland_vsync.enabled", false);
+  gUseWaylandUseOpaqueRegion =
+      Preferences::GetBool("widget.wayland.use-opaque-region", false);
+
+  if (Preferences::HasUserValue("widget.use-aspect-ratio")) {
+    gUseAspectRatio = Preferences::GetBool("widget.use-aspect-ratio", true);
+  } else {
+    static const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+    gUseAspectRatio =
+        currentDesktop ? (strstr(currentDesktop, "GNOME") != nullptr) : false;
+  }
+
+  return NS_OK;
+}
+
+static GdkWindow* get_inner_gdk_window(GdkWindow* aWindow, gint x, gint y,
+                                       gint* retx, gint* rety) {
+  gint cx, cy, cw, ch;
+  GList* children = gdk_window_peek_children(aWindow);
+  for (GList* child = g_list_last(children); child;
+       child = g_list_previous(child)) {
+    auto* childWindow = (GdkWindow*)child->data;
+    if (get_window_for_gdk_window(childWindow)) {
+      gdk_window_get_geometry(childWindow, &cx, &cy, &cw, &ch);
+      if ((cx < x) && (x < (cx + cw)) && (cy < y) && (y < (cy + ch)) &&
+          gdk_window_is_visible(childWindow)) {
+        return get_inner_gdk_window(childWindow, x - cx, y - cy, retx, rety);
+      }
+    }
+  }
+  *retx = x;
+  *rety = y;
+  return aWindow;
+}
+
+static int is_parent_ungrab_enter(GdkEventCrossing* aEvent) {
+  return (GDK_CROSSING_UNGRAB == aEvent->mode) &&
+         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
+          (GDK_NOTIFY_VIRTUAL == aEvent->detail));
+}
+
+static int is_parent_grab_leave(GdkEventCrossing* aEvent) {
+  return (GDK_CROSSING_GRAB == aEvent->mode) &&
+         ((GDK_NOTIFY_ANCESTOR == aEvent->detail) ||
+          (GDK_NOTIFY_VIRTUAL == aEvent->detail));
+}
+
+#ifdef ACCESSIBILITY
+void nsWindow::CreateRootAccessible() {
+  if (mIsTopLevel && !mRootAccessible) {
+    LOG(("nsWindow:: Create Toplevel Accessibility\n"));
+    mRootAccessible = GetRootAccessible();
+  }
+}
+
+void nsWindow::DispatchEventToRootAccessible(uint32_t aEventType) {
+  if (!a11y::ShouldA11yBeEnabled()) {
+    return;
+  }
+
+  nsAccessibilityService* accService = GetOrCreateAccService();
+  if (!accService) {
+    return;
+  }
+
+  // Get the root document accessible and fire event to it.
+  a11y::Accessible* acc = GetRootAccessible();
+  if (acc) {
+    accService->FireAccessibleEvent(aEventType, acc);
+  }
+}
+
+void nsWindow::DispatchActivateEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_ACTIVATE);
+}
+
+void nsWindow::DispatchDeactivateEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_DEACTIVATE);
+}
+
+void nsWindow::DispatchMaximizeEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MAXIMIZE);
+}
+
+void nsWindow::DispatchMinimizeEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_MINIMIZE);
+}
+
+void nsWindow::DispatchRestoreEventAccessible(void) {
+  DispatchEventToRootAccessible(nsIAccessibleEvent::EVENT_WINDOW_RESTORE);
+}
+
+#endif /* #ifdef ACCESSIBILITY */
+
+void nsWindow::SetInputContext(const InputContext& aContext,
+                               const InputContextAction& aAction) {
+  if (!mIMContext) {
+    return;
+  }
+  mIMContext->SetInputContext(this, &aContext, &aAction);
+}
+
+InputContext nsWindow::GetInputContext() {
+  InputContext context;
+  if (!mIMContext) {
+    context.mIMEState.mEnabled = IMEState::DISABLED;
+    context.mIMEState.mOpen = IMEState::OPEN_STATE_NOT_SUPPORTED;
+  } else {
+    context = mIMContext->GetInputContext();
+  }
+  return context;
+}
+
+TextEventDispatcherListener* nsWindow::GetNativeTextEventDispatcherListener() {
+  if (NS_WARN_IF(!mIMContext)) {
+    return nullptr;
+  }
+  return mIMContext;
+}
+
+void nsWindow::GetEditCommandsRemapped(NativeKeyBindingsType aType,
+                                       const WidgetKeyboardEvent& aEvent,
+                                       nsTArray<CommandInt>& aCommands,
+                                       uint32_t aGeckoKeyCode,
+                                       uint32_t aNativeKeyCode) {
+  // If aEvent.mNativeKeyEvent is nullptr, the event was created by chrome
+  // script.  In such case, we shouldn't expose the OS settings to it.
+  // So, just ignore such events here.
+  if (!aEvent.mNativeKeyEvent) {
+    return;
+  }
+  WidgetKeyboardEvent modifiedEvent(aEvent);
+  modifiedEvent.mKeyCode = aGeckoKeyCode;
+  static_cast<GdkEventKey*>(modifiedEvent.mNativeKeyEvent)->keyval =
+      aNativeKeyCode;
+
+  NativeKeyBindings* keyBindings = NativeKeyBindings::GetInstance(aType);
+  keyBindings->GetEditCommands(modifiedEvent, aCommands);
+}
+
+bool nsWindow::GetEditCommands(NativeKeyBindingsType aType,
+                               const WidgetKeyboardEvent& aEvent,
+                               nsTArray<CommandInt>& aCommands) {
+  // Validate the arguments.
+  if (NS_WARN_IF(!nsIWidget::GetEditCommands(aType, aEvent, aCommands))) {
+    return false;
+  }
+
+  if (aEvent.mKeyCode >= NS_VK_LEFT && aEvent.mKeyCode <= NS_VK_DOWN) {
+    // Check if we're targeting content with vertical writing mode,
+    // and if so remap the arrow keys.
+    // XXX This may be expensive.
+    WidgetQueryContentEvent querySelectedTextEvent(true, eQuerySelectedText,
+                                                   this);
+    nsEventStatus status;
+    DispatchEvent(&querySelectedTextEvent, status);
+
+    if (querySelectedTextEvent.FoundSelection() &&
+        querySelectedTextEvent.mReply->mWritingMode.IsVertical()) {
+      uint32_t geckoCode = 0;
+      uint32_t gdkCode = 0;
+      switch (aEvent.mKeyCode) {
+        case NS_VK_LEFT:
+          if (querySelectedTextEvent.mReply->mWritingMode.IsVerticalLR()) {
+            geckoCode = NS_VK_UP;
+            gdkCode = GDK_Up;
+          } else {
+            geckoCode = NS_VK_DOWN;
+            gdkCode = GDK_Down;
+          }
+          break;
+
+        case NS_VK_RIGHT:
+          if (querySelectedTextEvent.mReply->mWritingMode.IsVerticalLR()) {
+            geckoCode = NS_VK_DOWN;
+            gdkCode = GDK_Down;
+          } else {
+            geckoCode = NS_VK_UP;
+            gdkCode = GDK_Up;
+          }
+          break;
+
+        case NS_VK_UP:
+          geckoCode = NS_VK_LEFT;
+          gdkCode = GDK_Left;
+          break;
+
+        case NS_VK_DOWN:
+          geckoCode = NS_VK_RIGHT;
+          gdkCode = GDK_Right;
+          break;
+      }
+
+      GetEditCommandsRemapped(aType, aEvent, aCommands, geckoCode, gdkCode);
+      return true;
+    }
+  }
+
+  NativeKeyBindings* keyBindings = NativeKeyBindings::GetInstance(aType);
+  keyBindings->GetEditCommands(aEvent, aCommands);
+  return true;
+}
+
+already_AddRefed<DrawTarget> nsWindow::StartRemoteDrawingInRegion(
+    LayoutDeviceIntRegion& aInvalidRegion, BufferMode* aBufferMode) {
+  return mSurfaceProvider.StartRemoteDrawingInRegion(aInvalidRegion,
+                                                     aBufferMode);
+}
+
+void nsWindow::EndRemoteDrawingInRegion(
+    DrawTarget* aDrawTarget, const LayoutDeviceIntRegion& aInvalidRegion) {
+  mSurfaceProvider.EndRemoteDrawingInRegion(aDrawTarget, aInvalidRegion);
+}
+
+// Code shared begin BeginMoveDrag and BeginResizeDrag
+bool nsWindow::GetDragInfo(WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
+                           gint* aButton, gint* aRootX, gint* aRootY) {
+  if (aMouseEvent->mButton != MouseButton::ePrimary) {
+    // we can only begin a move drag with the left mouse button
+    return false;
+  }
+  *aButton = 1;
+
+  // get the gdk window for this widget
+  GdkWindow* gdk_window = mGdkWindow;
+  if (!gdk_window) {
+    return false;
+  }
+#ifdef DEBUG
+  // GDK_IS_WINDOW(...) expands to a statement-expression, and
+  // statement-expressions are not allowed in template-argument lists. So we
+  // have to make the MOZ_ASSERT condition indirect.
+  if (!GDK_IS_WINDOW(gdk_window)) {
+    MOZ_ASSERT(false, "must really be window");
+  }
+#endif
+
+  // find the top-level window
+  gdk_window = gdk_window_get_toplevel(gdk_window);
+  MOZ_ASSERT(gdk_window, "gdk_window_get_toplevel should not return null");
+  *aWindow = gdk_window;
+
+  if (!aMouseEvent->mWidget) {
+    return false;
+  }
+
+#ifdef MOZ_X11
+  if (mIsX11Display) {
+    // Workaround for https://bugzilla.gnome.org/show_bug.cgi?id=789054
+    // To avoid crashes disable double-click on WM without _NET_WM_MOVERESIZE.
+    // See _should_perform_ewmh_drag() at gdkwindow-x11.c
+    GdkScreen* screen = gdk_window_get_screen(gdk_window);
+    GdkAtom atom = gdk_atom_intern("_NET_WM_MOVERESIZE", FALSE);
+    if (!gdk_x11_screen_supports_net_wm_hint(screen, atom)) {
+      static unsigned int lastTimeStamp = 0;
+      if (lastTimeStamp != aMouseEvent->mTime) {
+        lastTimeStamp = aMouseEvent->mTime;
+      } else {
+        return false;
+      }
+    }
+  }
+#endif
+
+  // FIXME: It would be nice to have the widget position at the time
+  // of the event, but it's relatively unlikely that the widget has
+  // moved since the mousedown.  (On the other hand, it's quite likely
+  // that the mouse has moved, which is why we use the mouse position
+  // from the event.)
+  LayoutDeviceIntPoint offset = aMouseEvent->mWidget->WidgetToScreenOffset();
+  *aRootX = aMouseEvent->mRefPoint.x + offset.x;
+  *aRootY = aMouseEvent->mRefPoint.y + offset.y;
+
+  return true;
+}
+
+nsresult nsWindow::BeginResizeDrag(WidgetGUIEvent* aEvent, int32_t aHorizontal,
+                                   int32_t aVertical) {
+  NS_ENSURE_ARG_POINTER(aEvent);
+
+  if (aEvent->mClass != eMouseEventClass) {
+    // you can only begin a resize drag with a mouse event
+    return NS_ERROR_INVALID_ARG;
+  }
+
+  GdkWindow* gdk_window;
+  gint button, screenX, screenY;
+  if (!GetDragInfo(aEvent->AsMouseEvent(), &gdk_window, &button, &screenX,
+                   &screenY)) {
+    return NS_ERROR_FAILURE;
+  }
+
+  // work out what GdkWindowEdge we're talking about
+  GdkWindowEdge window_edge;
+  if (aVertical < 0) {
+    if (aHorizontal < 0) {
+      window_edge = GDK_WINDOW_EDGE_NORTH_WEST;
+    } else if (aHorizontal == 0) {
+      window_edge = GDK_WINDOW_EDGE_NORTH;
+    } else {
+      window_edge = GDK_WINDOW_EDGE_NORTH_EAST;
+    }
+  } else if (aVertical == 0) {
+    if (aHorizontal < 0) {
+      window_edge = GDK_WINDOW_EDGE_WEST;
+    } else if (aHorizontal == 0) {
+      return NS_ERROR_INVALID_ARG;
+    } else {
+      window_edge = GDK_WINDOW_EDGE_EAST;
+    }
+  } else {
+    if (aHorizontal < 0) {
+      window_edge = GDK_WINDOW_EDGE_SOUTH_WEST;
+    } else if (aHorizontal == 0) {
+      window_edge = GDK_WINDOW_EDGE_SOUTH;
+    } else {
+      window_edge = GDK_WINDOW_EDGE_SOUTH_EAST;
+    }
+  }
+
+  // tell the window manager to start the resize
+  gdk_window_begin_resize_drag(gdk_window, window_edge, button, screenX,
+                               screenY, aEvent->mTime);
+
+  return NS_OK;
+}
+
+nsIWidget::LayerManager* nsWindow::GetLayerManager(
+    PLayerTransactionChild* aShadowManager, LayersBackend aBackendHint,
+    LayerManagerPersistence aPersistence) {
+  if (mIsDestroyed) {
+    // Prevent external code from triggering the re-creation of the
+    // LayerManager/Compositor during shutdown. Just return what we currently
+    // have, which is most likely null.
+    return mLayerManager;
+  }
+
+  return nsBaseWidget::GetLayerManager(aShadowManager, aBackendHint,
+                                       aPersistence);
+}
+
+void nsWindow::SetCompositorWidgetDelegate(CompositorWidgetDelegate* delegate) {
+  if (delegate) {
+    mCompositorWidgetDelegate = delegate->AsPlatformSpecificDelegate();
+    MOZ_ASSERT(mCompositorWidgetDelegate,
+               "nsWindow::SetCompositorWidgetDelegate called with a "
+               "non-PlatformCompositorWidgetDelegate");
+#ifdef MOZ_WAYLAND
+    MaybeResumeCompositor();
+#endif
+  } else {
+    mCompositorWidgetDelegate = nullptr;
+  }
+}
+
+void nsWindow::ClearCachedResources() {
+  if (mLayerManager && mLayerManager->GetBackendType() ==
+                           mozilla::layers::LayersBackend::LAYERS_BASIC) {
+    mLayerManager->ClearCachedResources();
+  }
+
+  GList* children = gdk_window_peek_children(mGdkWindow);
+  for (GList* list = children; list; list = list->next) {
+    nsWindow* window = get_window_for_gdk_window(GDK_WINDOW(list->data));
+    if (window) {
+      window->ClearCachedResources();
+    }
+  }
+}
+
+/* nsWindow::UpdateClientOffsetFromCSDWindow() is designed to be called from
+ * nsWindow::OnConfigureEvent() when mContainer window is already positioned.
+ *
+ * It works only for CSD decorated GtkWindow.
+ */
+void nsWindow::UpdateClientOffsetFromCSDWindow() {
+  int x, y;
+  gdk_window_get_position(mGdkWindow, &x, &y);
+
+  x = GdkCoordToDevicePixels(x);
+  y = GdkCoordToDevicePixels(y);
+
+  if (mClientOffset.x != x || mClientOffset.y != y) {
+    mClientOffset = nsIntPoint(x, y);
+
+    LOG(("nsWindow::UpdateClientOffsetFromCSDWindow [%p] %d, %d\n", (void*)this,
+         mClientOffset.x, mClientOffset.y));
+
+    // Send a WindowMoved notification. This ensures that BrowserParent
+    // picks up the new client offset and sends it to the child process
+    // if appropriate.
+    NotifyWindowMoved(mBounds.x, mBounds.y);
+  }
+}
+
+nsresult nsWindow::SetNonClientMargins(LayoutDeviceIntMargin& aMargins) {
+  SetDrawsInTitlebar(aMargins.top == 0);
+  return NS_OK;
+}
+
+void nsWindow::SetDrawsInTitlebar(bool aState) {
+  LOG(("nsWindow::SetDrawsInTitlebar() [%p] State %d mCSDSupportLevel %d\n",
+       (void*)this, aState, (int)mCSDSupportLevel));
+
+  if (!mShell || mCSDSupportLevel == CSD_SUPPORT_NONE ||
+      aState == mDrawInTitlebar) {
+    return;
+  }
+
+  if (mCSDSupportLevel == CSD_SUPPORT_SYSTEM) {
+    SetWindowDecoration(aState ? eBorderStyle_border : mBorderStyle);
+  } else if (mCSDSupportLevel == CSD_SUPPORT_CLIENT) {
+    LOG(("    Using CSD mode\n"));
+
+    /* Window manager does not support GDK_DECOR_BORDER,
+     * emulate it by CSD.
+     *
+     * gtk_window_set_titlebar() works on unrealized widgets only,
+     * we need to handle mShell carefully here.
+     * When CSD is enabled mGdkWindow is owned by mContainer which is good
+     * as we can't delete our mGdkWindow. To make mShell unrealized while
+     * mContainer is preserved we temporary reparent mContainer to an
+     * invisible GtkWindow.
+     */
+    NativeShow(false);
+
+    // Using GTK_WINDOW_POPUP rather than
+    // GTK_WINDOW_TOPLEVEL in the hope that POPUP results in less
+    // initialization and window manager interaction.
+    GtkWidget* tmpWindow = gtk_window_new(GTK_WINDOW_POPUP);
+    gtk_widget_realize(tmpWindow);
+
+    gtk_widget_reparent(GTK_WIDGET(mContainer), tmpWindow);
+    gtk_widget_unrealize(GTK_WIDGET(mShell));
+
+    if (aState) {
+      // Add a hidden titlebar widget to trigger CSD, but disable the default
+      // titlebar.  GtkFixed is a somewhat random choice for a simple unused
+      // widget. gtk_window_set_titlebar() takes ownership of the titlebar
+      // widget.
+      gtk_window_set_titlebar(GTK_WINDOW(mShell), gtk_fixed_new());
+    } else {
+      gtk_window_set_titlebar(GTK_WINDOW(mShell), nullptr);
+    }
+
+    /* A workaround for https://bugzilla.gnome.org/show_bug.cgi?id=791081
+     * gtk_widget_realize() throws:
+     * "In pixman_region32_init_rect: Invalid rectangle passed"
+     * when mShell has default 1x1 size.
+     */
+    GtkAllocation allocation = {0, 0, 0, 0};
+    gtk_widget_get_preferred_width(GTK_WIDGET(mShell), nullptr,
+                                   &allocation.width);
+    gtk_widget_get_preferred_height(GTK_WIDGET(mShell), nullptr,
+                                    &allocation.height);
+    gtk_widget_size_allocate(GTK_WIDGET(mShell), &allocation);
+
+    gtk_widget_realize(GTK_WIDGET(mShell));
+    gtk_widget_reparent(GTK_WIDGET(mContainer), GTK_WIDGET(mShell));
+    mNeedsShow = true;
+    NativeResize();
+
+    // Label mShell toplevel window so property_notify_event_cb callback
+    // can find its way home.
+    g_object_set_data(G_OBJECT(gtk_widget_get_window(mShell)), "nsWindow",
+                      this);
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
+    SetCompositorHint(GTK_WIDGET_COMPOSIDED_ENABLED);
+#endif
+    RefreshWindowClass();
+
+    gtk_widget_destroy(tmpWindow);
+  }
+
+  mDrawInTitlebar = aState;
+
+  if (mTransparencyBitmapForTitlebar) {
+    if (mDrawInTitlebar && mSizeState == nsSizeMode_Normal && !mIsTiled) {
+      UpdateTitlebarTransparencyBitmap();
+    } else {
+      ClearTransparencyBitmap();
+    }
+  }
+}
+
+GtkWindow* nsWindow::GetCurrentTopmostWindow() {
+  GtkWindow* parentWindow = GTK_WINDOW(GetGtkWidget());
+  GtkWindow* topmostParentWindow = nullptr;
+  while (parentWindow) {
+    topmostParentWindow = parentWindow;
+    parentWindow = gtk_window_get_transient_for(parentWindow);
+  }
+  return topmostParentWindow;
+}
+
+gint nsWindow::GdkScaleFactor() {
+  // We depend on notify::scale-factor callback which is reliable for toplevel
+  // windows only, so don't use scale cache for popup windows.
+  if (mWindowType == eWindowType_toplevel && !mWindowScaleFactorChanged) {
+    return mWindowScaleFactor;
+  }
+
+  GdkWindow* scaledGdkWindow = mGdkWindow;
+  if (!mIsX11Display) {
+    // For popup windows/dialogs with parent window we need to get scale factor
+    // of the topmost window. Otherwise the scale factor of the popup is
+    // not updated during it's hidden.
+    if (mWindowType == eWindowType_popup || mWindowType == eWindowType_dialog) {
+      // Get toplevel window for scale factor:
+      GtkWindow* topmostParentWindow = GetCurrentTopmostWindow();
+      if (topmostParentWindow) {
+        scaledGdkWindow =
+            gtk_widget_get_window(GTK_WIDGET(topmostParentWindow));
+      } else {
+        NS_WARNING("Popup/Dialog has no parent.");
+      }
+      // Fallback for windows which parent has been unrealized.
+      if (!scaledGdkWindow) {
+        scaledGdkWindow = mGdkWindow;
+      }
+    }
+  }
+
+  // Available as of GTK 3.10+
+  static auto sGdkWindowGetScaleFactorPtr =
+      (gint(*)(GdkWindow*))dlsym(RTLD_DEFAULT, "gdk_window_get_scale_factor");
+  if (sGdkWindowGetScaleFactorPtr && scaledGdkWindow) {
+    mWindowScaleFactor = (*sGdkWindowGetScaleFactorPtr)(scaledGdkWindow);
+  } else {
+    mWindowScaleFactor = ScreenHelperGTK::GetGTKMonitorScaleFactor();
+  }
+  mWindowScaleFactorChanged = false;
+
+  return mWindowScaleFactor;
+}
+
+gint nsWindow::DevicePixelsToGdkCoordRoundUp(int pixels) {
+  gint scale = GdkScaleFactor();
+  return (pixels + scale - 1) / scale;
+}
+
+gint nsWindow::DevicePixelsToGdkCoordRoundDown(int pixels) {
+  gint scale = GdkScaleFactor();
+  return pixels / scale;
+}
+
+GdkPoint nsWindow::DevicePixelsToGdkPointRoundDown(LayoutDeviceIntPoint point) {
+  gint scale = GdkScaleFactor();
+  return {point.x / scale, point.y / scale};
+}
+
+GdkRectangle nsWindow::DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect rect) {
+  gint scale = GdkScaleFactor();
+  int x = rect.x / scale;
+  int y = rect.y / scale;
+  int right = (rect.x + rect.width + scale - 1) / scale;
+  int bottom = (rect.y + rect.height + scale - 1) / scale;
+  return {x, y, right - x, bottom - y};
+}
+
+GdkRectangle nsWindow::DevicePixelsToGdkSizeRoundUp(
+    LayoutDeviceIntSize pixelSize) {
+  gint scale = GdkScaleFactor();
+  gint width = (pixelSize.width + scale - 1) / scale;
+  gint height = (pixelSize.height + scale - 1) / scale;
+  return {0, 0, width, height};
+}
+
+int nsWindow::GdkCoordToDevicePixels(gint coord) {
+  return coord * GdkScaleFactor();
+}
+
+LayoutDeviceIntPoint nsWindow::GdkEventCoordsToDevicePixels(gdouble x,
+                                                            gdouble y) {
+  gint scale = GdkScaleFactor();
+  return LayoutDeviceIntPoint::Round(x * scale, y * scale);
+}
+
+LayoutDeviceIntPoint nsWindow::GdkPointToDevicePixels(GdkPoint point) {
+  gint scale = GdkScaleFactor();
+  return LayoutDeviceIntPoint(point.x * scale, point.y * scale);
+}
+
+LayoutDeviceIntRect nsWindow::GdkRectToDevicePixels(GdkRectangle rect) {
+  gint scale = GdkScaleFactor();
+  return LayoutDeviceIntRect(rect.x * scale, rect.y * scale, rect.width * scale,
+                             rect.height * scale);
+}
+
+nsresult nsWindow::SynthesizeNativeMouseEvent(LayoutDeviceIntPoint aPoint,
+                                              uint32_t aNativeMessage,
+                                              uint32_t aModifierFlags,
+                                              nsIObserver* aObserver) {
+  AutoObserverNotifier notifier(aObserver, "mouseevent");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  GdkDisplay* display = gdk_window_get_display(mGdkWindow);
+
+  // When a button-press/release event is requested, create it here and put it
+  // in the event queue. This will not emit a motion event - this needs to be
+  // done explicitly *before* requesting a button-press/release. You will also
+  // need to wait for the motion event to be dispatched before requesting a
+  // button-press/release event to maintain the desired event order.
+  if (aNativeMessage == GDK_BUTTON_PRESS ||
+      aNativeMessage == GDK_BUTTON_RELEASE) {
+    GdkEvent event;
+    memset(&event, 0, sizeof(GdkEvent));
+    event.type = (GdkEventType)aNativeMessage;
+    event.button.button = 1;
+    event.button.window = mGdkWindow;
+    event.button.time = GDK_CURRENT_TIME;
+
+    // Get device for event source
+    GdkDeviceManager* device_manager = gdk_display_get_device_manager(display);
+    event.button.device = gdk_device_manager_get_client_pointer(device_manager);
+
+    event.button.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+    event.button.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+    LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+    event.button.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+    event.button.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+    gdk_event_put(&event);
+  } else {
+    // We don't support specific events other than button-press/release. In all
+    // other cases we'll synthesize a motion event that will be emitted by
+    // gdk_display_warp_pointer().
+    GdkScreen* screen = gdk_window_get_screen(mGdkWindow);
+    GdkPoint point = DevicePixelsToGdkPointRoundDown(aPoint);
+    gdk_display_warp_pointer(display, screen, point.x, point.y);
+  }
+
+  return NS_OK;
+}
+
+nsresult nsWindow::SynthesizeNativeMouseScrollEvent(
+    mozilla::LayoutDeviceIntPoint aPoint, uint32_t aNativeMessage,
+    double aDeltaX, double aDeltaY, double aDeltaZ, uint32_t aModifierFlags,
+    uint32_t aAdditionalFlags, nsIObserver* aObserver) {
+  AutoObserverNotifier notifier(aObserver, "mousescrollevent");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  GdkEvent event;
+  memset(&event, 0, sizeof(GdkEvent));
+  event.type = GDK_SCROLL;
+  event.scroll.window = mGdkWindow;
+  event.scroll.time = GDK_CURRENT_TIME;
+  // Get device for event source
+  GdkDisplay* display = gdk_window_get_display(mGdkWindow);
+  GdkDeviceManager* device_manager = gdk_display_get_device_manager(display);
+  event.scroll.device = gdk_device_manager_get_client_pointer(device_manager);
+  event.scroll.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+  event.scroll.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+  LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+  event.scroll.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+  event.scroll.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+  // The delta values are backwards on Linux compared to Windows and Cocoa,
+  // hence the negation.
+  event.scroll.direction = GDK_SCROLL_SMOOTH;
+  event.scroll.delta_x = -aDeltaX;
+  event.scroll.delta_y = -aDeltaY;
+
+  gdk_event_put(&event);
+
+  return NS_OK;
+}
+
+nsresult nsWindow::SynthesizeNativeTouchPoint(uint32_t aPointerId,
+                                              TouchPointerState aPointerState,
+                                              LayoutDeviceIntPoint aPoint,
+                                              double aPointerPressure,
+                                              uint32_t aPointerOrientation,
+                                              nsIObserver* aObserver) {
+  AutoObserverNotifier notifier(aObserver, "touchpoint");
+
+  if (!mGdkWindow) {
+    return NS_OK;
+  }
+
+  GdkEvent event;
+  memset(&event, 0, sizeof(GdkEvent));
+
+  static std::map<uint32_t, GdkEventSequence*> sKnownPointers;
+
+  auto result = sKnownPointers.find(aPointerId);
+  switch (aPointerState) {
+    case TOUCH_CONTACT:
+      if (result == sKnownPointers.end()) {
+        // GdkEventSequence isn't a thing we can instantiate, and never gets
+        // dereferenced in the gtk code. It's an opaque pointer, the only
+        // requirement is that it be distinct from other instances of
+        // GdkEventSequence*.
+        event.touch.sequence = (GdkEventSequence*)((uintptr_t)aPointerId);
+        sKnownPointers[aPointerId] = event.touch.sequence;
+        event.type = GDK_TOUCH_BEGIN;
+      } else {
+        event.touch.sequence = result->second;
+        event.type = GDK_TOUCH_UPDATE;
+      }
+      break;
+    case TOUCH_REMOVE:
+      event.type = GDK_TOUCH_END;
+      if (result == sKnownPointers.end()) {
+        NS_WARNING("Tried to synthesize touch-end for unknown pointer!");
+        return NS_ERROR_UNEXPECTED;
+      }
+      event.touch.sequence = result->second;
+      sKnownPointers.erase(result);
+      break;
+    case TOUCH_CANCEL:
+      event.type = GDK_TOUCH_CANCEL;
+      if (result == sKnownPointers.end()) {
+        NS_WARNING("Tried to synthesize touch-cancel for unknown pointer!");
+        return NS_ERROR_UNEXPECTED;
+      }
+      event.touch.sequence = result->second;
+      sKnownPointers.erase(result);
+      break;
+    case TOUCH_HOVER:
+    default:
+      return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  event.touch.window = mGdkWindow;
+  event.touch.time = GDK_CURRENT_TIME;
+
+  GdkDisplay* display = gdk_window_get_display(mGdkWindow);
+  GdkDeviceManager* device_manager = gdk_display_get_device_manager(display);
+  event.touch.device = gdk_device_manager_get_client_pointer(device_manager);
+
+  event.touch.x_root = DevicePixelsToGdkCoordRoundDown(aPoint.x);
+  event.touch.y_root = DevicePixelsToGdkCoordRoundDown(aPoint.y);
+
+  LayoutDeviceIntPoint pointInWindow = aPoint - WidgetToScreenOffset();
+  event.touch.x = DevicePixelsToGdkCoordRoundDown(pointInWindow.x);
+  event.touch.y = DevicePixelsToGdkCoordRoundDown(pointInWindow.y);
+
+  gdk_event_put(&event);
+
+  return NS_OK;
+}
+
+nsWindow::CSDSupportLevel nsWindow::GetSystemCSDSupportLevel(bool aIsPopup) {
+  if (sCSDSupportLevel != CSD_SUPPORT_UNKNOWN) {
+    return sCSDSupportLevel;
+  }
+
+  // Allow MOZ_GTK_TITLEBAR_DECORATION to override our heuristics
+  const char* decorationOverride = getenv("MOZ_GTK_TITLEBAR_DECORATION");
+  if (decorationOverride) {
+    if (strcmp(decorationOverride, "none") == 0) {
+      sCSDSupportLevel = CSD_SUPPORT_NONE;
+    } else if (strcmp(decorationOverride, "client") == 0) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    } else if (strcmp(decorationOverride, "system") == 0) {
+      sCSDSupportLevel = CSD_SUPPORT_SYSTEM;
+    }
+    return sCSDSupportLevel;
+  }
+
+#ifdef MOZ_WAYLAND
+  // nsWindow::GetSystemCSDSupportLevel can be called from various threads
+  // so we can't use gfxPlatformGtk here.
+  if (GDK_IS_WAYLAND_DISPLAY(gdk_display_get_default())) {
+    sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    return sCSDSupportLevel;
+  }
+#endif
+
+#ifdef MOZ_X11
+  const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+  if (currentDesktop) {
+    // GNOME Flashback (fallback)
+    if (strstr(currentDesktop, "GNOME-Flashback:GNOME") != nullptr) {
+      sCSDSupportLevel = aIsPopup ? CSD_SUPPORT_CLIENT : CSD_SUPPORT_SYSTEM;
+      // Pop Linux Bug 1629198
+    } else if (strstr(currentDesktop, "pop:GNOME") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+      // gnome-shell
+    } else if (strstr(currentDesktop, "GNOME") != nullptr) {
+      sCSDSupportLevel = aIsPopup ? CSD_SUPPORT_CLIENT : CSD_SUPPORT_SYSTEM;
+    } else if (strstr(currentDesktop, "XFCE") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    } else if (strstr(currentDesktop, "X-Cinnamon") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_SYSTEM;
+      // KDE Plasma
+    } else if (strstr(currentDesktop, "KDE") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    } else if (strstr(currentDesktop, "Enlightenment") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    } else if (strstr(currentDesktop, "LXDE") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    } else if (strstr(currentDesktop, "openbox") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    } else if (strstr(currentDesktop, "i3") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_NONE;
+    } else if (strstr(currentDesktop, "MATE") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+      // Ubuntu Unity
+    } else if (strstr(currentDesktop, "Unity") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_SYSTEM;
+      // Elementary OS
+    } else if (strstr(currentDesktop, "Pantheon") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_SYSTEM;
+    } else if (strstr(currentDesktop, "LXQt") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_SYSTEM;
+    } else if (strstr(currentDesktop, "Deepin") != nullptr) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    } else {
+// Release or beta builds are not supposed to be broken
+// so disable titlebar rendering on untested/unknown systems.
+#if defined(RELEASE_OR_BETA)
+      sCSDSupportLevel = CSD_SUPPORT_NONE;
+#else
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+#endif
+    }
+  } else {
+    sCSDSupportLevel = CSD_SUPPORT_NONE;
+  }
+
+  // GTK_CSD forces CSD mode - use also CSD because window manager
+  // decorations does not work with CSD.
+  // We check GTK_CSD as well as gtk_window_should_use_csd() does.
+  if (sCSDSupportLevel == CSD_SUPPORT_SYSTEM) {
+    const char* csdOverride = getenv("GTK_CSD");
+    if (csdOverride && g_strcmp0(csdOverride, "1") == 0) {
+      sCSDSupportLevel = CSD_SUPPORT_CLIENT;
+    }
+  }
+
+  return sCSDSupportLevel;
+#endif
+}
+
+bool nsWindow::TitlebarUseShapeMask() {
+  static int useShapeMask = []() {
+    // Don't use titlebar shape mask on Wayland
+    if (!gfxPlatformGtk::GetPlatform()->IsX11Display()) {
+      return false;
+    }
+
+    // We can'y use shape masks on Mutter/X.org as we can't resize Firefox
+    // window there (Bug 1530252).
+    const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+    if (currentDesktop) {
+      if (strstr(currentDesktop, "GNOME") != nullptr) {
+        const char* sessionType = getenv("XDG_SESSION_TYPE");
+        if (sessionType && strstr(sessionType, "x11") != nullptr) {
+          return false;
+        }
+      }
+    }
+
+    return Preferences::GetBool("widget.titlebar-x11-use-shape-mask", false);
+  }();
+  return useShapeMask;
+}
+
+bool nsWindow::HideTitlebarByDefault() {
+  static int hideTitlebar = []() {
+    // When user defined widget.default-hidden-titlebar don't do any
+    // heuristics and just follow it.
+    if (Preferences::HasUserValue("widget.default-hidden-titlebar")) {
+      return Preferences::GetBool("widget.default-hidden-titlebar", false);
+    }
+
+    // Don't hide titlebar when it's disabled on current desktop.
+    const char* currentDesktop = getenv("XDG_CURRENT_DESKTOP");
+    if (!currentDesktop || GetSystemCSDSupportLevel() == CSD_SUPPORT_NONE) {
+      return false;
+    }
+
+    // We hide system titlebar on Gnome/ElementaryOS without any restriction.
+    return ((strstr(currentDesktop, "GNOME-Flashback:GNOME") != nullptr ||
+             strstr(currentDesktop, "GNOME") != nullptr ||
+             strstr(currentDesktop, "Pantheon") != nullptr));
+  }();
+  return hideTitlebar;
+}
+
+int32_t nsWindow::RoundsWidgetCoordinatesTo() { return GdkScaleFactor(); }
+
+void nsWindow::GetCompositorWidgetInitData(
+    mozilla::widget::CompositorWidgetInitData* aInitData) {
+#ifdef MOZ_X11
+  // Make sure the window XID is propagated to X server, we can fail otherwise
+  // in GPU process (Bug 1401634).
+  if (mXDisplay && mXWindow != X11None) {
+    XFlush(mXDisplay);
+  }
+#endif
+
+  bool isShaped =
+      mIsTransparent && !mHasAlphaVisual && !mTransparencyBitmapForTitlebar;
+#ifdef MOZ_X11
+  *aInitData = mozilla::widget::GtkCompositorWidgetInitData(
+      (mXWindow != X11None) ? mXWindow : (uintptr_t) nullptr,
+      mXDisplay ? nsCString(XDisplayString(mXDisplay)) : nsCString(), isShaped,
+      mIsX11Display, GetClientSize());
+#else
+  *aInitData = mozilla::widget::GtkCompositorWidgetInitData(
+      (uintptr_t) nullptr, nsCString(), isShaped,
+      mIsX11Display, GetClientSize());
+#endif
+}
+
+#ifdef MOZ_WAYLAND
+bool nsWindow::WaylandSurfaceNeedsClear() {
+  if (mContainer) {
+    return moz_container_wayland_surface_needs_clear(MOZ_CONTAINER(mContainer));
+  }
+  return false;
+}
+#endif
+
+#ifdef MOZ_X11
+/* XApp progress support currently works by setting a property
+ * on a window with this Atom name.  A supporting window manager
+ * will notice this and pass it along to whatever handling has
+ * been implemented on that end (e.g. passing it on to a taskbar
+ * widget.)  There is no issue if WM support is lacking, this is
+ * simply ignored in that case.
+ *
+ * See https://github.com/linuxmint/xapps/blob/master/libxapp/xapp-gtk-window.c
+ * for further details.
+ */
+
+#  define PROGRESS_HINT "_NET_WM_XAPP_PROGRESS"
+
+static void set_window_hint_cardinal(Window xid, const gchar* atom_name,
+                                     gulong cardinal) {
+  GdkDisplay* display;
+
+  display = gdk_display_get_default();
+
+  if (cardinal > 0) {
+    XChangeProperty(GDK_DISPLAY_XDISPLAY(display), xid,
+                    gdk_x11_get_xatom_by_name_for_display(display, atom_name),
+                    XA_CARDINAL, 32, PropModeReplace, (guchar*)&cardinal, 1);
+  } else {
+    XDeleteProperty(GDK_DISPLAY_XDISPLAY(display), xid,
+                    gdk_x11_get_xatom_by_name_for_display(display, atom_name));
+  }
+}
+#endif  // MOZ_X11
+
+void nsWindow::SetProgress(unsigned long progressPercent) {
+#ifdef MOZ_X11
+
+  if (!mIsX11Display) {
+    return;
+  }
+
+  if (!mShell) {
+    return;
+  }
+
+  progressPercent = MIN(progressPercent, 100);
+
+  set_window_hint_cardinal(GDK_WINDOW_XID(gtk_widget_get_window(mShell)),
+                           PROGRESS_HINT, progressPercent);
+#endif  // MOZ_X11
+}
+
+void nsWindow::SetCompositorHint(WindowComposeRequest aState) {
+#ifdef MOZ_X11
+  if (!mIsX11Display) {
+    return;
+  }
+
+  gulong value = aState;
+  GdkAtom cardinal_atom = gdk_x11_xatom_to_atom(XA_CARDINAL);
+  gdk_property_change(gtk_widget_get_window(mShell),
+                      gdk_atom_intern("_NET_WM_BYPASS_COMPOSITOR", FALSE),
+                      cardinal_atom,
+                      32,  // format
+                      GDK_PROP_MODE_REPLACE, (guchar*)&value, 1);
+#endif
+}
+
+nsresult nsWindow::SetSystemFont(const nsCString& aFontName) {
+  GtkSettings* settings = gtk_settings_get_default();
+  g_object_set(settings, "gtk-font-name", aFontName.get(), nullptr);
+  return NS_OK;
+}
+
+nsresult nsWindow::GetSystemFont(nsCString& aFontName) {
+  GtkSettings* settings = gtk_settings_get_default();
+  gchar* fontName = nullptr;
+  g_object_get(settings, "gtk-font-name", &fontName, nullptr);
+  if (fontName) {
+    aFontName.Assign(fontName);
+    g_free(fontName);
+  }
+  return NS_OK;
+}
+
+already_AddRefed<nsIWidget> nsIWidget::CreateTopLevelWindow() {
+  nsCOMPtr<nsIWidget> window = new nsWindow();
+  return window.forget();
+}
+
+already_AddRefed<nsIWidget> nsIWidget::CreateChildWindow() {
+  nsCOMPtr<nsIWidget> window = new nsWindow();
+  return window.forget();
+}
+
+#ifdef MOZ_WAYLAND
+nsresult nsWindow::GetScreenRect(LayoutDeviceIntRect* aRect) {
+  typedef struct _GdkMonitor GdkMonitor;
+  static auto s_gdk_display_get_monitor_at_window =
+      (GdkMonitor * (*)(GdkDisplay*, GdkWindow*))
+          dlsym(RTLD_DEFAULT, "gdk_display_get_monitor_at_window");
+
+  static auto s_gdk_monitor_get_workarea =
+      (void (*)(GdkMonitor*, GdkRectangle*))dlsym(RTLD_DEFAULT,
+                                                  "gdk_monitor_get_workarea");
+
+  if (!s_gdk_display_get_monitor_at_window || !s_gdk_monitor_get_workarea) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  GtkWindow* topmostParentWindow = GetCurrentTopmostWindow();
+  GdkWindow* gdkWindow = gtk_widget_get_window(GTK_WIDGET(topmostParentWindow));
+
+  GdkMonitor* monitor =
+      s_gdk_display_get_monitor_at_window(gdk_display_get_default(), gdkWindow);
+  if (monitor) {
+    GdkRectangle workArea;
+    s_gdk_monitor_get_workarea(monitor, &workArea);
+    // The monitor offset won't help us in Wayland, because we can't get the
+    // absolute position of our window.
+    aRect->x = aRect->y = 0;
+    aRect->width = workArea.width;
+    aRect->height = workArea.height;
+    LOG(("  workarea for [%p], monitor %p: x%d y%d w%d h%d\n", this, monitor,
+         workArea.x, workArea.y, workArea.width, workArea.height));
+    return NS_OK;
+  }
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+#endif
+
+bool nsWindow::GetTopLevelWindowActiveState(nsIFrame* aFrame) {
+  // Used by window frame and button box rendering. We can end up in here in
+  // the content process when rendering one of these moz styles freely in a
+  // page. Fail in this case, there is no applicable window focus state.
+  if (!XRE_IsParentProcess()) {
+    return false;
+  }
+  // All headless windows are considered active so they are painted.
+  if (gfxPlatform::IsHeadless()) {
+    return true;
+  }
+  // Get the widget. nsIFrame's GetNearestWidget walks up the view chain
+  // until it finds a real window.
+  nsWindow* window = static_cast<nsWindow*>(aFrame->GetNearestWidget());
+  if (!window) {
+    return false;
+  }
+
+  // Get our toplevel nsWindow.
+  if (!window->mIsTopLevel) {
+    GtkWidget* widget = window->GetMozContainerWidget();
+    if (!widget) {
+      return false;
+    }
+
+    GtkWidget* toplevelWidget = gtk_widget_get_toplevel(widget);
+    window = get_window_for_gtk_widget(toplevelWidget);
+    if (!window) {
+      return false;
+    }
+  }
+
+  return !window->mTitlebarBackdropState;
+}
+
+static nsIFrame* FindTitlebarFrame(nsIFrame* aFrame) {
+  for (nsIFrame* childFrame : aFrame->PrincipalChildList()) {
+    StyleAppearance appearance =
+        childFrame->StyleDisplay()->EffectiveAppearance();
+    if (appearance == StyleAppearance::MozWindowTitlebar ||
+        appearance == StyleAppearance::MozWindowTitlebarMaximized) {
+      return childFrame;
+    }
+
+    if (nsIFrame* foundFrame = FindTitlebarFrame(childFrame)) {
+      return foundFrame;
+    }
+  }
+  return nullptr;
+}
+
+nsIFrame* nsWindow::GetFrame(void) {
+  nsView* view = nsView::GetViewFor(this);
+  if (!view) {
+    return nullptr;
+  }
+  return view->GetFrame();
+}
+
+void nsWindow::UpdateMozWindowActive() {
+  // Update activation state for the :-moz-window-inactive pseudoclass.
+  // Normally, this follows focus; we override it here to follow
+  // GDK_WINDOW_STATE_FOCUSED.
+  if (mozilla::dom::Document* document = GetDocument()) {
+    if (nsPIDOMWindowOuter* window = document->GetWindow()) {
+      if (RefPtr<mozilla::dom::BrowsingContext> bc =
+              window->GetBrowsingContext()) {
+        bc->SetIsActiveBrowserWindow(!mTitlebarBackdropState);
+      }
+    }
+  }
+}
+
+void nsWindow::ForceTitlebarRedraw(void) {
+  MOZ_ASSERT(mDrawInTitlebar, "We should not redraw invisible titlebar.");
+
+  if (!mWidgetListener || !mWidgetListener->GetPresShell()) {
+    return;
+  }
+
+  nsIFrame* frame = GetFrame();
+  if (!frame) {
+    return;
+  }
+
+  frame = FindTitlebarFrame(frame);
+  if (frame) {
+    nsIContent* content = frame->GetContent();
+    if (content) {
+      nsLayoutUtils::PostRestyleEvent(content->AsElement(), RestyleHint{0},
+                                      nsChangeHint_RepaintFrame);
+    }
+  }
+}
+
+GtkTextDirection nsWindow::GetTextDirection() {
+  nsIFrame* frame = GetFrame();
+  if (!frame) {
+    return GTK_TEXT_DIR_LTR;
+  }
+
+  WritingMode wm = frame->GetWritingMode();
+  return wm.IsPhysicalLTR() ? GTK_TEXT_DIR_LTR : GTK_TEXT_DIR_RTL;
+}
+
+void nsWindow::LockAspectRatio(bool aShouldLock) {
+  if (!gUseAspectRatio) {
+    return;
+  }
+
+  if (aShouldLock) {
+    int decWidth = 0, decHeight = 0;
+    AddCSDDecorationSize(&decWidth, &decHeight);
+
+    float width =
+        (float)DevicePixelsToGdkCoordRoundDown(mBounds.width) + decWidth;
+    float height =
+        (float)DevicePixelsToGdkCoordRoundDown(mBounds.height) + decHeight;
+
+    mAspectRatio = width / height;
+    LOG(("nsWindow::LockAspectRatio() [%p] width %f height %f aspect %f\n",
+         (void*)this, width, height, mAspectRatio));
+  } else {
+    mAspectRatio = 0.0;
+    LOG(("nsWindow::LockAspectRatio() [%p] removed aspect ratio\n",
+         (void*)this));
+  }
+
+  ApplySizeConstraints();
+}
+
+#ifdef MOZ_WAYLAND
+void nsWindow::SetEGLNativeWindowSize(
+    const LayoutDeviceIntSize& aEGLWindowSize) {
+  if (mContainer && !mIsX11Display) {
+    moz_container_wayland_egl_window_set_size(mContainer, aEGLWindowSize.width,
+                                              aEGLWindowSize.height);
+  }
+}
+
+nsWindow* nsWindow::GetFocusedWindow() { return gFocusWindow; }
+#endif
+
+LayoutDeviceIntRect nsWindow::GetMozContainerSize() {
+  LayoutDeviceIntRect size(0, 0, 0, 0);
+  if (mContainer) {
+    GtkAllocation allocation;
+    gtk_widget_get_allocation(GTK_WIDGET(mContainer), &allocation);
+    int scale = GdkScaleFactor();
+    size.width = allocation.width * scale;
+    size.height = allocation.height * scale;
+  }
+  return size;
+}
diff --git a/widget/gtk/nsWindow.h b/widget/gtk/nsWindow.h
index 5190d175b7..9b5694b421 100644
--- a/widget/gtk/nsWindow.h
+++ b/widget/gtk/nsWindow.h
@@ -84,7 +84,9 @@ class nsIFrame;
 
 namespace mozilla {
 class TimeStamp;
+#ifdef MOZ_X11
 class CurrentX11TimeGetter;
+#endif
 
 }  // namespace mozilla
 
@@ -302,7 +304,9 @@ class nsWindow final : public nsBaseWidget {
 
   WidgetEventTime GetWidgetEventTime(guint32 aEventTime);
   mozilla::TimeStamp GetEventTimeStamp(guint32 aEventTime);
+#ifdef MOZ_X11
   mozilla::CurrentX11TimeGetter* GetCurrentTimeGetter();
+#endif
 
   virtual void SetInputContext(const InputContext& aContext,
                                const InputContextAction& aAction) override;
@@ -500,7 +504,7 @@ class nsWindow final : public nsBaseWidget {
 
   void AddCSDDecorationSize(int* aWidth, int* aHeight);
 
-#ifdef MOZ_X11
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
   typedef enum {GTK_WIDGET_COMPOSIDED_DEFAULT = 0,
                 GTK_WIDGET_COMPOSIDED_DISABLED = 1,
                 GTK_WIDGET_COMPOSIDED_ENABLED = 2} WindowComposeRequest;
@@ -537,10 +541,12 @@ class nsWindow final : public nsBaseWidget {
   Window mXWindow;
   Visual* mXVisual;
   int mXDepth;
-  mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
 
   bool ConfigureX11GLVisual(bool aUseAlpha);
 #endif
+#if defined(MOZ_X11) || defined(MOZ_WAYLAND)
+  mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
+#endif
 #ifdef MOZ_WAYLAND
   RefPtr<mozilla::gfx::VsyncSource> mWaylandVsyncSource;
 #endif
@@ -699,7 +705,9 @@ class nsWindow final : public nsBaseWidget {
    */
   RefPtr<mozilla::widget::IMContextWrapper> mIMContext;
 
+#ifdef MOZ_X11
   mozilla::UniquePtr<mozilla::CurrentX11TimeGetter> mCurrentTimeGetter;
+#endif
   static CSDSupportLevel sCSDSupportLevel;
 
   static bool sTransparentMainWindow;
diff --git a/widget/gtk/nsWindow.h.orig b/widget/gtk/nsWindow.h.orig
new file mode 100644
index 0000000000..47821ef74e
--- /dev/null
+++ b/widget/gtk/nsWindow.h.orig
@@ -0,0 +1,714 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim:expandtab:shiftwidth=4:tabstop=4:
+ */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef __nsWindow_h__
+#define __nsWindow_h__
+
+#include <gdk/gdk.h>
+#include <gtk/gtk.h>
+#ifdef MOZ_X11
+#  include <gdk/gdkx.h>
+#  include "X11UndefineNone.h"
+#endif /* MOZ_X11 */
+#ifdef MOZ_WAYLAND
+#  include <gdk/gdkwayland.h>
+#  include "base/thread.h"
+#  include "WaylandVsyncSource.h"
+#endif
+#include "MozContainer.h"
+#include "mozilla/RefPtr.h"
+#include "mozilla/UniquePtr.h"
+#include "nsIDragService.h"
+#include "nsGkAtoms.h"
+#include "nsRefPtrHashtable.h"
+#include "nsBaseWidget.h"
+#include "CompositorWidget.h"
+#include "mozilla/widget/WindowSurface.h"
+#include "mozilla/widget/WindowSurfaceProvider.h"
+#include "mozilla/Maybe.h"
+
+#ifdef ACCESSIBILITY
+#  include "mozilla/a11y/Accessible.h"
+#endif
+#include "mozilla/EventForwards.h"
+#include "mozilla/TouchEvents.h"
+
+#include "IMContextWrapper.h"
+
+#undef LOG
+#ifdef MOZ_LOGGING
+
+#  include "mozilla/Logging.h"
+#  include "nsTArray.h"
+#  include "Units.h"
+
+extern mozilla::LazyLogModule gWidgetLog;
+extern mozilla::LazyLogModule gWidgetFocusLog;
+extern mozilla::LazyLogModule gWidgetDragLog;
+extern mozilla::LazyLogModule gWidgetDrawLog;
+
+#  define LOG(args) MOZ_LOG(gWidgetLog, mozilla::LogLevel::Debug, args)
+#  define LOGFOCUS(args) \
+    MOZ_LOG(gWidgetFocusLog, mozilla::LogLevel::Debug, args)
+#  define LOGDRAG(args) MOZ_LOG(gWidgetDragLog, mozilla::LogLevel::Debug, args)
+#  define LOGDRAW(args) MOZ_LOG(gWidgetDrawLog, mozilla::LogLevel::Debug, args)
+
+#else
+
+#  define LOG(args)
+#  define LOGFOCUS(args)
+#  define LOGDRAG(args)
+#  define LOGDRAW(args)
+
+#endif /* MOZ_LOGGING */
+
+#ifdef MOZ_WAYLAND
+class nsWaylandDragContext;
+
+gboolean WindowDragMotionHandler(GtkWidget* aWidget,
+                                 GdkDragContext* aDragContext,
+                                 nsWaylandDragContext* aWaylandDragContext,
+                                 gint aX, gint aY, guint aTime);
+gboolean WindowDragDropHandler(GtkWidget* aWidget, GdkDragContext* aDragContext,
+                               nsWaylandDragContext* aWaylandDragContext,
+                               gint aX, gint aY, guint aTime);
+void WindowDragLeaveHandler(GtkWidget* aWidget);
+#endif
+
+class gfxPattern;
+class nsIFrame;
+
+namespace mozilla {
+class TimeStamp;
+#ifdef MOZ_X11
+class CurrentX11TimeGetter;
+#endif
+
+}  // namespace mozilla
+
+class nsWindow final : public nsBaseWidget {
+ public:
+  typedef mozilla::gfx::DrawTarget DrawTarget;
+  typedef mozilla::WidgetEventTime WidgetEventTime;
+  typedef mozilla::WidgetKeyboardEvent WidgetKeyboardEvent;
+  typedef mozilla::widget::PlatformCompositorWidgetDelegate
+      PlatformCompositorWidgetDelegate;
+
+  nsWindow();
+
+  static void ReleaseGlobals();
+
+  NS_INLINE_DECL_REFCOUNTING_INHERITED(nsWindow, nsBaseWidget)
+
+  void CommonCreate(nsIWidget* aParent, bool aListenForResizes);
+
+  virtual nsresult DispatchEvent(mozilla::WidgetGUIEvent* aEvent,
+                                 nsEventStatus& aStatus) override;
+
+  // called when we are destroyed
+  virtual void OnDestroy(void) override;
+
+  // called to check and see if a widget's dimensions are sane
+  bool AreBoundsSane(void);
+
+  // nsIWidget
+  using nsBaseWidget::Create;  // for Create signature not overridden here
+  [[nodiscard]] virtual nsresult Create(nsIWidget* aParent,
+                                        nsNativeWidget aNativeParent,
+                                        const LayoutDeviceIntRect& aRect,
+                                        nsWidgetInitData* aInitData) override;
+  virtual void Destroy() override;
+  virtual nsIWidget* GetParent() override;
+  virtual float GetDPI() override;
+  virtual double GetDefaultScaleInternal() override;
+  mozilla::DesktopToLayoutDeviceScale GetDesktopToDeviceScale() override;
+  mozilla::DesktopToLayoutDeviceScale GetDesktopToDeviceScaleByScreen()
+      override;
+  virtual void SetParent(nsIWidget* aNewParent) override;
+  virtual void SetModal(bool aModal) override;
+  virtual bool IsVisible() const override;
+  virtual void ConstrainPosition(bool aAllowSlop, int32_t* aX,
+                                 int32_t* aY) override;
+  virtual void SetSizeConstraints(const SizeConstraints& aConstraints) override;
+  virtual void LockAspectRatio(bool aShouldLock) override;
+  virtual void Move(double aX, double aY) override;
+  virtual void Show(bool aState) override;
+  virtual void Resize(double aWidth, double aHeight, bool aRepaint) override;
+  virtual void Resize(double aX, double aY, double aWidth, double aHeight,
+                      bool aRepaint) override;
+  virtual bool IsEnabled() const override;
+
+  void SetZIndex(int32_t aZIndex) override;
+  virtual void SetSizeMode(nsSizeMode aMode) override;
+  virtual void GetWorkspaceID(nsAString& workspaceID) override;
+  virtual void MoveToWorkspace(const nsAString& workspaceID) override;
+  virtual void Enable(bool aState) override;
+  virtual void SetFocus(Raise, mozilla::dom::CallerType aCallerType) override;
+  virtual LayoutDeviceIntRect GetScreenBounds() override;
+  virtual LayoutDeviceIntRect GetClientBounds() override;
+  virtual LayoutDeviceIntSize GetClientSize() override;
+  virtual LayoutDeviceIntPoint GetClientOffset() override;
+  virtual void SetCursor(nsCursor aDefaultCursor, imgIContainer* aCursor,
+                         uint32_t aHotspotX, uint32_t aHotspotY) override;
+  virtual void Invalidate(const LayoutDeviceIntRect& aRect) override;
+  virtual void* GetNativeData(uint32_t aDataType) override;
+  virtual nsresult SetTitle(const nsAString& aTitle) override;
+  virtual void SetIcon(const nsAString& aIconSpec) override;
+  virtual void SetWindowClass(const nsAString& xulWinType) override;
+  virtual LayoutDeviceIntPoint WidgetToScreenOffset() override;
+  virtual void CaptureMouse(bool aCapture) override;
+  virtual void CaptureRollupEvents(nsIRollupListener* aListener,
+                                   bool aDoCapture) override;
+  [[nodiscard]] virtual nsresult GetAttention(int32_t aCycleCount) override;
+  virtual nsresult SetWindowClipRegion(
+      const nsTArray<LayoutDeviceIntRect>& aRects,
+      bool aIntersectWithExisting) override;
+  virtual bool HasPendingInputEvent() override;
+
+  virtual bool PrepareForFullscreenTransition(nsISupports** aData) override;
+  virtual void PerformFullscreenTransition(FullscreenTransitionStage aStage,
+                                           uint16_t aDuration,
+                                           nsISupports* aData,
+                                           nsIRunnable* aCallback) override;
+  virtual already_AddRefed<nsIScreen> GetWidgetScreen() override;
+  virtual nsresult MakeFullScreen(bool aFullScreen,
+                                  nsIScreen* aTargetScreen = nullptr) override;
+  virtual void HideWindowChrome(bool aShouldHide) override;
+
+  /**
+   * GetLastUserInputTime returns a timestamp for the most recent user input
+   * event.  This is intended for pointer grab requests (including drags).
+   */
+  static guint32 GetLastUserInputTime();
+
+  // utility method, -1 if no change should be made, otherwise returns a
+  // value that can be passed to gdk_window_set_decorations
+  gint ConvertBorderStyles(nsBorderStyle aStyle);
+
+  GdkRectangle DevicePixelsToGdkRectRoundOut(LayoutDeviceIntRect aRect);
+
+  mozilla::widget::IMContextWrapper* GetIMContext() const { return mIMContext; }
+
+  bool DispatchCommandEvent(nsAtom* aCommand);
+  bool DispatchContentCommandEvent(mozilla::EventMessage aMsg);
+
+  // event callbacks
+  gboolean OnExposeEvent(cairo_t* cr);
+  gboolean OnConfigureEvent(GtkWidget* aWidget, GdkEventConfigure* aEvent);
+  void OnContainerUnrealize();
+  void OnSizeAllocate(GtkAllocation* aAllocation);
+  void OnDeleteEvent();
+  void OnEnterNotifyEvent(GdkEventCrossing* aEvent);
+  void OnLeaveNotifyEvent(GdkEventCrossing* aEvent);
+  void OnMotionNotifyEvent(GdkEventMotion* aEvent);
+  void OnButtonPressEvent(GdkEventButton* aEvent);
+  void OnButtonReleaseEvent(GdkEventButton* aEvent);
+  void OnContainerFocusInEvent(GdkEventFocus* aEvent);
+  void OnContainerFocusOutEvent(GdkEventFocus* aEvent);
+  gboolean OnKeyPressEvent(GdkEventKey* aEvent);
+  gboolean OnKeyReleaseEvent(GdkEventKey* aEvent);
+
+  void OnScrollEvent(GdkEventScroll* aEvent);
+  void OnWindowStateEvent(GtkWidget* aWidget, GdkEventWindowState* aEvent);
+  void OnDragDataReceivedEvent(GtkWidget* aWidget, GdkDragContext* aDragContext,
+                               gint aX, gint aY,
+                               GtkSelectionData* aSelectionData, guint aInfo,
+                               guint aTime, gpointer aData);
+  gboolean OnPropertyNotifyEvent(GtkWidget* aWidget, GdkEventProperty* aEvent);
+  gboolean OnTouchEvent(GdkEventTouch* aEvent);
+
+  void UpdateTopLevelOpaqueRegion();
+
+  virtual already_AddRefed<mozilla::gfx::DrawTarget> StartRemoteDrawingInRegion(
+      LayoutDeviceIntRegion& aInvalidRegion,
+      mozilla::layers::BufferMode* aBufferMode) override;
+  virtual void EndRemoteDrawingInRegion(
+      mozilla::gfx::DrawTarget* aDrawTarget,
+      const LayoutDeviceIntRegion& aInvalidRegion) override;
+
+  void SetProgress(unsigned long progressPercent);
+
+#ifdef MOZ_WAYLAND
+  void SetEGLNativeWindowSize(const LayoutDeviceIntSize& aEGLWindowSize);
+  static nsWindow* GetFocusedWindow();
+#endif
+
+  RefPtr<mozilla::gfx::VsyncSource> GetVsyncSource() override;
+
+ private:
+  void UpdateAlpha(mozilla::gfx::SourceSurface* aSourceSurface,
+                   nsIntRect aBoundsRect);
+
+  void NativeMove();
+  void NativeResize();
+  void NativeMoveResize();
+
+  void NativeShow(bool aAction);
+  void SetHasMappedToplevel(bool aState);
+  LayoutDeviceIntSize GetSafeWindowSize(LayoutDeviceIntSize aSize);
+
+  void EnsureGrabs(void);
+  void GrabPointer(guint32 aTime);
+  void ReleaseGrabs(void);
+
+  void UpdateClientOffsetFromFrameExtents();
+  void UpdateClientOffsetFromCSDWindow();
+
+  void DispatchContextMenuEventFromMouseEvent(uint16_t domButton,
+                                              GdkEventButton* aEvent);
+#ifdef MOZ_WAYLAND
+  void MaybeResumeCompositor();
+#endif
+
+  void WaylandStartVsync();
+  void WaylandStopVsync();
+
+ public:
+  void ThemeChanged(void);
+  void OnDPIChanged(void);
+  void OnCheckResize(void);
+  void OnCompositedChanged(void);
+  void OnScaleChanged(GtkAllocation* aAllocation);
+  void DispatchResized();
+
+#ifdef MOZ_X11
+  Window mOldFocusWindow;
+#endif /* MOZ_X11 */
+
+  static guint32 sLastButtonPressTime;
+
+  [[nodiscard]] virtual nsresult BeginResizeDrag(
+      mozilla::WidgetGUIEvent* aEvent, int32_t aHorizontal,
+      int32_t aVertical) override;
+
+  MozContainer* GetMozContainer() { return mContainer; }
+  LayoutDeviceIntRect GetMozContainerSize();
+  // GetMozContainerWidget returns the MozContainer even for undestroyed
+  // descendant windows
+  GtkWidget* GetMozContainerWidget();
+  GdkWindow* GetGdkWindow() { return mGdkWindow; }
+  GtkWidget* GetGtkWidget() { return mShell; }
+  nsIFrame* GetFrame();
+  bool IsDestroyed() { return mIsDestroyed; }
+  bool IsWaylandPopup();
+  bool IsPIPWindow() { return mIsPIPWindow; };
+
+  void DispatchDragEvent(mozilla::EventMessage aMsg,
+                         const LayoutDeviceIntPoint& aRefPoint, guint aTime);
+  static void UpdateDragStatus(GdkDragContext* aDragContext,
+                               nsIDragService* aDragService);
+
+  WidgetEventTime GetWidgetEventTime(guint32 aEventTime);
+  mozilla::TimeStamp GetEventTimeStamp(guint32 aEventTime);
+#ifdef MOZ_X11
+  mozilla::CurrentX11TimeGetter* GetCurrentTimeGetter();
+#endif
+
+  virtual void SetInputContext(const InputContext& aContext,
+                               const InputContextAction& aAction) override;
+  virtual InputContext GetInputContext() override;
+  virtual TextEventDispatcherListener* GetNativeTextEventDispatcherListener()
+      override;
+  void GetEditCommandsRemapped(NativeKeyBindingsType aType,
+                               const mozilla::WidgetKeyboardEvent& aEvent,
+                               nsTArray<mozilla::CommandInt>& aCommands,
+                               uint32_t aGeckoKeyCode, uint32_t aNativeKeyCode);
+  virtual bool GetEditCommands(
+      NativeKeyBindingsType aType, const mozilla::WidgetKeyboardEvent& aEvent,
+      nsTArray<mozilla::CommandInt>& aCommands) override;
+
+  // These methods are for toplevel windows only.
+  void ResizeTransparencyBitmap();
+  void ApplyTransparencyBitmap();
+  void ClearTransparencyBitmap();
+
+  virtual void SetTransparencyMode(nsTransparencyMode aMode) override;
+  virtual nsTransparencyMode GetTransparencyMode() override;
+  virtual void SetWindowMouseTransparent(bool aIsTransparent) override;
+  virtual nsresult ConfigureChildren(
+      const nsTArray<Configuration>& aConfigurations) override;
+  nsresult UpdateTranslucentWindowAlphaInternal(const nsIntRect& aRect,
+                                                uint8_t* aAlphas,
+                                                int32_t aStride);
+  void UpdateTitlebarTransparencyBitmap();
+
+  virtual void ReparentNativeWidget(nsIWidget* aNewParent) override;
+
+  virtual nsresult SynthesizeNativeMouseEvent(LayoutDeviceIntPoint aPoint,
+                                              uint32_t aNativeMessage,
+                                              uint32_t aModifierFlags,
+                                              nsIObserver* aObserver) override;
+
+  virtual nsresult SynthesizeNativeMouseMove(LayoutDeviceIntPoint aPoint,
+                                             nsIObserver* aObserver) override {
+    return SynthesizeNativeMouseEvent(aPoint, GDK_MOTION_NOTIFY, 0, aObserver);
+  }
+
+  virtual nsresult SynthesizeNativeMouseScrollEvent(
+      LayoutDeviceIntPoint aPoint, uint32_t aNativeMessage, double aDeltaX,
+      double aDeltaY, double aDeltaZ, uint32_t aModifierFlags,
+      uint32_t aAdditionalFlags, nsIObserver* aObserver) override;
+
+  virtual nsresult SynthesizeNativeTouchPoint(uint32_t aPointerId,
+                                              TouchPointerState aPointerState,
+                                              LayoutDeviceIntPoint aPoint,
+                                              double aPointerPressure,
+                                              uint32_t aPointerOrientation,
+                                              nsIObserver* aObserver) override;
+
+#ifdef MOZ_X11
+  Display* XDisplay() { return mXDisplay; }
+#endif
+#ifdef MOZ_WAYLAND
+  wl_display* GetWaylandDisplay();
+  bool WaylandSurfaceNeedsClear();
+  virtual void CreateCompositorVsyncDispatcher() override;
+#endif
+  virtual void GetCompositorWidgetInitData(
+      mozilla::widget::CompositorWidgetInitData* aInitData) override;
+
+  virtual nsresult SetNonClientMargins(
+      LayoutDeviceIntMargin& aMargins) override;
+  void SetDrawsInTitlebar(bool aState) override;
+  virtual void UpdateWindowDraggingRegion(
+      const LayoutDeviceIntRegion& aRegion) override;
+
+  // HiDPI scale conversion
+  gint GdkScaleFactor();
+
+  // To GDK
+  gint DevicePixelsToGdkCoordRoundUp(int pixels);
+  gint DevicePixelsToGdkCoordRoundDown(int pixels);
+  GdkPoint DevicePixelsToGdkPointRoundDown(LayoutDeviceIntPoint point);
+  GdkRectangle DevicePixelsToGdkSizeRoundUp(LayoutDeviceIntSize pixelSize);
+
+  // From GDK
+  int GdkCoordToDevicePixels(gint coord);
+  LayoutDeviceIntPoint GdkPointToDevicePixels(GdkPoint point);
+  LayoutDeviceIntPoint GdkEventCoordsToDevicePixels(gdouble x, gdouble y);
+  LayoutDeviceIntRect GdkRectToDevicePixels(GdkRectangle rect);
+
+  virtual bool WidgetTypeSupportsAcceleration() override;
+
+  nsresult SetSystemFont(const nsCString& aFontName) override;
+  nsresult GetSystemFont(nsCString& aFontName) override;
+
+  typedef enum {
+    CSD_SUPPORT_SYSTEM,  // CSD including shadows
+    CSD_SUPPORT_CLIENT,  // CSD without shadows
+    CSD_SUPPORT_NONE,    // WM does not support CSD at all
+    CSD_SUPPORT_UNKNOWN
+  } CSDSupportLevel;
+  /**
+   * Get the support of Client Side Decoration by checking
+   * the XDG_CURRENT_DESKTOP environment variable.
+   */
+  static CSDSupportLevel GetSystemCSDSupportLevel(bool aIsPopup = false);
+
+  static bool HideTitlebarByDefault();
+  static bool GetTopLevelWindowActiveState(nsIFrame* aFrame);
+  static bool TitlebarUseShapeMask();
+#ifdef MOZ_WAYLAND
+  virtual nsresult GetScreenRect(LayoutDeviceIntRect* aRect) override;
+  virtual nsRect GetPreferredPopupRect() override {
+    return mPreferredPopupRect;
+  };
+  virtual void FlushPreferredPopupRect() override {
+    mPreferredPopupRect = nsRect(0, 0, 0, 0);
+    mPreferredPopupRectFlushed = true;
+  };
+#endif
+  bool IsRemoteContent() { return HasRemoteContent(); }
+  static void HideWaylandOpenedPopups();
+  void NativeMoveResizeWaylandPopupCB(const GdkRectangle* aFinalSize,
+                                      bool aFlippedX, bool aFlippedY);
+  static bool IsToplevelWindowTransparent();
+
+ protected:
+  virtual ~nsWindow();
+
+  // event handling code
+  void DispatchActivateEvent(void);
+  void DispatchDeactivateEvent(void);
+  void MaybeDispatchResized();
+
+  virtual void RegisterTouchWindow() override;
+  virtual bool CompositorInitiallyPaused() override {
+#ifdef MOZ_WAYLAND
+    return mCompositorInitiallyPaused;
+#else
+    return false;
+#endif
+  }
+  nsCOMPtr<nsIWidget> mParent;
+  // Is this a toplevel window?
+  bool mIsTopLevel;
+  // Has this widget been destroyed yet?
+  bool mIsDestroyed;
+
+  // Should we send resize events on all resizes?
+  bool mListenForResizes;
+  // Does WindowResized need to be called on listeners?
+  bool mNeedsDispatchResized;
+  // This flag tracks if we're hidden or shown.
+  bool mIsShown;
+  bool mNeedsShow;
+  // is this widget enabled?
+  bool mEnabled;
+  // has the native window for this been created yet?
+  bool mCreated;
+  // whether we handle touch event
+  bool mHandleTouchEvent;
+  // true if this is a drag and drop feedback popup
+  bool mIsDragPopup;
+  // Can we access X?
+  bool mIsX11Display;
+#ifdef MOZ_WAYLAND
+  bool mNeedsCompositorResume;
+  bool mCompositorInitiallyPaused;
+#endif
+  bool mWindowScaleFactorChanged;
+  int mWindowScaleFactor;
+  bool mCompositedScreen;
+
+ private:
+  void DestroyChildWindows();
+  GtkWidget* GetToplevelWidget();
+  nsWindow* GetContainerWindow();
+  void SetUrgencyHint(GtkWidget* top_window, bool state);
+  void SetDefaultIcon(void);
+  void SetWindowDecoration(nsBorderStyle aStyle);
+  void InitButtonEvent(mozilla::WidgetMouseEvent& aEvent,
+                       GdkEventButton* aGdkEvent);
+  bool CheckForRollup(gdouble aMouseX, gdouble aMouseY, bool aIsWheel,
+                      bool aAlwaysRollup);
+  void CheckForRollupDuringGrab() { CheckForRollup(0, 0, false, true); }
+
+  bool GetDragInfo(mozilla::WidgetMouseEvent* aMouseEvent, GdkWindow** aWindow,
+                   gint* aButton, gint* aRootX, gint* aRootY);
+  void ClearCachedResources();
+  nsIWidgetListener* GetListener();
+
+  nsWindow* GetTransientForWindowIfPopup();
+  bool IsHandlingTouchSequence(GdkEventSequence* aSequence);
+
+  void ResizeInt(int aX, int aY, int aWidth, int aHeight, bool aMove,
+                 bool aRepaint);
+  void NativeMoveResizeWaylandPopup(GdkPoint* aPosition, GdkRectangle* aSize);
+
+  GtkTextDirection GetTextDirection();
+
+  void AddCSDDecorationSize(int* aWidth, int* aHeight);
+
+#ifdef MOZ_X11
+  typedef enum {GTK_WIDGET_COMPOSIDED_DEFAULT = 0,
+                GTK_WIDGET_COMPOSIDED_DISABLED = 1,
+                GTK_WIDGET_COMPOSIDED_ENABLED = 2} WindowComposeRequest;
+
+  void SetCompositorHint(WindowComposeRequest aState);
+#endif
+  nsCString mGtkWindowAppName;
+  nsCString mGtkWindowRoleName;
+  void RefreshWindowClass();
+
+  GtkWidget* mShell;
+  MozContainer* mContainer;
+  GdkWindow* mGdkWindow;
+  bool mWindowShouldStartDragging = false;
+  PlatformCompositorWidgetDelegate* mCompositorWidgetDelegate;
+
+  uint32_t mHasMappedToplevel : 1, mRetryPointerGrab : 1;
+  nsSizeMode mSizeState;
+  float mAspectRatio;
+  float mAspectRatioSaved;
+  nsIntPoint mClientOffset;
+
+  // This field omits duplicate scroll events caused by GNOME bug 726878.
+  guint32 mLastScrollEventTime;
+
+  bool mPanInProgress = false;
+
+  // for touch event handling
+  nsRefPtrHashtable<nsPtrHashKey<GdkEventSequence>, mozilla::dom::Touch>
+      mTouches;
+
+#ifdef MOZ_X11
+  Display* mXDisplay;
+  Window mXWindow;
+  Visual* mXVisual;
+  int mXDepth;
+  mozilla::widget::WindowSurfaceProvider mSurfaceProvider;
+
+  bool ConfigureX11GLVisual(bool aUseAlpha);
+#endif
+#ifdef MOZ_WAYLAND
+  RefPtr<mozilla::gfx::VsyncSource> mWaylandVsyncSource;
+#endif
+
+  // Upper bound on pending ConfigureNotify events to be dispatched to the
+  // window. See bug 1225044.
+  unsigned int mPendingConfigures;
+
+  // Window titlebar rendering mode, CSD_SUPPORT_NONE if it's disabled
+  // for this window.
+  CSDSupportLevel mCSDSupportLevel;
+  // Use dedicated GdkWindow for mContainer
+  bool mDrawToContainer;
+  // If true, draw our own window titlebar.
+  bool mDrawInTitlebar;
+  // Draw titlebar with :backdrop css state (inactive/unfocused).
+  bool mTitlebarBackdropState;
+  // Draggable titlebar region maintained by UpdateWindowDraggingRegion
+  LayoutDeviceIntRegion mDraggableRegion;
+  // It's PictureInPicture window.
+  bool mIsPIPWindow;
+  bool mAlwaysOnTop;
+
+#ifdef ACCESSIBILITY
+  RefPtr<mozilla::a11y::Accessible> mRootAccessible;
+
+  /**
+   * Request to create the accessible for this window if it is top level.
+   */
+  void CreateRootAccessible();
+
+  /**
+   * Dispatch accessible event for the top level window accessible.
+   *
+   * @param  aEventType  [in] the accessible event type to dispatch
+   */
+  void DispatchEventToRootAccessible(uint32_t aEventType);
+
+  /**
+   * Dispatch accessible window activate event for the top level window
+   * accessible.
+   */
+  void DispatchActivateEventAccessible();
+
+  /**
+   * Dispatch accessible window deactivate event for the top level window
+   * accessible.
+   */
+  void DispatchDeactivateEventAccessible();
+
+  /**
+   * Dispatch accessible window maximize event for the top level window
+   * accessible.
+   */
+  void DispatchMaximizeEventAccessible();
+
+  /**
+   * Dispatch accessible window minize event for the top level window
+   * accessible.
+   */
+  void DispatchMinimizeEventAccessible();
+
+  /**
+   * Dispatch accessible window restore event for the top level window
+   * accessible.
+   */
+  void DispatchRestoreEventAccessible();
+#endif
+
+  // The cursor cache
+  static GdkCursor* gsGtkCursorCache[eCursorCount];
+
+  // Transparency
+  bool mIsTransparent;
+  // This bitmap tracks which pixels are transparent. We don't support
+  // full translucency at this time; each pixel is either fully opaque
+  // or fully transparent.
+  gchar* mTransparencyBitmap;
+  int32_t mTransparencyBitmapWidth;
+  int32_t mTransparencyBitmapHeight;
+  // The transparency bitmap is used instead of ARGB visual for toplevel
+  // window to draw titlebar.
+  bool mTransparencyBitmapForTitlebar;
+
+  // True when we're on compositing window manager and this
+  // window is using visual with alpha channel.
+  bool mHasAlphaVisual;
+
+  // all of our DND stuff
+  void InitDragEvent(mozilla::WidgetDragEvent& aEvent);
+
+  float mLastMotionPressure;
+
+  // Remember the last sizemode so that we can restore it when
+  // leaving fullscreen
+  nsSizeMode mLastSizeMode;
+  // We can't detect size state changes correctly so set this flag
+  // to force update mBounds after a size state change from a configure
+  // event.
+  bool mBoundsAreValid;
+
+  static bool DragInProgress(void);
+
+  void DispatchMissedButtonReleases(GdkEventCrossing* aGdkEvent);
+
+  // nsBaseWidget
+  virtual LayerManager* GetLayerManager(
+      PLayerTransactionChild* aShadowManager = nullptr,
+      LayersBackend aBackendHint = mozilla::layers::LayersBackend::LAYERS_NONE,
+      LayerManagerPersistence aPersistence = LAYER_MANAGER_CURRENT) override;
+
+  void SetCompositorWidgetDelegate(CompositorWidgetDelegate* delegate) override;
+
+  void CleanLayerManagerRecursive();
+
+  virtual int32_t RoundsWidgetCoordinatesTo() override;
+
+  void UpdateMozWindowActive();
+
+  void ForceTitlebarRedraw();
+  bool DoDrawTilebarCorners();
+  bool IsChromeWindowTitlebar();
+
+  void SetPopupWindowDecoration(bool aShowOnTaskbar);
+
+  void ApplySizeConstraints(void);
+
+  bool IsMainMenuWindow();
+  GtkWidget* ConfigureWaylandPopupWindows();
+  void PauseRemoteRenderer();
+  void HideWaylandWindow();
+  void HideWaylandTooltips();
+  void HideWaylandPopupAndAllChildren();
+  void CleanupWaylandPopups();
+  GtkWindow* GetCurrentTopmostWindow();
+  GtkWindow* GetCurrentWindow();
+  GtkWindow* GetTopmostWindow();
+  bool IsWidgetOverflowWindow();
+  nsRect mPreferredPopupRect;
+  bool mPreferredPopupRectFlushed;
+  bool mWaitingForMoveToRectCB;
+  LayoutDeviceIntRect mPendingSizeRect;
+
+  /**
+   * |mIMContext| takes all IME related stuff.
+   *
+   * This is owned by the top-level nsWindow or the topmost child
+   * nsWindow embedded in a non-Gecko widget.
+   *
+   * The instance is created when the top level widget is created.  And when
+   * the widget is destroyed, it's released.  All child windows refer its
+   * ancestor widget's instance.  So, one set of IM contexts is created for
+   * all windows in a hierarchy.  If the children are released after the top
+   * level window is released, the children still have a valid pointer,
+   * however, IME doesn't work at that time.
+   */
+  RefPtr<mozilla::widget::IMContextWrapper> mIMContext;
+
+#ifdef MOZ_X11
+  mozilla::UniquePtr<mozilla::CurrentX11TimeGetter> mCurrentTimeGetter;
+#endif
+  static CSDSupportLevel sCSDSupportLevel;
+
+  static bool sTransparentMainWindow;
+};
+
+#endif /* __nsWindow_h__ */
diff --git a/widget/moz.build b/widget/moz.build
index 0547242073..1ac688804d 100644
--- a/widget/moz.build
+++ b/widget/moz.build
@@ -266,10 +266,14 @@ if CONFIG["MOZ_INSTRUMENT_EVENT_LOOP"]:
 
 EXPORTS.ipc = ["nsGUIEventIPC.h"]
 
-if CONFIG["MOZ_X11"]:
+if CONFIG["MOZ_X11"] or CONFIG["MOZ_WAYLAND"]:
     DIRS += ["x11"]
     SOURCES += [
         "GfxInfoX11.cpp",
+    ]
+
+if CONFIG["MOZ_X11"]:
+    SOURCES += [
         "nsShmImage.cpp",
         "WindowSurfaceX11SHM.cpp",
     ]
@@ -330,7 +334,7 @@ if toolkit == "windows":
         "windows/PCompositorWidget.ipdl",
         "windows/PlatformWidgetTypes.ipdlh",
     ]
-elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk" and CONFIG["MOZ_X11"]:
+elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
     IPDL_SOURCES = [
         "gtk/PCompositorWidget.ipdl",
         "gtk/PlatformWidgetTypes.ipdlh",
diff --git a/widget/moz.build.orig b/widget/moz.build.orig
new file mode 100644
index 0000000000..d434091160
--- /dev/null
+++ b/widget/moz.build.orig
@@ -0,0 +1,364 @@
+# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+with Files("**"):
+    BUG_COMPONENT = ("Core", "Widget")
+
+with Files("crashtests/*1128214*"):
+    BUG_COMPONENT = ("Core", "Layout")
+
+with Files("crashtests/*303901*"):
+    BUG_COMPONENT = ("Core", "Graphics")
+
+with Files("crashtests/*380359*"):
+    BUG_COMPONENT = ("Core", "Widget")
+
+with Files("reftests/**"):
+    BUG_COMPONENT = ("Core", "Widget: Cocoa")
+
+with Files("reftests/*fallback*"):
+    BUG_COMPONENT = ("Core", "Layout: Form Controls")
+
+with Files("*CompositorWidget*"):
+    BUG_COMPONENT = ("Core", "Graphics")
+
+with Files("*Gfx*"):
+    BUG_COMPONENT = ("Core", "Graphics")
+
+with Files("*WindowSurface*"):
+    BUG_COMPONENT = ("Core", "Graphics")
+
+with Files("*FontRange*"):
+    BUG_COMPONENT = ("Core", "Widget: Cocoa")
+
+toolkit = CONFIG["MOZ_WIDGET_TOOLKIT"]
+
+if toolkit in ("cocoa", "android", "uikit"):
+    DIRS += [toolkit]
+
+if toolkit == "windows":
+    DIRS += ["windows"]
+
+    XPIDL_SOURCES += [
+        "nsIJumpListBuilder.idl",
+        "nsIJumpListItem.idl",
+        "nsIPrintSettingsWin.idl",
+        "nsITaskbarOverlayIconController.idl",
+        "nsITaskbarPreview.idl",
+        "nsITaskbarPreviewButton.idl",
+        "nsITaskbarPreviewController.idl",
+        "nsITaskbarProgress.idl",
+        "nsITaskbarTabPreview.idl",
+        "nsITaskbarWindowPreview.idl",
+        "nsIWindowsUIUtils.idl",
+        "nsIWinTaskbar.idl",
+    ]
+elif toolkit == "cocoa":
+    XPIDL_SOURCES += [
+        "nsIMacDockSupport.idl",
+        "nsIMacFinderProgress.idl",
+        "nsIMacSharingService.idl",
+        "nsIMacWebAppUtils.idl",
+        "nsIStandaloneNativeMenu.idl",
+        "nsITaskbarProgress.idl",
+        "nsITouchBarHelper.idl",
+        "nsITouchBarInput.idl",
+        "nsITouchBarUpdater.idl",
+    ]
+    EXPORTS += [
+        "nsINativeMenuService.h",
+    ]
+
+TEST_DIRS += ["tests", "tests/gtest"]
+
+DIRS += ["headless"]
+
+# Don't build the DSO under the 'build' directory as windows does.
+#
+# The DSOs get built in the toolkit dir itself.  Do this so that
+# multiple implementations of widget can be built on the same
+# source tree.
+#
+if CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk":
+    DIRS += ["gtk"]
+
+    XPIDL_SOURCES += [
+        "nsIGtkTaskbarProgress.idl",
+        "nsITaskbarProgress.idl",
+    ]
+
+XPIDL_SOURCES += [
+    "nsIAppShell.idl",
+    "nsIBaseWindow.idl",
+    "nsIBidiKeyboard.idl",
+    "nsIClipboard.idl",
+    "nsIClipboardHelper.idl",
+    "nsIClipboardOwner.idl",
+    "nsIColorPicker.idl",
+    "nsIDisplayInfo.idl",
+    "nsIDragService.idl",
+    "nsIDragSession.idl",
+    "nsIFilePicker.idl",
+    "nsIFormatConverter.idl",
+    "nsIGfxInfo.idl",
+    "nsIGfxInfoDebug.idl",
+    "nsIPaper.idl",
+    "nsIPaperMargin.idl",
+    "nsIPrinter.idl",
+    "nsIPrinterList.idl",
+    "nsIPrintSession.idl",
+    "nsIPrintSettings.idl",
+    "nsIPrintSettingsService.idl",
+    "nsIScreen.idl",
+    "nsIScreenManager.idl",
+    "nsISharePicker.idl",
+    "nsISound.idl",
+    "nsISystemStatusBar.idl",
+    "nsITransferable.idl",
+    "nsIUserIdleService.idl",
+    "nsIUserIdleServiceInternal.idl",
+]
+
+XPIDL_MODULE = "widget"
+
+EXPORTS += [
+    "GfxDriverInfo.h",
+    "GfxInfoBase.h",
+    "GfxInfoCollector.h",
+    "InputData.h",
+    "nsBaseAppShell.h",
+    "nsBaseDragService.h",
+    "nsBaseFilePicker.h",
+    "nsBaseScreen.h",
+    "nsBaseWidget.h",
+    "nsIDeviceContextSpec.h",
+    "nsIKeyEventInPluginCallback.h",
+    "nsIPluginWidget.h",
+    "nsIPrintDialogService.h",
+    "nsIRollupListener.h",
+    "nsIWidget.h",
+    "nsIWidgetListener.h",
+    "nsPaper.h",
+    "nsPrinterListBase.h",
+    "nsUserIdleService.h",
+    "nsWidgetInitData.h",
+    "nsWidgetsCID.h",
+    "PuppetWidget.h",
+]
+
+EXPORTS.mozilla += [
+    "BasicEvents.h",
+    "CommandList.h",
+    "ContentCache.h",
+    "ContentEvents.h",
+    "EventClassList.h",
+    "EventForwards.h",
+    "EventMessageList.h",
+    "FontRange.h",
+    "LookAndFeel.h",
+    "MiscEvents.h",
+    "MouseEvents.h",
+    "TextEventDispatcher.h",
+    "TextEventDispatcherListener.h",
+    "TextEvents.h",
+    "TextRange.h",
+    "TouchEvents.h",
+    "VsyncDispatcher.h",
+    "WidgetUtils.h",
+]
+
+EXPORTS.mozilla.widget += [
+    "CompositorWidget.h",
+    "IconLoader.h",
+    "IMEData.h",
+    "InProcessCompositorWidget.h",
+    "MediaKeysEventSourceFactory.h",
+    "nsAutoRollup.h",
+    "PuppetBidiKeyboard.h",
+    "Screen.h",
+    "ScreenManager.h",
+    "ThemeChangeKind.h",
+    "WidgetMessageUtils.h",
+    "WindowSurface.h",
+]
+
+UNIFIED_SOURCES += [
+    "CompositorWidget.cpp",
+    "ContentCache.cpp",
+    "GfxDriverInfo.cpp",
+    "GfxInfoBase.cpp",
+    "GfxInfoCollector.cpp",
+    "IconLoader.cpp",
+    "IMEData.cpp",
+    "InProcessCompositorWidget.cpp",
+    "InputData.cpp",
+    "nsAutoRollup.cpp",
+    "nsBaseAppShell.cpp",
+    "nsBaseScreen.cpp",
+    "nsClipboardHelper.cpp",
+    "nsClipboardProxy.cpp",
+    "nsColorPickerProxy.cpp",
+    "nsContentProcessWidgetFactory.cpp",
+    "nsDragServiceProxy.cpp",
+    "nsFilePickerProxy.cpp",
+    "nsHTMLFormatConverter.cpp",
+    "nsIWidgetListener.cpp",
+    "nsNativeBasicTheme.cpp",
+    "nsPrimitiveHelpers.cpp",
+    "nsPrintSettingsImpl.cpp",
+    "nsSoundProxy.cpp",
+    "nsTransferable.cpp",
+    "nsUserIdleService.cpp",
+    "nsXPLookAndFeel.cpp",
+    "PuppetBidiKeyboard.cpp",
+    "PuppetWidget.cpp",
+    "Screen.cpp",
+    "ScrollbarDrawingMac.cpp",
+    "SharedWidgetUtils.cpp",
+    "TextEventDispatcher.cpp",
+    "TouchResampler.cpp",
+    "VsyncDispatcher.cpp",
+    "WidgetEventImpl.cpp",
+    "WidgetUtils.cpp",
+]
+
+if CONFIG["OS_ARCH"] == "Linux":
+    EXPORTS.mozilla.widget += ["LSBUtils.h"]
+    SOURCES += ["LSBUtils.cpp"]
+
+if CONFIG["MOZ_XUL"] and CONFIG["NS_PRINTING"]:
+    EXPORTS += [
+        "nsDeviceContextSpecProxy.h",
+        "nsPrintSettingsService.h",
+    ]
+    UNIFIED_SOURCES += [
+        "nsDeviceContextSpecProxy.cpp",
+        "nsPaper.cpp",
+        "nsPaperMargin.cpp",
+        "nsPrinterBase.cpp",
+        "nsPrinterListBase.cpp",
+        "nsPrintSession.cpp",
+        "nsPrintSettingsService.cpp",
+    ]
+
+    if toolkit in ("cocoa", "gtk"):
+        UNIFIED_SOURCES += [
+            "nsCUPSShim.cpp",
+            "nsPrinterCUPS.cpp",
+            "nsPrinterListCUPS.cpp",
+        ]
+
+# nsBaseWidget.cpp needs to be built separately because of name clashes in the OS X headers
+# nsBaseDragService.cpp moved out of UNIFIED to fix xgill crash (bug 1259850) after moving widget/ContentHelper -> apz/util/TouchActionHelper
+SOURCES += [
+    "nsBaseDragService.cpp",
+    "nsBaseWidget.cpp",
+    "ScreenManager.cpp",
+]
+
+if CONFIG["MOZ_INSTRUMENT_EVENT_LOOP"]:
+    EXPORTS.mozilla += [
+        "WidgetTraceEvent.h",
+    ]
+
+EXPORTS.ipc = ["nsGUIEventIPC.h"]
+
+if CONFIG["MOZ_X11"]:
+    DIRS += ["x11"]
+    SOURCES += [
+        "GfxInfoX11.cpp",
+    ]
+
+if CONFIG["MOZ_X11"]:
+    SOURCES += [
+        "nsShmImage.cpp",
+        "WindowSurfaceX11SHM.cpp",
+    ]
+
+if toolkit == "windows":
+    EXPORTS += [
+        "PluginWidgetProxy.h",
+    ]
+    SOURCES += [
+        "PluginWidgetProxy.cpp",
+    ]
+
+if toolkit in ("cocoa", "windows"):
+    UNIFIED_SOURCES += [
+        "nsBaseClipboard.cpp",
+    ]
+
+if toolkit in {"gtk", "cocoa", "windows", "android", "uikit"}:
+    UNIFIED_SOURCES += [
+        "nsBaseFilePicker.cpp",
+    ]
+
+if toolkit in ("gtk", "windows", "cocoa", "android"):
+    UNIFIED_SOURCES += [
+        "nsNativeTheme.cpp",
+    ]
+if toolkit == "gtk":
+    XPIDL_SOURCES += [
+        "nsIApplicationChooser.idl",
+    ]
+
+DEFINES["MOZ_CROSS_PROCESS_IME"] = True
+
+include("/ipc/chromium/chromium-config.mozbuild")
+
+LOCAL_INCLUDES += [
+    "/dom/base",
+    "/dom/ipc",
+    "/gfx/2d",
+    "/layout/base",
+    "/layout/forms",
+    "/layout/generic",
+    "/layout/painting",
+    "/layout/xul",
+    "/layout/xul/tree/",
+    "/view",
+    "/widget",
+    "/widget/headless",
+]
+
+# We use the CUPS headers on Cocoa and GTK, but on GTK we don't depend on there being system headers.
+if toolkit == "gtk":
+    LOCAL_INCLUDES += ["/third_party/cups/include"]
+
+if toolkit == "windows":
+    IPDL_SOURCES = [
+        "headless/HeadlessWidgetTypes.ipdlh",
+        "windows/PCompositorWidget.ipdl",
+        "windows/PlatformWidgetTypes.ipdlh",
+    ]
+elif CONFIG["MOZ_WIDGET_TOOLKIT"] == "gtk" and CONFIG["MOZ_X11"]:
+    IPDL_SOURCES = [
+        "gtk/PCompositorWidget.ipdl",
+        "gtk/PlatformWidgetTypes.ipdlh",
+        "headless/HeadlessWidgetTypes.ipdlh",
+    ]
+else:
+    IPDL_SOURCES = [
+        "generic/PCompositorWidget.ipdl",
+        "generic/PlatformWidgetTypes.ipdlh",
+        "headless/HeadlessWidgetTypes.ipdlh",
+    ]
+
+IPDL_SOURCES += [
+    "LookAndFeelTypes.ipdlh",
+]
+
+LOCAL_INCLUDES += [
+    "/widget/%s" % toolkit,
+]
+FINAL_LIBRARY = "xul"
+
+if CONFIG["MOZ_ENABLE_D3D10_LAYER"]:
+    DEFINES["MOZ_ENABLE_D3D10_LAYER"] = True
+
+CXXFLAGS += CONFIG["TK_CFLAGS"]
+if CONFIG["MOZ_WAYLAND"]:
+    CXXFLAGS += CONFIG["MOZ_WAYLAND_CFLAGS"]
-- 
2.30.0

