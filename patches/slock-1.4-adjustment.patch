diff -uNr slock-1.4/config.def.h slock-1.4-dmps.message/config.def.h
--- slock-1.4/config.def.h	2016-11-19 18:31:23.000000000 -0600
+++ slock-1.4-dmps.message/config.def.h	2019-02-16 18:56:36.406057235 -0600
@@ -10,3 +10,15 @@
 
 /* treat a cleared input like a wrong password (color) */
 static const int failonclear = 1;
+
+/* time in seconds before the monitor shuts down */
+static const int monitortime = 60;
+
+/* default message */
+static const char * message = "Suckless: Software that sucks less.";
+
+/* text color */
+static const char * text_color = "#ffffff";
+
+/* text size (must be a valid size) */
+static const char * text_size = "6x13";
diff -uNr slock-1.4/config.mk slock-1.4-dmps.message/config.mk
--- slock-1.4/config.mk	2016-11-19 18:31:23.000000000 -0600
+++ slock-1.4-dmps.message/config.mk	2019-02-16 17:31:10.633138215 -0600
@@ -4,11 +4,11 @@
 # Customize below to fit your system
 
 # paths
-PREFIX = /usr/local
+PREFIX = /usr
 MANPREFIX = ${PREFIX}/share/man
 
-X11INC = /usr/X11R6/include
-X11LIB = /usr/X11R6/lib
+X11INC = /usr/X11/include
+X11LIB = /usr/X11/lib
 
 # includes and libs
 INCS = -I. -I/usr/include -I${X11INC}
diff -uNr slock-1.4/slock.1 slock-1.4-dmps.message/slock.1
--- slock-1.4/slock.1	2016-11-19 18:31:23.000000000 -0600
+++ slock-1.4-dmps.message/slock.1	2019-02-16 17:31:10.634138202 -0600
@@ -6,6 +6,7 @@
 .Sh SYNOPSIS
 .Nm
 .Op Fl v
+.Op Fl m Ar message
 .Op Ar cmd Op Ar arg ...
 .Sh DESCRIPTION
 .Nm
@@ -16,6 +17,9 @@
 .Bl -tag -width Ds
 .It Fl v
 Print version information to stdout and exit.
+.It Fl m Ar message
+Overrides default slock lock message.
+.TP
 .El
 .Sh SECURITY CONSIDERATIONS
 To make sure a locked screen can not be bypassed by switching VTs
diff -uNr slock-1.4/slock.c slock-1.4-dmps.message/slock.c
--- slock-1.4/slock.c	2016-11-19 18:31:23.000000000 -0600
+++ slock-1.4-dmps.message/slock.c	2019-02-16 17:31:35.175831389 -0600
@@ -15,6 +15,7 @@
 #include <unistd.h>
 #include <sys/types.h>
 #include <X11/extensions/Xrandr.h>
+#include <X11/extensions/dpms.h>
 #include <X11/keysym.h>
 #include <X11/Xlib.h>
 #include <X11/Xutil.h>
@@ -62,6 +63,71 @@
 #include <linux/oom.h>
 
 static void
+writemessage(Display *dpy, Window win, int screen)
+{
+	int len, line_len, width, height, i, j, k, tab_replace, tab_size;
+	XGCValues gr_values;
+	XFontStruct *fontinfo;
+	XColor color, dummy;
+	GC gc;
+	fontinfo = XLoadQueryFont(dpy, text_size);
+	tab_size = 8 * XTextWidth(fontinfo, " ", 1);
+
+	XAllocNamedColor(dpy, DefaultColormap(dpy, screen),
+			 text_color, &color, &dummy);
+
+	gr_values.font = fontinfo->fid;
+	gr_values.foreground = color.pixel;
+	gc=XCreateGC(dpy,win,GCFont+GCForeground, &gr_values);
+
+
+	/*
+	 * Start formatting and drawing text
+	 */
+
+	len = strlen(message);
+
+	/* Max max line length (cut at '\n') */
+	line_len = 0;
+	k = 0;
+	for (i = j = 0; i < len; i++) {
+		if (message[i] == '\n') {
+			if (i - j > line_len)
+				line_len = i - j;
+			k++;
+			i++;
+			j = i;
+		}
+	}
+	/* If there is only one line */
+	if (line_len == 0)
+		line_len = len;
+
+	height = DisplayHeight(dpy, screen)*3/7 - (k*20)/3;
+	width  = (DisplayWidth(dpy, screen) - XTextWidth(fontinfo, message, line_len))/2;
+
+	/* Look for '\n' and print the text between them. */
+	for (i = j = k = 0; i <= len; i++) {
+		/* i == len is the special case for the last line */
+		if (i == len || message[i] == '\n') {
+			tab_replace = 0;
+			while (message[j] == '\t' && j < i) {
+				tab_replace++;
+				j++;
+			}
+
+			XDrawString(dpy, win, gc, width + tab_size*tab_replace, height + 20*k, message + j, i - j);
+			while (i < len && message[i] == '\n') {
+				i++;
+				j = i;
+				k++;
+			}
+		}
+	}
+}
+
+
+static void
 dontkillme(void)
 {
 	FILE *f;
@@ -194,6 +260,7 @@
 					                     locks[screen]->win,
 					                     locks[screen]->colors[color]);
 					XClearWindow(dpy, locks[screen]->win);
+					writemessage(dpy, locks[screen]->win, screen);
 				}
 				oldc = color;
 			}
@@ -290,9 +357,17 @@
 }
 
 static void
+monitorreset(Display* dpy, CARD16 standby, CARD16 suspend, CARD16 off)
+{
+	DPMSSetTimeouts(dpy, standby, suspend, off);
+	DPMSForceLevel(dpy, DPMSModeOn);
+	XFlush(dpy);
+}
+
+static void
 usage(void)
 {
-	die("usage: slock [-v] [cmd [arg ...]]\n");
+	die("usage: slock [-v] [-m message] [cmd [arg ...]]\n");
 }
 
 int
@@ -306,11 +381,15 @@
 	const char *hash;
 	Display *dpy;
 	int s, nlocks, nscreens;
+	CARD16 standby, suspend, off;
 
 	ARGBEGIN {
 	case 'v':
 		fprintf(stderr, "slock-"VERSION"\n");
 		return 0;
+	case 'm':
+		message = EARGF(usage());
+		break;
 	default:
 		usage();
 	} ARGEND
@@ -355,10 +434,12 @@
 	if (!(locks = calloc(nscreens, sizeof(struct lock *))))
 		die("slock: out of memory\n");
 	for (nlocks = 0, s = 0; s < nscreens; s++) {
-		if ((locks[s] = lockscreen(dpy, &rr, s)) != NULL)
+		if ((locks[s] = lockscreen(dpy, &rr, s)) != NULL) {
+			writemessage(dpy, locks[s]->win, s);
 			nlocks++;
-		else
+		} else {
 			break;
+		}
 	}
 	XSync(dpy, 0);
 
@@ -366,12 +447,28 @@
 	if (nlocks != nscreens)
 		return 1;
 
+	/* DPMS-magic to disable the monitor */
+	if (!DPMSCapable(dpy))
+		die("slock: DPMSCapable failed\n");
+	if (!DPMSEnable(dpy))
+		die("slock: DPMSEnable failed\n");
+	if (!DPMSGetTimeouts(dpy, &standby, &suspend, &off))
+		die("slock: DPMSGetTimeouts failed\n");
+	if (!standby || !suspend || !off)
+		/* set values if there arent some */
+		standby = suspend = off = 300;
+
+	DPMSSetTimeouts(dpy, monitortime, monitortime, monitortime);
+	XFlush(dpy);
+
 	/* run post-lock command */
 	if (argc > 0) {
 		switch (fork()) {
 		case -1:
 			die("slock: fork failed: %s\n", strerror(errno));
 		case 0:
+			monitorreset(dpy, standby, suspend, off);
+
 			if (close(ConnectionNumber(dpy)) < 0)
 				die("slock: close: %s\n", strerror(errno));
 			execvp(argv[0], argv);
@@ -383,5 +480,8 @@
 	/* everything is now blank. Wait for the correct password */
 	readpw(dpy, &rr, locks, nscreens, hash);
 
+	/* reset DPMS values to inital ones */
+	monitorreset(dpy, standby, suspend, off);
+
 	return 0;
 }
diff -uNr slock-1.4/slock.c.orig slock-1.4-dmps.message/slock.c.orig
--- slock-1.4/slock.c.orig	1969-12-31 18:00:00.000000000 -0600
+++ slock-1.4-dmps.message/slock.c.orig	2019-02-16 17:31:10.634138202 -0600
@@ -0,0 +1,458 @@
+/* See LICENSE file for license details. */
+#define _XOPEN_SOURCE 500
+#if HAVE_SHADOW_H
+#include <shadow.h>
+#endif
+
+#include <ctype.h>
+#include <errno.h>
+#include <grp.h>
+#include <pwd.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <X11/extensions/Xrandr.h>
+#include <X11/keysym.h>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+#include "arg.h"
+#include "util.h"
+
+char *argv0;
+
+enum {
+	INIT,
+	INPUT,
+	FAILED,
+	NUMCOLS
+};
+
+struct lock {
+	int screen;
+	Window root, win;
+	Pixmap pmap;
+	unsigned long colors[NUMCOLS];
+};
+
+struct xrandr {
+	int active;
+	int evbase;
+	int errbase;
+};
+
+#include "config.h"
+
+static void
+die(const char *errstr, ...)
+{
+	va_list ap;
+
+	va_start(ap, errstr);
+	vfprintf(stderr, errstr, ap);
+	va_end(ap);
+	exit(1);
+}
+
+#ifdef __linux__
+#include <fcntl.h>
+#include <linux/oom.h>
+
+static void
+writemessage(Display *dpy, Window win, int screen)
+{
+	int len, line_len, width, height, i, j, k, tab_replace, tab_size;
+	XGCValues gr_values;
+	XFontStruct *fontinfo;
+	XColor color, dummy;
+	GC gc;
+	fontinfo = XLoadQueryFont(dpy, text_size);
+	tab_size = 8 * XTextWidth(fontinfo, " ", 1);
+
+	XAllocNamedColor(dpy, DefaultColormap(dpy, screen),
+			 text_color, &color, &dummy);
+
+	gr_values.font = fontinfo->fid;
+	gr_values.foreground = color.pixel;
+	gc=XCreateGC(dpy,win,GCFont+GCForeground, &gr_values);
+
+
+	/*
+	 * Start formatting and drawing text
+	 */
+
+	len = strlen(message);
+
+	/* Max max line length (cut at '\n') */
+	line_len = 0;
+	k = 0;
+	for (i = j = 0; i < len; i++) {
+		if (message[i] == '\n') {
+			if (i - j > line_len)
+				line_len = i - j;
+			k++;
+			i++;
+			j = i;
+		}
+	}
+	/* If there is only one line */
+	if (line_len == 0)
+		line_len = len;
+
+	height = DisplayHeight(dpy, screen)*3/7 - (k*20)/3;
+	width  = (DisplayWidth(dpy, screen) - XTextWidth(fontinfo, message, line_len))/2;
+
+	/* Look for '\n' and print the text between them. */
+	for (i = j = k = 0; i <= len; i++) {
+		/* i == len is the special case for the last line */
+		if (i == len || message[i] == '\n') {
+			tab_replace = 0;
+			while (message[j] == '\t' && j < i) {
+				tab_replace++;
+				j++;
+			}
+
+			XDrawString(dpy, win, gc, width + tab_size*tab_replace, height + 20*k, message + j, i - j);
+			while (i < len && message[i] == '\n') {
+				i++;
+				j = i;
+				k++;
+			}
+		}
+	}
+}
+
+
+static void
+dontkillme(void)
+{
+	FILE *f;
+	const char oomfile[] = "/proc/self/oom_score_adj";
+
+	if (!(f = fopen(oomfile, "w"))) {
+		if (errno == ENOENT)
+			return;
+		die("slock: fopen %s: %s\n", oomfile, strerror(errno));
+	}
+	fprintf(f, "%d", OOM_SCORE_ADJ_MIN);
+	if (fclose(f)) {
+		if (errno == EACCES)
+			die("slock: unable to disable OOM killer. "
+			    "Make sure to suid or sgid slock.\n");
+		else
+			die("slock: fclose %s: %s\n", oomfile, strerror(errno));
+	}
+}
+#endif
+
+static const char *
+gethash(void)
+{
+	const char *hash;
+	struct passwd *pw;
+
+	/* Check if the current user has a password entry */
+	errno = 0;
+	if (!(pw = getpwuid(getuid()))) {
+		if (errno)
+			die("slock: getpwuid: %s\n", strerror(errno));
+		else
+			die("slock: cannot retrieve password entry\n");
+	}
+	hash = pw->pw_passwd;
+
+#if HAVE_SHADOW_H
+	if (!strcmp(hash, "x")) {
+		struct spwd *sp;
+		if (!(sp = getspnam(pw->pw_name)))
+			die("slock: getspnam: cannot retrieve shadow entry. "
+			    "Make sure to suid or sgid slock.\n");
+		hash = sp->sp_pwdp;
+	}
+#else
+	if (!strcmp(hash, "*")) {
+#ifdef __OpenBSD__
+		if (!(pw = getpwuid_shadow(getuid())))
+			die("slock: getpwnam_shadow: cannot retrieve shadow entry. "
+			    "Make sure to suid or sgid slock.\n");
+		hash = pw->pw_passwd;
+#else
+		die("slock: getpwuid: cannot retrieve shadow entry. "
+		    "Make sure to suid or sgid slock.\n");
+#endif /* __OpenBSD__ */
+	}
+#endif /* HAVE_SHADOW_H */
+
+	return hash;
+}
+
+static void
+readpw(Display *dpy, struct xrandr *rr, struct lock **locks, int nscreens,
+       const char *hash)
+{
+	XRRScreenChangeNotifyEvent *rre;
+	char buf[32], passwd[256], *inputhash;
+	int num, screen, running, failure, oldc;
+	unsigned int len, color;
+	KeySym ksym;
+	XEvent ev;
+
+	len = 0;
+	running = 1;
+	failure = 0;
+	oldc = INIT;
+
+	while (running && !XNextEvent(dpy, &ev)) {
+		if (ev.type == KeyPress) {
+			explicit_bzero(&buf, sizeof(buf));
+			num = XLookupString(&ev.xkey, buf, sizeof(buf), &ksym, 0);
+			if (IsKeypadKey(ksym)) {
+				if (ksym == XK_KP_Enter)
+					ksym = XK_Return;
+				else if (ksym >= XK_KP_0 && ksym <= XK_KP_9)
+					ksym = (ksym - XK_KP_0) + XK_0;
+			}
+			if (IsFunctionKey(ksym) ||
+			    IsKeypadKey(ksym) ||
+			    IsMiscFunctionKey(ksym) ||
+			    IsPFKey(ksym) ||
+			    IsPrivateKeypadKey(ksym))
+				continue;
+			switch (ksym) {
+			case XK_Return:
+				passwd[len] = '\0';
+				errno = 0;
+				if (!(inputhash = crypt(passwd, hash)))
+					fprintf(stderr, "slock: crypt: %s\n", strerror(errno));
+				else
+					running = !!strcmp(inputhash, hash);
+				if (running) {
+					XBell(dpy, 100);
+					failure = 1;
+				}
+				explicit_bzero(&passwd, sizeof(passwd));
+				len = 0;
+				break;
+			case XK_Escape:
+				explicit_bzero(&passwd, sizeof(passwd));
+				len = 0;
+				break;
+			case XK_BackSpace:
+				if (len)
+					passwd[len--] = '\0';
+				break;
+			default:
+				if (num && !iscntrl((int)buf[0]) &&
+				    (len + num < sizeof(passwd))) {
+					memcpy(passwd + len, buf, num);
+					len += num;
+				}
+				break;
+			}
+			color = len ? INPUT : ((failure || failonclear) ? FAILED : INIT);
+			if (running && oldc != color) {
+				for (screen = 0; screen < nscreens; screen++) {
+					XSetWindowBackground(dpy,
+					                     locks[screen]->win,
+					                     locks[screen]->colors[color]);
+					XClearWindow(dpy, locks[screen]->win);
+					writemessage(dpy, locks[screen]->win, screen);
+				}
+				oldc = color;
+			}
+		} else if (rr->active && ev.type == rr->evbase + RRScreenChangeNotify) {
+			rre = (XRRScreenChangeNotifyEvent*)&ev;
+			for (screen = 0; screen < nscreens; screen++) {
+				if (locks[screen]->win == rre->window) {
+					XResizeWindow(dpy, locks[screen]->win,
+					              rre->width, rre->height);
+					XClearWindow(dpy, locks[screen]->win);
+				}
+			}
+		} else for (screen = 0; screen < nscreens; screen++)
+			XRaiseWindow(dpy, locks[screen]->win);
+	}
+}
+
+static struct lock *
+lockscreen(Display *dpy, struct xrandr *rr, int screen)
+{
+	char curs[] = {0, 0, 0, 0, 0, 0, 0, 0};
+	int i, ptgrab, kbgrab;
+	struct lock *lock;
+	XColor color, dummy;
+	XSetWindowAttributes wa;
+	Cursor invisible;
+
+	if (dpy == NULL || screen < 0 || !(lock = malloc(sizeof(struct lock))))
+		return NULL;
+
+	lock->screen = screen;
+	lock->root = RootWindow(dpy, lock->screen);
+
+	for (i = 0; i < NUMCOLS; i++) {
+		XAllocNamedColor(dpy, DefaultColormap(dpy, lock->screen),
+		                 colorname[i], &color, &dummy);
+		lock->colors[i] = color.pixel;
+	}
+
+	/* init */
+	wa.override_redirect = 1;
+	wa.background_pixel = lock->colors[INIT];
+	lock->win = XCreateWindow(dpy, lock->root, 0, 0,
+	                          DisplayWidth(dpy, lock->screen),
+	                          DisplayHeight(dpy, lock->screen),
+	                          0, DefaultDepth(dpy, lock->screen),
+	                          CopyFromParent,
+	                          DefaultVisual(dpy, lock->screen),
+	                          CWOverrideRedirect | CWBackPixel, &wa);
+	lock->pmap = XCreateBitmapFromData(dpy, lock->win, curs, 8, 8);
+	invisible = XCreatePixmapCursor(dpy, lock->pmap, lock->pmap,
+	                                &color, &color, 0, 0);
+	XDefineCursor(dpy, lock->win, invisible);
+
+	/* Try to grab mouse pointer *and* keyboard for 600ms, else fail the lock */
+	for (i = 0, ptgrab = kbgrab = -1; i < 6; i++) {
+		if (ptgrab != GrabSuccess) {
+			ptgrab = XGrabPointer(dpy, lock->root, False,
+			                      ButtonPressMask | ButtonReleaseMask |
+			                      PointerMotionMask, GrabModeAsync,
+			                      GrabModeAsync, None, invisible, CurrentTime);
+		}
+		if (kbgrab != GrabSuccess) {
+			kbgrab = XGrabKeyboard(dpy, lock->root, True,
+			                       GrabModeAsync, GrabModeAsync, CurrentTime);
+		}
+
+		/* input is grabbed: we can lock the screen */
+		if (ptgrab == GrabSuccess && kbgrab == GrabSuccess) {
+			XMapRaised(dpy, lock->win);
+			if (rr->active)
+				XRRSelectInput(dpy, lock->win, RRScreenChangeNotifyMask);
+
+			XSelectInput(dpy, lock->root, SubstructureNotifyMask);
+			return lock;
+		}
+
+		/* retry on AlreadyGrabbed but fail on other errors */
+		if ((ptgrab != AlreadyGrabbed && ptgrab != GrabSuccess) ||
+		    (kbgrab != AlreadyGrabbed && kbgrab != GrabSuccess))
+			break;
+
+		usleep(100000);
+	}
+
+	/* we couldn't grab all input: fail out */
+	if (ptgrab != GrabSuccess)
+		fprintf(stderr, "slock: unable to grab mouse pointer for screen %d\n",
+		        screen);
+	if (kbgrab != GrabSuccess)
+		fprintf(stderr, "slock: unable to grab keyboard for screen %d\n",
+		        screen);
+	return NULL;
+}
+
+static void
+usage(void)
+{
+	die("usage: slock [-v] [-m message] [cmd [arg ...]]\n");
+}
+
+int
+main(int argc, char **argv) {
+	struct xrandr rr;
+	struct lock **locks;
+	struct passwd *pwd;
+	struct group *grp;
+	uid_t duid;
+	gid_t dgid;
+	const char *hash;
+	Display *dpy;
+	int s, nlocks, nscreens;
+
+	ARGBEGIN {
+	case 'v':
+		fprintf(stderr, "slock-"VERSION"\n");
+		return 0;
+	case 'm':
+		message = EARGF(usage());
+		break;
+	default:
+		usage();
+	} ARGEND
+
+	/* validate drop-user and -group */
+	errno = 0;
+	if (!(pwd = getpwnam(user)))
+		die("slock: getpwnam %s: %s\n", user,
+		    errno ? strerror(errno) : "user entry not found");
+	duid = pwd->pw_uid;
+	errno = 0;
+	if (!(grp = getgrnam(group)))
+		die("slock: getgrnam %s: %s\n", group,
+		    errno ? strerror(errno) : "group entry not found");
+	dgid = grp->gr_gid;
+
+#ifdef __linux__
+	dontkillme();
+#endif
+
+	hash = gethash();
+	errno = 0;
+	if (!crypt("", hash))
+		die("slock: crypt: %s\n", strerror(errno));
+
+	if (!(dpy = XOpenDisplay(NULL)))
+		die("slock: cannot open display\n");
+
+	/* drop privileges */
+	if (setgroups(0, NULL) < 0)
+		die("slock: setgroups: %s\n", strerror(errno));
+	if (setgid(dgid) < 0)
+		die("slock: setgid: %s\n", strerror(errno));
+	if (setuid(duid) < 0)
+		die("slock: setuid: %s\n", strerror(errno));
+
+	/* check for Xrandr support */
+	rr.active = XRRQueryExtension(dpy, &rr.evbase, &rr.errbase);
+
+	/* get number of screens in display "dpy" and blank them */
+	nscreens = ScreenCount(dpy);
+	if (!(locks = calloc(nscreens, sizeof(struct lock *))))
+		die("slock: out of memory\n");
+	for (nlocks = 0, s = 0; s < nscreens; s++) {
+		if ((locks[s] = lockscreen(dpy, &rr, s)) != NULL) {
+			writemessage(dpy, locks[s]->win, s);
+			nlocks++;
+		} else {
+			break;
+		}
+	}
+	XSync(dpy, 0);
+
+	/* did we manage to lock everything? */
+	if (nlocks != nscreens)
+		return 1;
+
+	/* run post-lock command */
+	if (argc > 0) {
+		switch (fork()) {
+		case -1:
+			die("slock: fork failed: %s\n", strerror(errno));
+		case 0:
+			if (close(ConnectionNumber(dpy)) < 0)
+				die("slock: close: %s\n", strerror(errno));
+			execvp(argv[0], argv);
+			fprintf(stderr, "slock: execvp %s: %s\n", argv[0], strerror(errno));
+			_exit(1);
+		}
+	}
+
+	/* everything is now blank. Wait for the correct password */
+	readpw(dpy, &rr, locks, nscreens, hash);
+
+	return 0;
+}
